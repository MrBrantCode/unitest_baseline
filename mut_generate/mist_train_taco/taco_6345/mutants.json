{
  "task_id": "taco_6345",
  "entry_point": "find_four_vertices",
  "mutant_count": 113,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[1] = True",
      "mutated_line": "visited[1] = False",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = False\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 1\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = -1\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 1\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "N = case['N']",
      "mutated_line": "N = case['']",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "edges = case['edges']",
      "mutated_line": "edges = case['']",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [1 for _ in range(N + 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [1 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [-1 for _ in range(N + 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [-1 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [1 for _ in range(N + 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [1 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [True for _ in range(N + 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [True for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q2 = [1]",
      "mutated_line": "q2 = [2]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [2]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q2 = [1]",
      "mutated_line": "q2 = [0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [0]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q2 = [1]",
      "mutated_line": "q2 = [0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [0]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q2 = [1]",
      "mutated_line": "q2 = [-1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [-1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[1] = True",
      "mutated_line": "visited[2] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[2] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[1] = True",
      "mutated_line": "visited[0] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[0] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[1] = True",
      "mutated_line": "visited[0] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[0] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[1] = True",
      "mutated_line": "visited[-1] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[-1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(xorl)):",
      "mutated_line": "for i in range(2, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(2, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(xorl)):",
      "mutated_line": "for i in range(0, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(0, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(xorl)):",
      "mutated_line": "for i in range(0, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(0, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(xorl)):",
      "mutated_line": "for i in range(-1, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(-1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [l[1]]",
      "mutated_line": "queue = [l[2]]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[2]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [l[1]]",
      "mutated_line": "queue = [l[0]]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[0]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [l[1]]",
      "mutated_line": "queue = [l[0]]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[0]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [l[1]]",
      "mutated_line": "queue = [l[-1]]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[-1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = queue.pop(0)",
      "mutated_line": "s = queue.pop(1)",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(1)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = queue.pop(0)",
      "mutated_line": "s = queue.pop(-1)",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(-1)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s = queue.pop(0)",
      "mutated_line": "s = queue.pop(1)",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(1)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "si = q2.pop(0)",
      "mutated_line": "si = q2.pop(1)",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(1)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "si = q2.pop(0)",
      "mutated_line": "si = q2.pop(-1)",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(-1)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "si = q2.pop(0)",
      "mutated_line": "si = q2.pop(1)",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(1)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(xorl)):",
      "mutated_line": "for j in range(i - 1, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i - 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(xorl)):",
      "mutated_line": "for j in range(i * 1, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i * 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if xorl[i] ^ xorl[j] in d:",
      "mutated_line": "if xorl[i] ^ xorl[j] not in d:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] not in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "l = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N - 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "l = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N * 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [0 for _ in range(N - 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N - 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [0 for _ in range(N * 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N * 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [False for _ in range(N - 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N - 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [False for _ in range(N * 1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N * 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[0]] = xorl[si] | i[1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] | i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "visited[i[0]] = True",
      "mutated_line": "visited[i[0]] = False",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = False\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(xorl)):",
      "mutated_line": "for j in range(i + 2, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 2, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(xorl)):",
      "mutated_line": "for j in range(i + 0, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 0, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(xorl)):",
      "mutated_line": "for j in range(i + 0, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 0, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(i + 1, len(xorl)):",
      "mutated_line": "for j in range(i + -1, len(xorl)):",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + -1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if xorl[i] ^ xorl[j] in d:",
      "mutated_line": "if xorl[i] | xorl[j] in d:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] | xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 1",
      "mutated_line": "t = 2",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 2\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 0\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 1",
      "mutated_line": "t = 0",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 0\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 1",
      "mutated_line": "t = -1",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = -1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((+1, -1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((+1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, +1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, +1, -1, -1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, +1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, +1, -1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -1, +1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, +1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 2)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 0)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 0)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + -1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [0 for _ in range(N + 2)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 2)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [0 for _ in range(N + 0)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 0)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [0 for _ in range(N + 0)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 0)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "xorl = [0 for _ in range(N + 1)]",
      "mutated_line": "xorl = [0 for _ in range(N + -1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + -1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [False for _ in range(N + 2)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 2)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [False for _ in range(N + 0)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 0)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [False for _ in range(N + 0)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 0)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [False for _ in range(N + 1)]",
      "mutated_line": "visited = [False for _ in range(N + -1)]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + -1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = d[xorl[i] ^ xorl[j]][0]",
      "mutated_line": "a = d[xorl[i] ^ xorl[j]][1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][1]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = d[xorl[i] ^ xorl[j]][0]",
      "mutated_line": "a = d[xorl[i] ^ xorl[j]][-1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][-1]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = d[xorl[i] ^ xorl[j]][0]",
      "mutated_line": "a = d[xorl[i] ^ xorl[j]][1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][1]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = d[xorl[i] ^ xorl[j]][1]",
      "mutated_line": "b = d[xorl[i] ^ xorl[j]][2]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][2]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = d[xorl[i] ^ xorl[j]][1]",
      "mutated_line": "b = d[xorl[i] ^ xorl[j]][0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][0]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = d[xorl[i] ^ xorl[j]][1]",
      "mutated_line": "b = d[xorl[i] ^ xorl[j]][0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][0]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = d[xorl[i] ^ xorl[j]][1]",
      "mutated_line": "b = d[xorl[i] ^ xorl[j]][-1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][-1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "d[xorl[i] ^ xorl[j]] = [i, j]",
      "mutated_line": "d[xorl[i] | xorl[j]] = [i, j]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] | xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-2, -1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-2, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-0, -1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-0, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-0, -1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-0, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((--1, -1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((--1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -2, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -2, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -0, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -0, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -0, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -0, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, --1, -1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, --1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -2, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -2, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -0, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -0, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -0, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -0, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, --1, -1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, --1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -1, -2))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -2))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -1, -0))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -0))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -1, -0))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -0))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "results.append((-1, -1, -1, -1))",
      "mutated_line": "results.append((-1, -1, -1, --1))",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, --1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not visited[i[0]]:",
      "mutated_line": "if not visited[i[1]]:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[1]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not visited[i[0]]:",
      "mutated_line": "if not visited[i[-1]]:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[-1]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not visited[i[0]]:",
      "mutated_line": "if not visited[i[1]]:",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[1]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[1]] = xorl[si] ^ i[1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[1]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[-1]] = xorl[si] ^ i[1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[-1]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[1]] = xorl[si] ^ i[1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[1]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[0]] = xorl[si] ^ i[2]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[2]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[0]] = xorl[si] ^ i[0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[0]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[0]] = xorl[si] ^ i[0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[0]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "xorl[i[0]] = xorl[si] ^ i[1]",
      "mutated_line": "xorl[i[0]] = xorl[si] ^ i[-1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[-1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q2.append(i[0])",
      "mutated_line": "q2.append(i[1])",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[1])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q2.append(i[0])",
      "mutated_line": "q2.append(i[-1])",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[-1])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q2.append(i[0])",
      "mutated_line": "q2.append(i[1])",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[1])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "visited[i[0]] = True",
      "mutated_line": "visited[i[1]] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[1]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "visited[i[0]] = True",
      "mutated_line": "visited[i[-1]] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[-1]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "visited[i[0]] = True",
      "mutated_line": "visited[i[1]] = True",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[1]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "a = d[xorl[i] ^ xorl[j]][0]",
      "mutated_line": "a = d[xorl[i] | xorl[j]][0]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] | xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "b = d[xorl[i] ^ xorl[j]][1]",
      "mutated_line": "b = d[xorl[i] | xorl[j]][1]",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[0]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] | xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append(l[i[0]])",
      "mutated_line": "queue.append(l[i[1]])",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[1]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append(l[i[0]])",
      "mutated_line": "queue.append(l[i[-1]])",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[-1]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append(l[i[0]])",
      "mutated_line": "queue.append(l[i[1]])",
      "code": "def find_four_vertices(test_cases):\n    results = []\n    for case in test_cases:\n        N = case['N']\n        edges = case['edges']\n        l = [[] for _ in range(N + 1)]\n        for (u, v, w) in edges:\n            l[u].append([v, w])\n            l[v].append([u, w])\n        xorl = [0 for _ in range(N + 1)]\n        visited = [False for _ in range(N + 1)]\n        queue = [l[1]]\n        q2 = [1]\n        visited[1] = True\n        while queue:\n            s = queue.pop(0)\n            si = q2.pop(0)\n            for i in s:\n                if not visited[i[0]]:\n                    xorl[i[0]] = xorl[si] ^ i[1]\n                    queue.append(l[i[1]])\n                    q2.append(i[0])\n                    visited[i[0]] = True\n        d = {}\n        t = 0\n        for i in range(1, len(xorl)):\n            for j in range(i + 1, len(xorl)):\n                if xorl[i] ^ xorl[j] in d:\n                    a = d[xorl[i] ^ xorl[j]][0]\n                    b = d[xorl[i] ^ xorl[j]][1]\n                    c1 = i\n                    d1 = j\n                    t = 1\n                    break\n                else:\n                    d[xorl[i] ^ xorl[j]] = [i, j]\n            if t:\n                break\n        if t:\n            results.append((a, b, c1, d1))\n        else:\n            results.append((-1, -1, -1, -1))\n    return results"
    }
  ]
}