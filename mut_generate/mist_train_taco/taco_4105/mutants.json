{
  "task_id": "taco_4105",
  "entry_point": "count_blankets_needed",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if xa > xb:",
      "mutated_line": "(xa, xb) = (xb, xa)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa >= xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if xa > xb:",
      "mutated_line": "(xa, xb) = (xb, xa)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa <= xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if xa > xb:",
      "mutated_line": "(xa, xb) = (xb, xa)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa != xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if ya > yb:",
      "mutated_line": "if ya >= yb:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya >= yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if ya > yb:",
      "mutated_line": "if ya <= yb:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya <= yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if ya > yb:",
      "mutated_line": "if ya != yb:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya != yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "blankets = 0",
      "mutated_line": "blankets = 1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 1\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "blankets = 0",
      "mutated_line": "blankets = -1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = -1\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "blankets = 0",
      "mutated_line": "blankets = 1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 1\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 / (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 / (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 + (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 + (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 ** (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 ** (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return total_generals - blankets",
      "mutated_line": "return total_generals + blankets",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals + blankets"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return total_generals - blankets",
      "mutated_line": "return total_generals * blankets",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals * blankets"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 3 * (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 3 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 1 * (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 1 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 0 * (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 0 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 1 * (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 1 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = -2 * (xb - xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = -2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 * (xb - xa + yb + ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb + ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 * ((xb - xa + yb) * ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * ((xb - xa + yb) * ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 - (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 - (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 * (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 * (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for x in range(xa, xb + 1):",
      "mutated_line": "for x in range(xa, xb - 1):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb - 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for x in range(xa, xb + 1):",
      "mutated_line": "for x in range(xa, xb * 1):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb * 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for y in range(ya + 1, yb):",
      "mutated_line": "for y in range(ya - 1, yb):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya - 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for y in range(ya + 1, yb):",
      "mutated_line": "for y in range(ya * 1, yb):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya * 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 * (xb - xa - yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa - yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 * ((xb - xa) * yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * ((xb - xa) * yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) * 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) * 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt(x1 - x2 + 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt(x1 - x2 + 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) * 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) * 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2 + 2))",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2 + 2))\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) < r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) < r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) > r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) > r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) == r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) == r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for x in range(xa, xb + 1):",
      "mutated_line": "for x in range(xa, xb + 2):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 2):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for x in range(xa, xb + 1):",
      "mutated_line": "for x in range(xa, xb + 0):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 0):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for x in range(xa, xb + 1):",
      "mutated_line": "for x in range(xa, xb + 0):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 0):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for x in range(xa, xb + 1):",
      "mutated_line": "for x in range(xa, xb + -1):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + -1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) <= r or distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r or distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "blankets += 1",
      "mutated_line": "blankets -= 1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets -= 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) < r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) < r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) > r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) > r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) == r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) == r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for y in range(ya + 1, yb):",
      "mutated_line": "for y in range(ya + 2, yb):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 2, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for y in range(ya + 1, yb):",
      "mutated_line": "for y in range(ya + 0, yb):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 0, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for y in range(ya + 1, yb):",
      "mutated_line": "for y in range(ya + 0, yb):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 0, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for y in range(ya + 1, yb):",
      "mutated_line": "for y in range(ya + -1, yb):",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + -1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) <= r or distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r or distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "blankets += 1",
      "mutated_line": "blankets -= 1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets -= 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 * (xb + xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb + xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "total_generals = 2 * (xb - xa + yb - ya)",
      "mutated_line": "total_generals = 2 * (xb * xa + yb - ya)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb * xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 + x2) ** 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 + x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 * x2) ** 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 * x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 3 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 3 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 0 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 0 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** -2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** -2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 + y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 + y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 * y2) ** 2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 * y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 3)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 3)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 0)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 0)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** -2)",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** -2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) < r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) < r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) > r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) > r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) == r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) == r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) <= r and distance(x, y, u, v) < r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) < r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) <= r and distance(x, y, u, v) > r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) > r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x - u) <= r and distance(x, y, u, v) == r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) == r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += 2",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 2\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += 0",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 0\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += 0",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 0\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += -1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += -1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) < r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) < r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) > r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) > r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) == r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) == r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) <= r and distance(x, y, u, v) < r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) < r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) <= r and distance(x, y, u, v) > r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) > r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y - v) <= r and distance(x, y, u, v) == r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) == r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += 2",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 2\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += 0",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 0\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += 0",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 0\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "blankets += 1",
      "mutated_line": "blankets += -1",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += -1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v + y) <= r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v + y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(v * y) <= r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v * y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u + x) <= r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u + x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]",
      "mutated_line": "p = [(u, v, r) for (u, v, r) in radiators if abs(u * x) <= r]",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u * x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x + u) <= r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x + u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if abs(x - u) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(x * u) <= r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x * u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y - v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y + v) <= r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y + v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if abs(y - v) <= r and distance(x, y, u, v) <= r:",
      "mutated_line": "if abs(y * v) <= r and distance(x, y, u, v) <= r:",
      "code": "import math\n\ndef count_blankets_needed(table_corners, radiators):\n    (xa, ya, xb, yb) = table_corners\n    if xa > xb:\n        (xa, xb) = (xb, xa)\n    if ya > yb:\n        (ya, yb) = (yb, ya)\n\n    def distance(x1, y1, x2, y2):\n        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    blankets = 0\n    for y in [ya, yb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(v - y) <= r]\n        for x in range(xa, xb + 1):\n            for (u, v, r) in p:\n                if abs(x - u) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    for x in [xa, xb]:\n        p = [(u, v, r) for (u, v, r) in radiators if abs(u - x) <= r]\n        for y in range(ya + 1, yb):\n            for (u, v, r) in p:\n                if abs(y * v) <= r and distance(x, y, u, v) <= r:\n                    blankets += 1\n                    break\n    total_generals = 2 * (xb - xa + yb - ya)\n    return total_generals - blankets"
    }
  ]
}