{
  "task_id": "taco_13225",
  "entry_point": "calculate_sum_of_permutations",
  "mutant_count": 298,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C -= A[n - 1] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C -= A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T -= C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T -= C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 * 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 * 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 + 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 + 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] / (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] / (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] + (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] + (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] ** (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] ** (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] / (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] / (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] + (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] + (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] ** (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] ** (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "counter[x] += 1",
      "mutated_line": "counter[x] -= 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] -= 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k and k < 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k and k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] * invfac[k] * invfac[n - k] * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] * mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] * invfac[k] * invfac[n - k] + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] + mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) * mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2) + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2) + mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "T = 0",
      "mutated_line": "T = 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 1\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "T = 0",
      "mutated_line": "T = -1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = -1\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "T = 0",
      "mutated_line": "T = 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 1\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A_C = 0",
      "mutated_line": "A_C = 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 1\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A_C = 0",
      "mutated_line": "A_C = -1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = -1\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "A_C = 0",
      "mutated_line": "A_C = 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 1\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] / (n + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] / (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] + (n + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] + (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] ** (n + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] ** (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 2\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 0\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 0\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = -1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T -= C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T -= C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C -= A[i - 1] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C -= A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] / C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] / C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] + C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] + C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] ** C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] ** C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = S[n] * fac[T] * A_C * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C * mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = S[n] * fac[T] * A_C + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C + mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 11 ** 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 11 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 9 ** 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 9 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 0 ** 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 0 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 1 ** 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 1 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = -10 ** 5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = -10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 ** 6",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 6\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 ** 4",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 4\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 ** 0",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 0\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 ** 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 1\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "N_max = 10 ** 5",
      "mutated_line": "N_max = 10 ** -5",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** -5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] * (N_max - 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max - 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] * (N_max * 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max * 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] * (N_max - 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max - 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] * (N_max * 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max * 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(3, N_max + 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(3, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(1, N_max + 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(1, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(0, N_max + 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(0, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(1, N_max + 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(1, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(-2, N_max + 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(-2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(2, N_max - 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max - 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(2, N_max * 1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max * 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] * i * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i * mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] * i + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i + mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod + 2, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod + 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod * 2, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod * 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i + 1) * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) * mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i + 1) + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) + mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "counter[x] += 1",
      "mutated_line": "counter[x] += 2",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 2\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "counter[x] += 1",
      "mutated_line": "counter[x] += 0",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 0\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "counter[x] += 1",
      "mutated_line": "counter[x] += 0",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 0\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "counter[x] += 1",
      "mutated_line": "counter[x] += -1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += -1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n <= k or k < 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n <= k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n >= k or k < 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n >= k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n != k or k < 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n != k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k <= 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k <= 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k >= 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k >= 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k != 0:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k != 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 1\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return -1\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 1\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] * invfac[k] / invfac[n - k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] / invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return (fac[n] * invfac[k] + invfac[n - k]) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return (fac[n] * invfac[k] + invfac[n - k]) % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return (fac[n] * invfac[k]) ** invfac[n - k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return (fac[n] * invfac[k]) ** invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) + binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) + binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return n * binomial(n + 1, k + 1) * binomial(n + 1, k + 2) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return n * binomial(n + 1, k + 1) * binomial(n + 1, k + 2) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] * (n - 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n - 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] * (n * 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n * 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = p * invfac[c] % mod",
      "mutated_line": "p = p * invfac[c] * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] * mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = p * invfac[c] % mod",
      "mutated_line": "p = p * invfac[c] + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] + mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(2, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(0, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(0, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(-1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] / C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] / C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] + C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] + C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] ** C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] ** C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T - 1] * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] * mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T - 1] + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] + mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = S[i] * A_C * p * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p * mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = S[i] * A_C * p + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p + mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) * mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) * mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) + mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) + mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T += C[n + 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n + 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T += C[n * 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n * 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = S[n] * fac[T] / A_C % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] / A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = (S[n] * fac[T] + A_C) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = (S[n] * fac[T] + A_C) % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = (S[n] * fac[T]) ** A_C % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = (S[n] * fac[T]) ** A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [2] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [2] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [0] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [0] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [0] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [0] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [-1] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [-1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] * (N_max + 2)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 2)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] * (N_max + 0)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 0)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] * (N_max + 0)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 0)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "fac = [1] * (N_max + 1)",
      "mutated_line": "fac = [1] * (N_max + -1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + -1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [2] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [2] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [0] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [0] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [0] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [0] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [-1] * (N_max + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [-1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] * (N_max + 2)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 2)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] * (N_max + 0)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 0)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] * (N_max + 0)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 0)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "invfac = [1] * (N_max + 1)",
      "mutated_line": "invfac = [1] * (N_max + -1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + -1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(2, N_max + 2):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 2):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(2, N_max + 0):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 0):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(2, N_max + 0):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 0):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, N_max + 1):",
      "mutated_line": "for i in range(2, N_max + -1):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + -1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] / i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] / i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = (fac[i - 1] + i) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = (fac[i - 1] + i) % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 1] ** i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] ** i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod - 3, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 3, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod - 1, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 1, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod - 0, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 0, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod - 1, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 1, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invfac[N_max] = pow(fac[N_max], mod - 2, mod)",
      "mutated_line": "invfac[N_max] = pow(fac[N_max], mod - -2, mod)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - -2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in reversed(range(2, N_max)):",
      "mutated_line": "for i in reversed(range(3, N_max)):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(3, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in reversed(range(2, N_max)):",
      "mutated_line": "for i in reversed(range(1, N_max)):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(1, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in reversed(range(2, N_max)):",
      "mutated_line": "for i in reversed(range(0, N_max)):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(0, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in reversed(range(2, N_max)):",
      "mutated_line": "for i in reversed(range(1, N_max)):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(1, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in reversed(range(2, N_max)):",
      "mutated_line": "for i in reversed(range(-2, N_max)):",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(-2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] / (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] / (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = (invfac[i + 1] + (i + 1)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = (invfac[i + 1] + (i + 1)) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] ** (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] ** (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k < 1:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 1:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k < -1:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < -1:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n < k or k < 0:",
      "mutated_line": "if n < k or k < 1:",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 1:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] / invfac[k] * invfac[n - k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] / invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return (fac[n] + invfac[k]) * invfac[n - k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return (fac[n] + invfac[k]) * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] ** invfac[k] * invfac[n - k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] ** invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n / binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n / binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n + binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n + binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n ** binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n ** binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [1] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [-1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [-1] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [1] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] * (n + 2)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 2)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] * (n + 0)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 0)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] * (n + 0)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 0)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S = [0] * (n + 1)",
      "mutated_line": "S = [0] * (n + -1)",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + -1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = p * invfac[c] % mod",
      "mutated_line": "p = p / invfac[c] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p / invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = p * invfac[c] % mod",
      "mutated_line": "p = (p + invfac[c]) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = (p + invfac[c]) % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = p * invfac[c] % mod",
      "mutated_line": "p = p ** invfac[c] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p ** invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T += C[i + 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i + 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T += C[i * 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i * 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] / fac[T - 1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] / fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = (fac[N - T] + fac[T - 1]) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = (fac[N - T] + fac[T - 1]) % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] ** fac[T - 1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] ** fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = S[i] * A_C / p % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C / p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = (S[i] * A_C + p) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = (S[i] * A_C + p) % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = (S[i] * A_C) ** p % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = (S[i] * A_C) ** p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] / ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] / ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = (S[i] + ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T))) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = (S[i] + ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T))) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] ** ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] ** ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n + 1] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n + 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n * 1] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n * 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] * C[n + 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n + 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] * C[n * 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n * 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T += C[n - 2]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 2]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T += C[n - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 0]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T += C[n - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 0]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "T += C[n - 1]",
      "mutated_line": "T += C[n - -1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - -1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = S[n] / fac[T] * A_C % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] / fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = (S[n] + fac[T]) * A_C % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = (S[n] + fac[T]) * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "S[n] = S[n] * fac[T] * A_C % mod",
      "mutated_line": "S[n] = S[n] ** fac[T] * A_C % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] ** fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i - 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i - 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i * 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i * 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] * invfac[k] * invfac[n + k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n + k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return fac[n] * invfac[k] * invfac[n - k] % mod",
      "mutated_line": "return fac[n] * invfac[k] * invfac[n * k] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n * k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n - 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n - 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n * 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n * 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k - 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k - 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k * 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k * 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T += C[i - 2]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 2]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T += C[i - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 0]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T += C[i - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 0]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "T += C[i - 1]",
      "mutated_line": "T += C[i - -1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - -1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i + 1] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i + 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i * 1] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i * 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] * C[i + 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i + 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] * C[i * 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i * 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = S[i] / A_C * p % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] / A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = (S[i] + A_C) * p % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = (S[i] + A_C) * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "S[i] = S[i] * A_C * p % mod",
      "mutated_line": "S[i] = S[i] ** A_C * p % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] ** A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) + sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) + sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) * sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) * sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 2] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 2] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 0] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 0] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 0] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 0] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - -1] * C[n - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - -1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] * C[n - 2]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 2]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] * C[n - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 0]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] * C[n - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 0]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "A_C += A[n - 1] * C[n - 1]",
      "mutated_line": "A_C += A[n - 1] * C[n - -1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - -1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i + 1] * i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i + 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i * 1] * i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i * 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i - 1] * (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i - 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i * 1] * (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i * 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i + 2) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 2) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i + 0) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 0) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i + 0) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 0) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 1] * (i + -1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + -1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n - 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n - 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n * 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n * 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k - 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k - 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k * 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k * 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 2, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 2, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 0, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 0, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 0, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 0, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + -1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + -1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 3)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 3)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 1)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 1)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 0)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 0)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 1)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 1)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + -2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + -2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 2] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 2] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 0] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 0] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 0] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 0] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - -1] * C[i - 1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - -1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] * C[i - 2]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 2]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] * C[i - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 0]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] * C[i - 0]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 0]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "A_C += A[i - 1] * C[i - 1]",
      "mutated_line": "A_C += A[i - 1] * C[i - -1]",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - -1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N + T] * fac[T - 1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N + T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N * T] * fac[T - 1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N * T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T + 1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T + 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T * 1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T * 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) / binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) / binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * (N - 1 + binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * (N - 1 + binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) ** binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) ** binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 2] * i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 2] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 0] * i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 0] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - 0] * i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 0] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "fac[i] = fac[i - 1] * i % mod",
      "mutated_line": "fac[i] = fac[i - -1] * i % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - -1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 2] * (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 2] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 0] * (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 0] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + 0] * (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 0] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "invfac[i] = invfac[i + 1] * (i + 1) % mod",
      "mutated_line": "invfac[i] = invfac[i + -1] * (i + 1) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + -1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 2, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 2, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 0, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 0, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 0, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 0, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + -1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + -1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 2) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 2) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 0) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 0) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + 0) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 0) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod",
      "mutated_line": "return (n * binomial(n + 1, k + -1) - binomial(n + 1, k + 2)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + -1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T - 2] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 2] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T - 0] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 0] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T - 0] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 0] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "S[i] = fac[N - T] * fac[T - 1] % mod",
      "mutated_line": "S[i] = fac[N - T] * fac[T - -1] % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - -1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N + 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N + 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * (N * 1 * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * (N * 1 * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N + 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N + 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N * 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N * 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 + T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 + T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, (N - 1) * T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, (N - 1) * T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 2) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 2) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 0) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 0) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 0) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 0) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - -1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - -1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N + 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N + 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N * 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N * 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T + 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T + 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T * 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T * 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 3, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 3, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 1, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 1, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 0, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 0, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 1, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 1, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - -2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - -2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N + 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N + 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N * 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N * 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 2, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 2, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 0, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 0, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 0, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 0, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - -1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - -1, T - 1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 2) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 2) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 0) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 0) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 0) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 0) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - -1) - sum_(N - 2, N - 1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - -1) - sum_(N - 2, N - 1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 2 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 2 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 0 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 0 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 0 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 0 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - 1 - T)) % mod",
      "mutated_line": "S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - -1 - T)) % mod",
      "code": "from collections import defaultdict\nfrom bisect import bisect_right\n\ndef calculate_sum_of_permutations(A, Q, queries, P):\n    mod = P\n\n    def binomial(n, k):\n        if n < k or k < 0:\n            return 0\n        return fac[n] * invfac[k] * invfac[n - k] % mod\n\n    def sum_(n, k):\n        return (n * binomial(n + 1, k + 1) - binomial(n + 1, k + 2)) % mod\n\n    def init(counter):\n        n = len(counter)\n        A = sorted(counter.keys())\n        C = [counter[x] for x in A]\n        N = sum(C)\n        T = 0\n        A_C = 0\n        S = [0] * (n + 1)\n        p = 1\n        for c in C:\n            p = p * invfac[c] % mod\n        S[n] = p\n        for i in range(1, n):\n            T += C[i - 1]\n            A_C += A[i - 1] * C[i - 1]\n            S[i] = fac[N - T] * fac[T - 1] % mod\n            S[i] = S[i] * A_C * p % mod\n            S[i] = S[i] * ((N - 1) * binomial(N - 1, T - 1) - sum_(N - 2, N - -1 - T)) % mod\n        A_C += A[n - 1] * C[n - 1]\n        T += C[n - 1]\n        S[n] = S[n] * fac[T] * A_C % mod\n        return (S, A)\n    N_max = 10 ** 5\n    fac = [1] * (N_max + 1)\n    invfac = [1] * (N_max + 1)\n    for i in range(2, N_max + 1):\n        fac[i] = fac[i - 1] * i % mod\n    invfac[N_max] = pow(fac[N_max], mod - 2, mod)\n    for i in reversed(range(2, N_max)):\n        invfac[i] = invfac[i + 1] * (i + 1) % mod\n    counter = defaultdict(int)\n    for x in A:\n        counter[x] += 1\n    (S, A) = init(counter)\n    results = []\n    for M in queries:\n        i = bisect_right(A, M)\n        results.append(S[i])\n    return results"
    }
  ]
}