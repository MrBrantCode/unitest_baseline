{
  "task_id": "taco_8230",
  "entry_point": "max_possible_gcd",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ide_ele = 0",
      "mutated_line": "",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 1\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ide_ele = 0",
      "mutated_line": "",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = -1\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ide_ele = 0",
      "mutated_line": "",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 1\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 2\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 0\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 0\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = -1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "k += self.num",
      "mutated_line": "k -= self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k -= self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "l += self.num",
      "mutated_line": "l -= self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l -= self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "r += self.num",
      "mutated_line": "r -= self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r -= self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * 2 / self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 / self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * 2 + self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 + self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = ([ide_ele] * 2) ** self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = ([ide_ele] * 2) ** self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k >= 1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k >= 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k <= 1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k <= 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k != 1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k != 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while l < r:",
      "mutated_line": "while l <= r:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l <= r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while l < r:",
      "mutated_line": "while l >= r:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l >= r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while l < r:",
      "mutated_line": "while l != r:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l != r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "seg.update(i, 0)",
      "mutated_line": "seg.update(i, 1)",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 1)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "seg.update(i, 0)",
      "mutated_line": "seg.update(i, -1)",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, -1)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "seg.update(i, 0)",
      "mutated_line": "seg.update(i, 1)",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 1)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 2 << (n - 1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 2 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 0 << (n - 1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 0 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 0 << (n - 1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 0 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = -1 << (n - 1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = -1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] / 2 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] / 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = ([ide_ele] + 2) * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = ([ide_ele] + 2) * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] ** 2 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] ** 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num + 1, 0, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num + 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num * 1, 0, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num * 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 1, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 1, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, -1, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, -1, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 1, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 1, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 0, +1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, +1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k > 2:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 2:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k > 0:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 0:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k > 0:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 0:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k > 1:",
      "mutated_line": "while k > -1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > -1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 2",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 2\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 0\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 0\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "k >>= 1",
      "mutated_line": "k >>= -1",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= -1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if l & 1:",
      "mutated_line": "if l | 1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l | 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l -= 1",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l -= 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if r & 1:",
      "mutated_line": "if r | 1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r | 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "l >>= 1",
      "mutated_line": "l >>= 2",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 2\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "l >>= 1",
      "mutated_line": "l >>= 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 0\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "l >>= 1",
      "mutated_line": "l >>= 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 0\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "l >>= 1",
      "mutated_line": "l >>= -1",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= -1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r >>= 1",
      "mutated_line": "r >>= 2",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 2\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r >>= 1",
      "mutated_line": "r >>= 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 0\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r >>= 1",
      "mutated_line": "r >>= 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 0\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r >>= 1",
      "mutated_line": "r >>= -1",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= -1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = max(ans, seg.query(0, N))",
      "mutated_line": "ans = max(ans, seg.query(1, N))",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(1, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = max(ans, seg.query(0, N))",
      "mutated_line": "ans = max(ans, seg.query(-1, N))",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(-1, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = max(ans, seg.query(0, N))",
      "mutated_line": "ans = max(ans, seg.query(1, N))",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(1, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * 3 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 3 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * 1 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 1 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * 0 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 0 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * 1 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 1 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.tree = [ide_ele] * 2 * self.num",
      "mutated_line": "self.tree = [ide_ele] * -2 * self.num",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * -2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "self.tree[self.num + i] = init_val[i]",
      "mutated_line": "self.tree[self.num - i] = init_val[i]",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num - i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "self.tree[self.num + i] = init_val[i]",
      "mutated_line": "self.tree[self.num * i] = init_val[i]",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num * i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 2, 0, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 2, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 0, 0, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 0, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 0, 0, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 0, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - -1, 0, -1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - -1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 0, -2):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -2):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 0, -0):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -0):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 0, -0):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -0):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(self.num - 1, 0, -1):",
      "mutated_line": "for i in range(self.num - 1, 0, --1):",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, --1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if l & 1:",
      "mutated_line": "if l & 2:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 2:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if l & 1:",
      "mutated_line": "if l & 0:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 0:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if l & 1:",
      "mutated_line": "if l & 0:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 0:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if l & 1:",
      "mutated_line": "if l & -1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & -1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += 2",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 2\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 0\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 0\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "l += 1",
      "mutated_line": "l += -1",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += -1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r & 1:",
      "mutated_line": "if r & 2:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 2:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r & 1:",
      "mutated_line": "if r & 0:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 0:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r & 1:",
      "mutated_line": "if r & 0:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 0:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if r & 1:",
      "mutated_line": "if r & -1:",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & -1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 1 << (n + 1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n + 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 1 << (n * 1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n * 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 / i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 / i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 + i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 + i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 ** i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 ** i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i - 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i - 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i * 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i * 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 2] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 2] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 0] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 0] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 0] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 0] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> -1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> -1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k | 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k | 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 1 << (n - 2).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 2).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 1 << (n - 0).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 0).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 1 << (n - 0).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 0).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "self.num = 1 << (n - 1).bit_length()",
      "mutated_line": "self.num = 1 << (n - -1).bit_length()",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - -1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[3 * i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[3 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[1 * i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[1 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[0 * i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[0 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[1 * i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[1 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[-2 * i], self.tree[2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[-2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 / i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 / i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 + i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 + i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 ** i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 ** i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 2])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 2])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 0])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 0])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 0])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 0])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + -1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + -1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 2])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 2])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 0])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 0])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 0])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 0])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])",
      "mutated_line": "self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ -1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ -1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = self.segfunc(res, self.tree[r - 1])",
      "mutated_line": "res = self.segfunc(res, self.tree[r + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r + 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = self.segfunc(res, self.tree[r - 1])",
      "mutated_line": "res = self.segfunc(res, self.tree[r * 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r * 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[3 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[3 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[1 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[1 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[0 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[0 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[1 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[1 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[-2 * i + 1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[-2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = self.segfunc(res, self.tree[r - 1])",
      "mutated_line": "res = self.segfunc(res, self.tree[r - 2])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 2])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = self.segfunc(res, self.tree[r - 1])",
      "mutated_line": "res = self.segfunc(res, self.tree[r - 0])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 0])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = self.segfunc(res, self.tree[r - 1])",
      "mutated_line": "res = self.segfunc(res, self.tree[r - 0])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - 0])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = self.segfunc(res, self.tree[r - 1])",
      "mutated_line": "res = self.segfunc(res, self.tree[r - -1])",
      "code": "from math import gcd\n\ndef max_possible_gcd(N, A):\n\n    def segfunc(x, y):\n        return gcd(x, y)\n    ide_ele = 0\n\n    class SegTree:\n\n        def __init__(self, init_val, segfunc, ide_ele):\n            n = len(init_val)\n            self.segfunc = segfunc\n            self.ide_ele = ide_ele\n            self.num = 1 << (n - 1).bit_length()\n            self.tree = [ide_ele] * 2 * self.num\n            for i in range(n):\n                self.tree[self.num + i] = init_val[i]\n            for i in range(self.num - 1, 0, -1):\n                self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def update(self, k, x):\n            k += self.num\n            self.tree[k] = x\n            while k > 1:\n                self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n                k >>= 1\n\n        def query(self, l, r):\n            res = self.ide_ele\n            l += self.num\n            r += self.num\n            while l < r:\n                if l & 1:\n                    res = self.segfunc(res, self.tree[l])\n                    l += 1\n                if r & 1:\n                    res = self.segfunc(res, self.tree[r - -1])\n                l >>= 1\n                r >>= 1\n            return res\n    seg = SegTree(A, segfunc, ide_ele)\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, A[i])\n    return ans"
    }
  ]
}