{
  "task_id": "taco_18967",
  "entry_point": "calculate_minimum_impact_radius",
  "mutant_count": 212,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "epsilon /= 1000.0",
      "mutated_line": "epsilon *= 1000.0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon *= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "epsilon /= 1000.0",
      "mutated_line": "epsilon /= 1001.0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1001.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "epsilon /= 1000.0",
      "mutated_line": "epsilon /= 999.0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 999.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "epsilon /= 1000.0",
      "mutated_line": "epsilon /= 0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "epsilon /= 1000.0",
      "mutated_line": "epsilon /= 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "epsilon /= 1000.0",
      "mutated_line": "epsilon /= -1000.0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= -1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rmin = 0",
      "mutated_line": "rmin = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 1\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rmin = 0",
      "mutated_line": "rmin = -1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = -1\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rmin = 0",
      "mutated_line": "rmin = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 1\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin > 1e-08:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin > 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin < 1e-08:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin < 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin == 1e-08:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin == 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) * 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) * 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) // 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) // 2"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax + rmin >= 1e-08:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax + rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax * rmin >= 1e-08:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax * rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin >= 1.00000001:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1.00000001:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin >= -0.99999999:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= -0.99999999:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin >= 0:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 0:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin >= 1:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while rmax - rmin >= 1e-08:",
      "mutated_line": "while rmax - rmin >= -1e-08:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= -1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) * 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) * 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) // 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) // 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 2\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 0\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = 0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 0\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][0] = -1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = -1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 1\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = -1\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 1\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "s += dp[N][j]",
      "mutated_line": "s -= dp[N][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s -= dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s >= 1 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s >= 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s <= 1 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s <= 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s != 1 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s != 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin - rmax) / 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin - rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return rmin * rmax / 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return rmin * rmax / 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) / 3",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 3"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) / 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) / 0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) / 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (rmin + rmax) / 2",
      "mutated_line": "return (rmin + rmax) / -2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / -2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 - (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 - (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 * (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 * (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "rmax = math.sqrt(d[K - 1])",
      "mutated_line": "rmax = math.sqrt(d[K + 1])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K + 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "rmax = math.sqrt(d[K - 1])",
      "mutated_line": "rmax = math.sqrt(d[K * 1])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K * 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin - rmax) / 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin - rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = rmin * rmax / 2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = rmin * rmax / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) / 3",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 3\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) / 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 1\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) / 0",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 0\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) / 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 1\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "r = (rmin + rmax) / 2",
      "mutated_line": "r = (rmin + rmax) / -2",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / -2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] / (N + 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] / (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] + (N + 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] + (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] ** (N + 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] ** (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][1] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][-1] = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][-1] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][1] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(2, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(0, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(0, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(-1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N - 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N * 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(K, N + 1):",
      "mutated_line": "for j in range(K, N - 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N - 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(K, N + 1):",
      "mutated_line": "for j in range(K, N * 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N * 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s > 1 + epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 + epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s > 1 * epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 * epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) * 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) * 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([p[0] - X0 + 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([p[0] - X0 + 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) * 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) * 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0 + 2) for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0 + 2) for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rmax = math.sqrt(d[K - 1])",
      "mutated_line": "rmax = math.sqrt(d[K - 2])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 2])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rmax = math.sqrt(d[K - 1])",
      "mutated_line": "rmax = math.sqrt(d[K - 0])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 0])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rmax = math.sqrt(d[K - 1])",
      "mutated_line": "rmax = math.sqrt(d[K - 0])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 0])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "rmax = math.sqrt(d[K - 1])",
      "mutated_line": "rmax = math.sqrt(d[K - -1])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - -1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i >= r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i >= r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i <= r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i <= r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i != r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i != r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 2.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 2.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 0.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 0.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else -1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else -1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N - 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N - 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N * 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N * 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[1][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[-1][0] = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[-1][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][0] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[1][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 2):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 0):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 0):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + -1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i - 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i - 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i * 1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i * 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j >= 0:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j >= 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j <= 0:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j <= 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j != 0:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j != 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i != j:",
      "mutated_line": "if i == j:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i == j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] -= (1 - p[i - 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] -= (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(K, N + 1):",
      "mutated_line": "for j in range(K, N + 2):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 2):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(K, N + 1):",
      "mutated_line": "for j in range(K, N + 0):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 0):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(K, N + 1):",
      "mutated_line": "for j in range(K, N + 0):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 0):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(K, N + 1):",
      "mutated_line": "for j in range(K, N + -1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + -1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s > 2 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 2 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s > 0 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 0 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s > 0 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 0 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s > 1 - epsilon:",
      "mutated_line": "if s > -1 - epsilon:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > -1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] + X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] + X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] * X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] * X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 3 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 3 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 1 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 1 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 0 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 0 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 1 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 1 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** -2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** -2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] + Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] + Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] * Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] * Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 3 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 3 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 1 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 1 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 0 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 0 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 1 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 1 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** -2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** -2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r * 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r * 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r + 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r + 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 + i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 + i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 * (i / r ** 2)) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 * (i / r ** 2)) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[1] * (N + 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[1] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[-1] * (N + 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[-1] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[1] * (N + 1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[1] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 2) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 2) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 0) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 0) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 0) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 0) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + -1) for _ in range(N + 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + -1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(N - 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N - 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(N * 1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N * 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 2):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 2):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 0):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 0):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 0):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 0):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + -1):",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + -1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 1:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j > -1:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > -1:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 1:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] / dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] / dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] + dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] + dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] ** dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] ** dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) / dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) / dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += 1 - p[i - 1] + dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += 1 - p[i - 1] + dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) ** dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) ** dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 3 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 3 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 1 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 1 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 0 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 0 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 1 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 1 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 2) if i > r ** -2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** -2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(2 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(2 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(0 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(0 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(0 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(0 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(-1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(-1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i * r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i * r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i // r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i // r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(N + 2)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 2)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(N + 0)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 0)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(N + 0)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 0)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(N + -1)]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + -1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 + p[i - 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 + p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += 1 * p[i - 1] * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += 1 * p[i - 1] * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[1] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[1] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[-1] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[-1] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[1] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[1] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[2] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[2] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[0] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[0] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[0] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[0] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])",
      "mutated_line": "d = sorted([(p[0] - X0) ** 2 + (p[-1] - Y0) ** 2 for p in object_positions])",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[-1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / (r * 2)) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / (r * 2)) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / (r + 2)) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / (r + 2)) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i + 1] * dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i + 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i * 1] * dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i * 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 1][j + 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j + 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 1][j * 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j * 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (2 - p[i - 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (2 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (0 - p[i - 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (0 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (0 - p[i - 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (0 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (-1 - p[i - 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (-1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 3) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 3) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 1) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 1) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 0) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 0) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** 1) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 1) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]",
      "mutated_line": "p = [math.exp(1 - i / r ** -2) if i > r ** 2 else 1.0 for i in d]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** -2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 2] * dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 2] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 0] * dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 0] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 0] * dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 0] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - -1] * dp[i - 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - -1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i + 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i + 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i * 1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i * 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 2]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 2]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 0]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 0]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 0]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 0]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - -1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - -1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i + 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i + 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i * 1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i * 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) * dp[i + 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i + 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) * dp[i * 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i * 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 2][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 2][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 0][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 0][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - 0][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 0][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][j] = p[i - 1] * dp[i - 1][j - 1]",
      "mutated_line": "dp[i][j] = p[i - 1] * dp[i - -1][j - 1]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - -1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 2]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 2]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 0]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 0]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 0]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 0]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - -1]) * dp[i - 1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - -1]) * dp[i - 1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 2][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 2][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 0][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 0][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 0][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - 0][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - 1][j]",
      "mutated_line": "dp[i][j] += (1 - p[i - 1]) * dp[i - -1][j]",
      "code": "import math\n\ndef calculate_minimum_impact_radius(N, K, epsilon, X0, Y0, object_positions):\n    epsilon /= 1000.0\n    d = sorted([(p[0] - X0) ** 2 + (p[1] - Y0) ** 2 for p in object_positions])\n    rmin = 0\n    rmax = math.sqrt(d[K - 1])\n    while rmax - rmin >= 1e-08:\n        r = (rmin + rmax) / 2\n        p = [math.exp(1 - i / r ** 2) if i > r ** 2 else 1.0 for i in d]\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n        for i in range(1, N + 1):\n            for j in range(i + 1):\n                if j > 0:\n                    dp[i][j] = p[i - 1] * dp[i - 1][j - 1]\n                if i != j:\n                    dp[i][j] += (1 - p[i - 1]) * dp[i - -1][j]\n        s = 0\n        for j in range(K, N + 1):\n            s += dp[N][j]\n        if s > 1 - epsilon:\n            rmax = r\n        else:\n            rmin = r\n    return (rmin + rmax) / 2"
    }
  ]
}