{
  "task_id": "taco_11351",
  "entry_point": "minimum_casts_to_exit",
  "mutant_count": 267,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (+1, -1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (+1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-1, +1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, +1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if sx != -1:",
      "mutated_line": "if sx == -1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx == -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ma = [[0] * W for _ in range(H)]",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] / W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ma = [[0] * W for _ in range(H)]",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] + W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ma = [[0] * W for _ in range(H)]",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] ** W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if ma[x][y] == 1:",
      "mutated_line": "if ma[x][y] != 1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] != 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if z > K:",
      "mutated_line": "if z >= K:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z >= K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if z > K:",
      "mutated_line": "if z <= K:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z <= K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if z > K:",
      "mutated_line": "if z != K:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z != K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ma[x][y] = 1",
      "mutated_line": "ma[x][y] = 2",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 2\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ma[x][y] = 1",
      "mutated_line": "ma[x][y] = 0",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 0\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ma[x][y] = 1",
      "mutated_line": "ma[x][y] = 0",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 0\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ma[x][y] = 1",
      "mutated_line": "ma[x][y] = -1",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = -1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 or A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 or A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 or A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 or A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 or A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 or A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 or A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 or A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = float('inf')",
      "mutated_line": "ans = float('')",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-2, -1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-2, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-0, -1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-0, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-0, -1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-0, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (--1, -1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (--1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-1, -2)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -2)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-1, -0)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -0)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-1, -0)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -0)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sx, sy = -1, -1",
      "mutated_line": "(sx, sy) = (-1, --1)",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, --1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if A[i][j] == 'S':",
      "mutated_line": "if A[i][j] != 'S':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] != 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if sx != -1:",
      "mutated_line": "if sx != +1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != +1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ma[x][y] == 1:",
      "mutated_line": "if ma[x][y] == 2:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 2:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ma[x][y] == 1:",
      "mutated_line": "if ma[x][y] == 0:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 0:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ma[x][y] == 1:",
      "mutated_line": "if ma[x][y] == 0:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 0:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if ma[x][y] == 1:",
      "mutated_line": "if ma[x][y] == -1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == -1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x >= 0 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x >= 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x <= 0 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x <= 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x != 0 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x != 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x - 1][y] != '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] != '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y >= 0 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y >= 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y <= 0 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y <= 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y != 0 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y != 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y - 1] != '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] != '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x <= H - 1 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x <= H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x >= H - 1 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x >= H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x != H - 1 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x != H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x + 1][y] != '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] != '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y <= W - 1 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y <= W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y >= W - 1 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y >= W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y != W - 1 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y != W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y + 1] != '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] != '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ma[i][j] == 1:",
      "mutated_line": "if ma[i][j] != 1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] != 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if A[i][j] == 'S':",
      "mutated_line": "if A[i][j] == '':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == '':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sx != -1:",
      "mutated_line": "if sx != -2:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -2:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sx != -1:",
      "mutated_line": "if sx != -0:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -0:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sx != -1:",
      "mutated_line": "if sx != -0:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -0:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sx != -1:",
      "mutated_line": "if sx != --1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != --1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ma = [[0] * W for _ in range(H)]",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[1] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ma = [[0] * W for _ in range(H)]",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[-1] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ma = [[0] * W for _ in range(H)]",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[1] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 1 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 1 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > -1 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > -1 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 1 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 1 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x - 1][y] == '':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 1 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 1 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > -1 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > -1 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 1 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 1 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y - 1] == '':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H + 1 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H + 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H * 1 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H * 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x + 1][y] == '':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W + 1 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W + 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W * 1 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W * 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y + 1] == '':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "que = deque([[sx, sy, 0]])",
      "mutated_line": "que = deque([[sx, sy, 1]])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 1]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "que = deque([[sx, sy, 0]])",
      "mutated_line": "que = deque([[sx, sy, -1]])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, -1]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "que = deque([[sx, sy, 0]])",
      "mutated_line": "que = deque([[sx, sy, 1]])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 1]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ma[i][j] == 1:",
      "mutated_line": "if ma[i][j] == 2:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 2:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ma[i][j] == 1:",
      "mutated_line": "if ma[i][j] == 0:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 0:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ma[i][j] == 1:",
      "mutated_line": "if ma[i][j] == 0:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 0:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ma[i][j] == 1:",
      "mutated_line": "if ma[i][j] == -1:",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == -1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x * 1, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x * 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z - 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z - 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z * 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z * 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y + 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y * 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y * 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y + 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y * 1, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y * 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z - 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z - 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z * 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z * 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 2 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 2 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 0 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 0 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 0 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 0 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - -1 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - -1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x * 1, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x * 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z - 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z - 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z * 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z * 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 2 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 2 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 0 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 0 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 0 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 0 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - -1 and A[x][y + 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - -1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y - 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y - 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y * 1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y * 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y - 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y * 1, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y * 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z - 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z - 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z * 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z * 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K - (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K - (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, (1 + (H - i - 1) // K) * (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, (1 + (H - i - 1) // K) * (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K - (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K - (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), (1 + (W - j - 1) // K) * (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), (1 + (W - j - 1) // K) * (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K - (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K - (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), (1 + i // K) * (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), (1 + i // K) * (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K - (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K - (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), (1 + j // K) * (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), (1 + j // K) * (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x + 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x + 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x * 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x * 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 2, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 2, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 0, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 0, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 0, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 0, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - -1, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - -1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z + 2])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 2])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 0])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 0])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append([x - 1, y, z + 1])",
      "mutated_line": "que.append([x - 1, y, z + -1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + -1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y - 2] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 2] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y - 0] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 0] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y - 0] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 0] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if y > 0 and A[x][y - 1] == '.':",
      "mutated_line": "if y > 0 and A[x][y - -1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - -1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 2, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 2, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 0, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 0, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 0, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 0, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - -1, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - -1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z + 2])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 2])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 0])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 0])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "que.append([x, y - 1, z + 1])",
      "mutated_line": "que.append([x, y - 1, z + -1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + -1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x - 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x - 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x * 1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x * 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 2, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 2, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 0, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 0, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 0, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 0, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + -1, y, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + -1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z + 2])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 2])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 0])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 0])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "que.append([x + 1, y, z + 1])",
      "mutated_line": "que.append([x + 1, y, z + -1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + -1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y + 2] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 2] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y + 0] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 0] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y + 0] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 0] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if y < W - 1 and A[x][y + 1] == '.':",
      "mutated_line": "if y < W - 1 and A[x][y + -1] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + -1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 2, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 2, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 0, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 0, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 0, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 0, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + -1, z + 1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + -1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z + 2])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 2])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 0])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z + 0])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 0])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "que.append([x, y + 1, z + 1])",
      "mutated_line": "que.append([x, y + 1, z + -1])",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + -1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 - (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 - (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 * ((H - i - 1) // K) + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 * ((H - i - 1) // K) + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 - (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 - (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 * ((W - j - 1) // K) + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 * ((W - j - 1) // K) + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 - i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 - i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 * (i // K) + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 * (i // K) + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 - j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 - j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 * (j // K) + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 * (j // K) + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x - 2][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 2][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x - 0][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 0][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x - 0][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 0][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if x > 0 and A[x - 1][y] == '.':",
      "mutated_line": "if x > 0 and A[x - -1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - -1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x + 2][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 2][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x + 0][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 0][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x + 0][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 0][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x < H - 1 and A[x + 1][y] == '.':",
      "mutated_line": "if x < H - 1 and A[x + -1][y] == '.':",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + -1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 2 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 2 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 0 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 0 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 0 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 0 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, -1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, -1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) / K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) / K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) * K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) * K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) * K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) * K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if H - i - 1 + K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if H - i - 1 + K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (2 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (2 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (0 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (0 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (0 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (0 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (-1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (-1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 1), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 1), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else -1), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else -1), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 1), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 1), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 2 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 2 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 0 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 0 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 0 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 0 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), -1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), -1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) / K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) / K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) * K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) * K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) * K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) * K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if W - j - 1 + K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if W - j - 1 + K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (2 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (2 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (0 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (0 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (0 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (0 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (-1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (-1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 1), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 1), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else -1), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else -1), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 1), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 1), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 2 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 2 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 0 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 0 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 0 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 0 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), -1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), -1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i / K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i / K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i * K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i * K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i * K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i * K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i + K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i + K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (2 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (2 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (0 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (0 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (0 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (0 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (-1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (-1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 1), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 1), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else -1), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else -1), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "1 + i // K + (1 if i % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 1), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 1), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 2 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 2 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 0 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 0 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 0 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 0 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), -1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), -1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j / K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j / K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j * K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j * K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j * K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j * K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j + K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j + K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (2 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (2 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (0 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (0 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (0 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (0 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (-1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (-1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 1))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 1))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else -1))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else -1))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "1 + j // K + (1 if j % K else 0))",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 1))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 1))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i + 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i + 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i) * 1 // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i) * 1 // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i + 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i + 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i) * 1 % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i) * 1 % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j + 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j + 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j) * 1 // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j) * 1 // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j + 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j + 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j) * 1 % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j) * 1 % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H + i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H + i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H * i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H * i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 2) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 2) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 0) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 0) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 0) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 0) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - -1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - -1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H + i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H + i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H * i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H * i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 2) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 2) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 0) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 0) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 0) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 0) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - -1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - -1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W + j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W + j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W * j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W * j - 1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 2) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 2) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 0) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 0) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 0) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 0) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - -1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - -1) // K + (1 if (W - j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W + j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W + j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W * j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W * j - 1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 2) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 2) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 0) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 0) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 0) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - 0) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "1 + (W - j - 1) // K + (1 if (W - j - 1) % K else 0),",
      "mutated_line": "ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - -1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))",
      "code": "from collections import deque\n\ndef minimum_casts_to_exit(H, W, K, A):\n    (sx, sy) = (-1, -1)\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 'S':\n                (sx, sy) = (i, j)\n                break\n        if sx != -1:\n            break\n    ma = [[0] * W for _ in range(H)]\n\n    def dfs(x, y, z):\n        if ma[x][y] == 1:\n            return\n        if z > K:\n            return\n        ma[x][y] = 1\n        if x > 0 and A[x - 1][y] == '.':\n            que.append([x - 1, y, z + 1])\n        if y > 0 and A[x][y - 1] == '.':\n            que.append([x, y - 1, z + 1])\n        if x < H - 1 and A[x + 1][y] == '.':\n            que.append([x + 1, y, z + 1])\n        if y < W - 1 and A[x][y + 1] == '.':\n            que.append([x, y + 1, z + 1])\n    que = deque([[sx, sy, 0]])\n    while que:\n        (x, y, z) = que.popleft()\n        dfs(x, y, z)\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if ma[i][j] == 1:\n                ans = min(ans, 1 + (H - i - 1) // K + (1 if (H - i - 1) % K else 0), 1 + (W - j - 1) // K + (1 if (W - j - -1) % K else 0), 1 + i // K + (1 if i % K else 0), 1 + j // K + (1 if j % K else 0))\n    return ans"
    }
  ]
}