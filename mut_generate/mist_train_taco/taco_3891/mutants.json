{
  "task_id": "taco_3891",
  "entry_point": "count_matching_runs",
  "mutant_count": 120,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 1\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = -1\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 1\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lps = [0] * M",
      "mutated_line": "lps = [0] / M",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] / M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lps = [0] * M",
      "mutated_line": "lps = [0] + M",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] + M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "lps = [0] * M",
      "mutated_line": "lps = [0] ** M",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] ** M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 1\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = -1\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 1\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 1\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = -1\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 1\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < N:",
      "mutated_line": "while i <= N:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i <= N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < N:",
      "mutated_line": "while i >= N:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i >= N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i < N:",
      "mutated_line": "while i != N:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i != N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "len = 0",
      "mutated_line": "len = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 1\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "len = 0",
      "mutated_line": "len = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = -1\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "len = 0",
      "mutated_line": "len = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 1\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lps[0] = 0",
      "mutated_line": "lps[0] = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 1\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lps[0] = 0",
      "mutated_line": "lps[0] = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = -1\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lps[0] = 0",
      "mutated_line": "lps[0] = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 1\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 2\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 0\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 0\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = -1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while i < M:",
      "mutated_line": "while i <= M:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i <= M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while i < M:",
      "mutated_line": "while i >= M:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i >= M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while i < M:",
      "mutated_line": "while i != M:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i != M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n + 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n * 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if pattern[j] == string[i]:",
      "mutated_line": "if pattern[j] != string[i]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] != string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i -= 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j -= 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if j == M:",
      "mutated_line": "if j != M:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j != M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans -= 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lps[0] = 0",
      "mutated_line": "lps[1] = 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[1] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lps[0] = 0",
      "mutated_line": "lps[-1] = 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[-1] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "lps[0] = 0",
      "mutated_line": "lps[1] = 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[1] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pattern[i] == pattern[len]:",
      "mutated_line": "if pattern[i] != pattern[len]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] != pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "len += 1",
      "mutated_line": "len -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len -= 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i -= 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 2):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 0):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 0):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - -1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i + 1] + distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] + distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i + 1] * distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] * distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lps = [0] * M",
      "mutated_line": "lps = [1] * M",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [1] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lps = [0] * M",
      "mutated_line": "lps = [-1] * M",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [-1] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "lps = [0] * M",
      "mutated_line": "lps = [1] * M",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [1] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 2\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 0\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 0\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += -1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 2\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 0\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 0\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += -1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 2\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 0\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 0\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += -1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "elif i < N and pattern[j] != string[i]:",
      "mutated_line": "elif i < N or pattern[j] != string[i]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N or pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "len += 1",
      "mutated_line": "len += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 2\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "len += 1",
      "mutated_line": "len += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 0\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "len += 1",
      "mutated_line": "len += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 0\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "len += 1",
      "mutated_line": "len += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += -1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 2\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 0\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 0\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += -1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif len != 0:",
      "mutated_line": "elif len == 0:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len == 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i -= 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j + 1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j + 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j * 1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j * 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < N and pattern[j] != string[i]:",
      "mutated_line": "elif i <= N and pattern[j] != string[i]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i <= N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < N and pattern[j] != string[i]:",
      "mutated_line": "elif i >= N and pattern[j] != string[i]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i >= N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < N and pattern[j] != string[i]:",
      "mutated_line": "elif i != N and pattern[j] != string[i]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i != N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif i < N and pattern[j] != string[i]:",
      "mutated_line": "elif i < N and pattern[j] == string[i]:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] == string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if j != 0:",
      "mutated_line": "if j == 0:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j == 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i -= 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len != 0:",
      "mutated_line": "elif len != 1:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 1:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len != 0:",
      "mutated_line": "elif len != -1:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != -1:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif len != 0:",
      "mutated_line": "elif len != 1:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 1:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lps[i] = 0",
      "mutated_line": "lps[i] = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 1\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lps[i] = 0",
      "mutated_line": "lps[i] = -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = -1\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "lps[i] = 0",
      "mutated_line": "lps[i] = 1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 1\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 2\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 0\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 0\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += -1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i - 1] - distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i - 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i * 1] - distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i * 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - 2]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 2]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - 0]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 0]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - 0]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 0]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - -1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - -1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if j != 0:",
      "mutated_line": "if j != 1:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 1:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if j != 0:",
      "mutated_line": "if j != -1:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != -1:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if j != 0:",
      "mutated_line": "if j != 1:",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 1:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 2\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 0\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 0\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += -1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "len = lps[len - 1]",
      "mutated_line": "len = lps[len + 1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len + 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "len = lps[len - 1]",
      "mutated_line": "len = lps[len * 1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len * 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i + 2] - distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 2] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i + 0] - distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 0] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i + 0] - distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 0] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "string.append(distances[i + 1] - distances[i])",
      "mutated_line": "string.append(distances[i + -1] - distances[i])",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + -1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j + 1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j + 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j * 1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j * 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "len = lps[len - 1]",
      "mutated_line": "len = lps[len - 2]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 2]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "len = lps[len - 1]",
      "mutated_line": "len = lps[len - 0]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 0]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "len = lps[len - 1]",
      "mutated_line": "len = lps[len - 0]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 0]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "len = lps[len - 1]",
      "mutated_line": "len = lps[len - -1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - -1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - 2]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 2]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - 0]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 0]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - 0]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - 0]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = lps[j - 1]",
      "mutated_line": "j = lps[j - -1]",
      "code": "def count_matching_runs(n, k, distances, recorded_distances):\n\n    def KMPMatch(pattern, string):\n        M = len(pattern)\n        N = len(string)\n        ans = 0\n        lps = [0] * M\n        j = 0\n        LPSCompute(pattern, M, lps)\n        i = 0\n        while i < N:\n            if pattern[j] == string[i]:\n                i += 1\n                j += 1\n            if j == M:\n                ans += 1\n                j = lps[j - 1]\n            elif i < N and pattern[j] != string[i]:\n                if j != 0:\n                    j = lps[j - -1]\n                else:\n                    i += 1\n        return ans\n\n    def LPSCompute(pattern, M, lps):\n        len = 0\n        lps[0] = 0\n        i = 1\n        while i < M:\n            if pattern[i] == pattern[len]:\n                len += 1\n                lps[i] = len\n                i += 1\n            elif len != 0:\n                len = lps[len - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    string = []\n    for i in range(n - 1):\n        string.append(distances[i + 1] - distances[i])\n    return KMPMatch(recorded_distances, string)"
    }
  ]
}