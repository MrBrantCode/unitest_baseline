{
  "task_id": "taco_16918",
  "entry_point": "count_matching_mex_pairs",
  "mutant_count": 190,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] / (n + 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] / (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] + (n + 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] + (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] ** (n + 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] ** (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] / (n + 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] / (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] + (n + 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] + (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] ** (n + 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] ** (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x > y:",
      "mutated_line": "if x >= y:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x >= y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x > y:",
      "mutated_line": "if x <= y:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x <= y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x > y:",
      "mutated_line": "if x != y:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x != y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 1\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = -1\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 1\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x > 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x > 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x < 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x < 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x == 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x == 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res -= x * (x + 1) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res -= x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y > 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y > 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y < 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y < 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y == 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y == 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res -= (n - y - 1) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res -= (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 > 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 > 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 < 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 < 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 == 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 == 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res -= (y - x - 1) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res -= (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return res + 1",
      "mutated_line": "return res - 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res - 1"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "return res + 1",
      "mutated_line": "return res * 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res * 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] * (n - 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n - 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] * (n * 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n * 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] * (n - 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n - 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] * (n * 1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n * 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = pi[1]",
      "mutated_line": "x = pi[2]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[2]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = pi[1]",
      "mutated_line": "x = pi[0]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[0]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = pi[1]",
      "mutated_line": "x = pi[0]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[0]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x = pi[1]",
      "mutated_line": "x = pi[-1]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[-1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y = qi[1]",
      "mutated_line": "y = qi[2]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[2]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y = qi[1]",
      "mutated_line": "y = qi[0]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[0]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y = qi[1]",
      "mutated_line": "y = qi[0]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[0]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y = qi[1]",
      "mutated_line": "y = qi[-1]",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[-1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= 2:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 2:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= 0:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 0:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= 0:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 0:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= -1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= -1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) / 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) / 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) * 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) * 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 + y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 + y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if (n - 1) * y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if (n - 1) * y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y >= 2:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 2:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y >= 0:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 0:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y >= 0:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 0:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 1 - y >= -1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= -1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) / 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) / 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) * 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) * 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x + 1 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x + 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if (y - x) * 1 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if (y - x) * 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 >= 2:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 2:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 >= 0:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 0:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 >= 0:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 0:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 1 >= -1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= -1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) / 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) / 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) * 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) * 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(3, n):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(3, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(1, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(0, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(1, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(2, n):",
      "mutated_line": "for i in range(-2, n):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(-2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if x > y:",
      "mutated_line": "if x >= y:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x >= y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if x > y:",
      "mutated_line": "if x <= y:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x <= y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if x > y:",
      "mutated_line": "if x != y:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x != y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "res += u * v",
      "mutated_line": "res -= u * v",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res -= u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return res + 1",
      "mutated_line": "return res + 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 2"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return res + 1",
      "mutated_line": "return res + 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return res + 1",
      "mutated_line": "return res + 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return res + 1",
      "mutated_line": "return res + -1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] * (n + 2)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 2)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] * (n + 0)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 0)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] * (n + 0)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 0)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "pi = [None] * (n + 1)",
      "mutated_line": "pi = [None] * (n + -1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + -1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] * (n + 2)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 2)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] * (n + 0)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 0)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] * (n + 0)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 0)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "qi = [None] * (n + 1)",
      "mutated_line": "qi = [None] * (n + -1)",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + -1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x / (x + 1) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x / (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += (x + (x + 1)) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += (x + (x + 1)) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x ** (x + 1) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x ** (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) // 3",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 3\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) // 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 1\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) // 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 0\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) // 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 1\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 1) // -2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // -2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n + 1 - y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n + 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n * 1 - y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n * 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) / (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) / (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1 + (n - y)) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1 + (n - y)) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) ** (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) ** (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) // 3",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 3\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) // 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 1\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) // 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 0\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) // 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 1\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n - y) // -2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // -2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y + x - 1 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y + x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y * x - 1 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y * x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 2 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 2 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 0 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 0 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - 0 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 0 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if y - x - 1 >= 1:",
      "mutated_line": "if y - x - -1 >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - -1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) / (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) / (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1 + (y - x)) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1 + (y - x)) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) ** (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) ** (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) // 3",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 3\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) // 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 1\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) // 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 0\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) // 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 1\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y - x) // -2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // -2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not ((x >= l and x <= r) and (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not ((x >= l and x <= r) and (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y < l:",
      "mutated_line": "if y <= l:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y <= l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y < l:",
      "mutated_line": "if y >= l:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y >= l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if y < l:",
      "mutated_line": "if y != l:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y != l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if x > r:",
      "mutated_line": "if x >= r:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x >= r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if x > r:",
      "mutated_line": "if x <= r:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x <= r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if x > r:",
      "mutated_line": "if x != r:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x != r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "res += u * v",
      "mutated_line": "res += u / v",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u / v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "res += u * v",
      "mutated_line": "res += u + v",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u + v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "res += u * v",
      "mutated_line": "res += u ** v",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u ** v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x - 1) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x - 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x * 1) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x * 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 2 - y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 2 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 0 - y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 0 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - 0 - y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 0 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if n - 1 - y >= 1:",
      "mutated_line": "if n - -1 - y >= 1:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - -1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y + 1) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y + 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y) * 1 * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y) * 1 * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n + y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n + y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 1) * (n * y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n * y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x + 1) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x + 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x) * 1 * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x) * 1 * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y + x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y + x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 1) * (y * x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y * x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not ((x >= l or x <= r) or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not ((x >= l or x <= r) or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y >= l or y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l or y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "u = l - y",
      "mutated_line": "u = l + y",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l + y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "u = l - y",
      "mutated_line": "u = l * y",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l * y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif x < l:",
      "mutated_line": "elif x <= l:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x <= l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif x < l:",
      "mutated_line": "elif x >= l:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x >= l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif x < l:",
      "mutated_line": "elif x != l:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x != l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "v = x - r",
      "mutated_line": "v = x + r",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x + r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "v = x - r",
      "mutated_line": "v = x * r",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x * r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "elif y > r:",
      "mutated_line": "elif y >= r:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y >= r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "elif y > r:",
      "mutated_line": "elif y <= r:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y <= r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "elif y > r:",
      "mutated_line": "elif y != r:",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y != r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 2) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 2) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 0) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 0) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + 0) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 0) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res += x * (x + 1) // 2",
      "mutated_line": "res += x * (x + -1) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + -1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n + y - 1) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n + y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n * y - 1) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n * y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 2) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 2) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 0) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 0) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - 0) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 0) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res += (n - y - 1) * (n - y) // 2",
      "mutated_line": "res += (n - y - -1) * (n - y) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - -1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y + x - 1) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y + x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y * x - 1) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y * x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 2) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 2) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 0) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 0) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - 0) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 0) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "res += (y - x - 1) * (y - x) // 2",
      "mutated_line": "res += (y - x - -1) * (y - x) // 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - -1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x > l and x <= r or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x > l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x < l and x <= r or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x < l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x == l and x <= r or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x == l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x < r or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x < r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x > r or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x > r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x == r or (y >= l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x == r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y > l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y > l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y < l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y < l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y == l and y <= r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y == l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y >= l and y < r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y < r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y >= l and y > r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y > r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if not (x >= l and x <= r or (y >= l and y <= r)):",
      "mutated_line": "if not (x >= l and x <= r or (y >= l and y == r)):",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y == r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "u = l - x",
      "mutated_line": "u = l + x",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l + x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "u = l - x",
      "mutated_line": "u = l * x",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l * x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "u = l + 1",
      "mutated_line": "u = l - 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l - 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "u = l + 1",
      "mutated_line": "u = l * 1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l * 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "v = y - r",
      "mutated_line": "v = y + r",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y + r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "v = y - r",
      "mutated_line": "v = y * r",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y * r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "v = n - r",
      "mutated_line": "v = n + r",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n + r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "v = n - r",
      "mutated_line": "v = n * r",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n * r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "u = l + 1",
      "mutated_line": "u = l + 2",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 2\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "u = l + 1",
      "mutated_line": "u = l + 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 0\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "u = l + 1",
      "mutated_line": "u = l + 0",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + 0\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "u = l + 1",
      "mutated_line": "u = l + -1",
      "code": "def count_matching_mex_pairs(n, p, q):\n    \"\"\"\n    Counts the number of pairs of integers (l, r) such that the MEX of the subarrays \n    [p_l, p_{l+1}, ..., p_r] and [q_l, q_{l+1}, ..., q_r] are equal.\n\n    Parameters:\n    n (int): The length of the permutations.\n    p (list of int): The first permutation.\n    q (list of int): The second permutation.\n\n    Returns:\n    int: The number of suitable pairs (l, r).\n    \"\"\"\n    pi = [None] * (n + 1)\n    qi = [None] * (n + 1)\n    for i in range(n):\n        pi[p[i]] = i\n        qi[q[i]] = i\n    x = pi[1]\n    y = qi[1]\n    if x > y:\n        (x, y) = (y, x)\n    res = 0\n    if x >= 1:\n        res += x * (x + 1) // 2\n    if n - 1 - y >= 1:\n        res += (n - y - 1) * (n - y) // 2\n    if y - x - 1 >= 1:\n        res += (y - x - 1) * (y - x) // 2\n    l = x\n    r = y\n    for i in range(2, n):\n        x = pi[i]\n        y = qi[i]\n        if x > y:\n            (x, y) = (y, x)\n        if not (x >= l and x <= r or (y >= l and y <= r)):\n            if y < l:\n                u = l - y\n            elif x < l:\n                u = l - x\n            else:\n                u = l + -1\n            if x > r:\n                v = x - r\n            elif y > r:\n                v = y - r\n            else:\n                v = n - r\n            res += u * v\n        l = min(l, x)\n        r = max(r, y)\n    return res + 1"
    }
  ]
}