{
  "task_id": "taco_14040",
  "entry_point": "minimize_product",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sign = [False] * n",
      "mutated_line": "sign = [False] / n",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] / n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sign = [False] * n",
      "mutated_line": "sign = [False] + n",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] + n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "sign = [False] * n",
      "mutated_line": "sign = [False] ** n",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] ** n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 + sum(sign) % 2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 + sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 * (sum(sign) % 2):",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 * (sum(sign) % 2):\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "a -= j * x",
      "mutated_line": "a += j * x",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a += j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "k -= j",
      "mutated_line": "k += j",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k += j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "a += x",
      "mutated_line": "a -= x",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a -= x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a < 0:",
      "mutated_line": "if a <= 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a <= 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a < 0:",
      "mutated_line": "if a >= 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a >= 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if a < 0:",
      "mutated_line": "if a != 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a != 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 2 - sum(sign) % 2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 2 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 0 - sum(sign) % 2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 0 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 0 - sum(sign) % 2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 0 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if -1 - sum(sign) % 2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if -1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - sum(sign) * 2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) * 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - (sum(sign) + 2):",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - (sum(sign) + 2):\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "a -= j * x",
      "mutated_line": "a -= j / x",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j / x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "a -= j * x",
      "mutated_line": "a -= j + x",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j + x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "a -= j * x",
      "mutated_line": "a -= j ** x",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j ** x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a > 0:",
      "mutated_line": "if a >= 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a >= 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a > 0:",
      "mutated_line": "if a <= 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a <= 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a > 0:",
      "mutated_line": "if a != 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a != 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "a = -a",
      "mutated_line": "a = +a",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = +a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "sign[i] ^= True",
      "mutated_line": "sign[i] ^= False",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= False\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sign = [False] * n",
      "mutated_line": "sign = [True] * n",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [True] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a < 0:",
      "mutated_line": "if a < 1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 1:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a < 0:",
      "mutated_line": "if a < -1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < -1:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if a < 0:",
      "mutated_line": "if a < 1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 1:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sign[i] = True",
      "mutated_line": "sign[i] = False",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = False\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - sum(sign) % 3:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 3:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - sum(sign) % 1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 1:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - sum(sign) % 0:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 0:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - sum(sign) % 1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 1:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if (1 - sum(sign) % 2):",
      "mutated_line": "if 1 - sum(sign) % -2:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % -2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x - (1 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x - (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x * (1 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x * (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if a > 0:",
      "mutated_line": "if a > 1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 1:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if a > 0:",
      "mutated_line": "if a > -1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > -1:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if a > 0:",
      "mutated_line": "if a > 1:",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 1:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a / x + (1 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a / x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a * x + (1 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a * x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "h.append((-a, i))",
      "mutated_line": "h.append((+a, i))",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((+a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (1 if a * x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a * x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (1 if a + x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a + x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (2 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (2 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (0 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (0 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (0 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (0 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (-1 if a % x else 0), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (-1 if a % x else 0), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (1 if a % x else 1), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 1), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (1 if a % x else -1), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else -1), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "j = min(a // x + (1 if a % x else 0), k)",
      "mutated_line": "j = min(a // x + (1 if a % x else 1), k)",
      "code": "def minimize_product(n, k, x, array):\n    from heapq import heapify, heappop, heappushpop, heappush\n    sign = [False] * n\n    h = []\n    for (i, a) in enumerate(array):\n        if a < 0:\n            sign[i] = True\n            h.append((-a, i))\n        else:\n            h.append((a, i))\n    heapify(h)\n    (a, i) = heappop(h)\n    if 1 - sum(sign) % 2:\n        j = min(a // x + (1 if a % x else 1), k)\n        a -= j * x\n        if a > 0:\n            array[i] = a\n            return array\n        k -= j\n        a = -a\n        sign[i] ^= True\n    for _ in range(k):\n        (a, i) = heappushpop(h, (a, i))\n        a += x\n    array[i] = a\n    for (a, i) in h:\n        array[i] = a\n    return array"
    }
  ]
}