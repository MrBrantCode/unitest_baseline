{
  "task_id": "taco_5162",
  "entry_point": "calculate_minimum_magic_power",
  "mutant_count": 133,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 1\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = -1\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 1\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vx = dx - sx",
      "mutated_line": "vx = dx + sx",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx + sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vx = dx - sx",
      "mutated_line": "vx = dx * sx",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx * sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "vy = dy - sy",
      "mutated_line": "vy = dy + sy",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy + sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "vy = dy - sy",
      "mutated_line": "vy = dy * sy",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy * sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "vz = dz - sz",
      "mutated_line": "vz = dz + sz",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz + sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "vz = dz - sz",
      "mutated_line": "vz = dz * sz",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz * sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "t += vx * (xi - sx)",
      "mutated_line": "t -= vx * (xi - sx)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t -= vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "t += vy * (yi - sy)",
      "mutated_line": "t -= vy * (yi - sy)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t -= vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "t += vz * (zi - sz)",
      "mutated_line": "t -= vz * (zi - sz)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t -= vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t *= vx ** 2 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t *= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 -= (sx + vx * t - xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 -= (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 -= (sy + vy * t - yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 -= (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 -= (sz + vz * t - zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 -= (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 1\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = -1\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 1\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t += vx * (xi - sx)",
      "mutated_line": "t += vx / (xi - sx)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx / (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t += vx * (xi - sx)",
      "mutated_line": "t += vx + (xi - sx)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx + (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t += vx * (xi - sx)",
      "mutated_line": "t += vx ** (xi - sx)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx ** (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t += vy * (yi - sy)",
      "mutated_line": "t += vy / (yi - sy)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy / (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t += vy * (yi - sy)",
      "mutated_line": "t += vy + (yi - sy)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy + (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t += vy * (yi - sy)",
      "mutated_line": "t += vy ** (yi - sy)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy ** (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t += vz * (zi - sz)",
      "mutated_line": "t += vz / (zi - sz)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz / (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t += vz * (zi - sz)",
      "mutated_line": "t += vz + (zi - sz)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz + (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t += vz * (zi - sz)",
      "mutated_line": "t += vz ** (zi - sz)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz ** (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 - vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 - vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= (vx ** 2 + vy ** 2) * vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= (vx ** 2 + vy ** 2) * vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = 0",
      "mutated_line": "len2 = 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 1\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = 0",
      "mutated_line": "len2 = -1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = -1\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "len2 = 0",
      "mutated_line": "len2 = 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 1\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t - xi) * 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) * 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += sx + vx * t - xi + 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += sx + vx * t - xi + 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t - yi) * 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) * 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += sy + vy * t - yi + 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += sy + vy * t - yi + 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t - zi) * 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) * 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += sz + vz * t - zi + 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += sz + vz * t - zi + 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 or len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 or len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "ans += li",
      "mutated_line": "ans -= li",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans -= li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t += vx * (xi - sx)",
      "mutated_line": "t += vx * (xi + sx)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi + sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "t += vx * (xi - sx)",
      "mutated_line": "t += vx * (xi * sx)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi * sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t += vy * (yi - sy)",
      "mutated_line": "t += vy * (yi + sy)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi + sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t += vy * (yi - sy)",
      "mutated_line": "t += vy * (yi * sy)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi * sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t += vz * (zi - sz)",
      "mutated_line": "t += vz * (zi + sz)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi + sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t += vz * (zi - sz)",
      "mutated_line": "t += vz * (zi * sz)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi * sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 - vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 - vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 * vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 * vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + vz * 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz * 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + (vz + 2)",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + (vz + 2)\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t + xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t + xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += ((sx + vx * t) * xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += ((sx + vx * t) * xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t - xi) ** 3",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 3\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t - xi) ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 1\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t - xi) ** 0",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 0\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t - xi) ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 1\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx * t - xi) ** -2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** -2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t + yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t + yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += ((sy + vy * t) * yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += ((sy + vy * t) * yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t - yi) ** 3",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 3\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t - yi) ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 1\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t - yi) ** 0",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 0\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t - yi) ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 1\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy * t - yi) ** -2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** -2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t + zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t + zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += ((sz + vz * t) * zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += ((sz + vz * t) * zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t - zi) ** 3",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 3\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t - zi) ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 1\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t - zi) ** 0",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 0\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t - zi) ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 1\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz * t - zi) ** -2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** -2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 <= t < 1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 <= t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 >= t < 1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 >= t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 != t < 1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 != t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 < ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 < ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 > ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 > ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 == ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 == ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx * 2 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx * 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx + 2 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx + 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy * 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy * 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + (vy + 2) + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + (vy + 2) + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + vz ** 3",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 3\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + vz ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 1\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + vz ** 0",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 0\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + vz ** 1",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 1\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 2 + vz ** -2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** -2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx - vx * t - xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx - vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx * (vx * t) - xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx * (vx * t) - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy - vy * t - yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy - vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy * (vy * t) - yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy * (vy * t) - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz - vz * t - zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz - vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz * (vz * t) - zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz * (vz * t) - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 1 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 1 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if -1 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if -1 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 1 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 1 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 2 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 2 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 0 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 0 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 0 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 0 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < -1 and len2 <= ri ** 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < -1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 - 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 - 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 * 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 * 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 3 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 3 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 1 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 1 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 0 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 0 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 1 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 1 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** -2 + vy ** 2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** -2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 3 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 3 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 1 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 1 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 0 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 0 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** 1 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 1 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t /= vx ** 2 + vy ** 2 + vz ** 2",
      "mutated_line": "t /= vx ** 2 + vy ** -2 + vz ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** -2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx / t - xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx / t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + (vx + t) - xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + (vx + t) - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "len2 += (sx + vx * t - xi) ** 2",
      "mutated_line": "len2 += (sx + vx ** t - xi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx ** t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy / t - yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy / t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + (vy + t) - yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + (vy + t) - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "len2 += (sy + vy * t - yi) ** 2",
      "mutated_line": "len2 += (sy + vy ** t - yi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy ** t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz / t - zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz / t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + (vz + t) - zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + (vz + t) - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "len2 += (sz + vz * t - zi) ** 2",
      "mutated_line": "len2 += (sz + vz ** t - zi) ** 2",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz ** t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri * 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri * 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri + 2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri + 2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1.000000001:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1.000000001:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 + -0.999999999:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + -0.999999999:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 + 0:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 0:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + 1:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 2 + -1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 2 + -1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 3 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 3 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 1 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 1 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 0 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 0 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** 1 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** 1 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if 0 < t < 1 and len2 <= ri ** 2 + 1e-09:",
      "mutated_line": "if 0 < t < 1 and len2 <= ri ** -2 + 1e-09:",
      "code": "def calculate_minimum_magic_power(N, Q, obstacles, object_pairs):\n    results = []\n    for (sx, sy, sz, dx, dy, dz) in object_pairs:\n        ans = 0\n        vx = dx - sx\n        vy = dy - sy\n        vz = dz - sz\n        for (xi, yi, zi, ri, li) in obstacles:\n            t = 0\n            t += vx * (xi - sx)\n            t += vy * (yi - sy)\n            t += vz * (zi - sz)\n            t /= vx ** 2 + vy ** 2 + vz ** 2\n            len2 = 0\n            len2 += (sx + vx * t - xi) ** 2\n            len2 += (sy + vy * t - yi) ** 2\n            len2 += (sz + vz * t - zi) ** 2\n            if 0 < t < 1 and len2 <= ri ** -2 + 1e-09:\n                ans += li\n        results.append(ans)\n    return results"
    }
  ]
}