{
  "task_id": "taco_5423",
  "entry_point": "max_card_sum",
  "mutant_count": 48,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [0] / (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] / (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [0] + (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] + (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [0] ** (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] ** (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "no_cycle = [True] * (H + W)",
      "mutated_line": "no_cycle = [True] / (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] / (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "no_cycle = [True] * (H + W)",
      "mutated_line": "no_cycle = [True] + (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] + (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "no_cycle = [True] * (H + W)",
      "mutated_line": "no_cycle = [True] ** (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] ** (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "answer = 0",
      "mutated_line": "answer = 1",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 1\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "answer = 0",
      "mutated_line": "answer = -1",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = -1\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "answer = 0",
      "mutated_line": "answer = 1",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 1\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "answer += A",
      "mutated_line": "answer -= A",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer -= A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [0] * (H - W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H - W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [0] * (H * W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H * W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "no_cycle = [True] * (H + W)",
      "mutated_line": "no_cycle = [True] * (H - W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H - W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "no_cycle = [True] * (H + W)",
      "mutated_line": "no_cycle = [True] * (H * W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H * W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x != y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if sx < sy:",
      "mutated_line": "if sx <= sy:",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx <= sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if sx < sy:",
      "mutated_line": "if sx >= sy:",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx >= sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if sx < sy:",
      "mutated_line": "if sx != sy:",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx != sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "no_cycle[x] = no_cycle[x] and no_cycle[y]",
      "mutated_line": "no_cycle[x] = no_cycle[x] or no_cycle[y]",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] or no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if rx == ry:",
      "mutated_line": "if rx != ry:",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx != ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "root = list(range(H + W))",
      "mutated_line": "root = list(range(H - W))",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H - W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "root = list(range(H + W))",
      "mutated_line": "root = list(range(H * W))",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H * W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [1] * (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [1] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [-1] * (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [-1] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "size = [0] * (H + W)",
      "mutated_line": "size = [1] * (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [1] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "no_cycle = [True] * (H + W)",
      "mutated_line": "no_cycle = [False] * (H + W)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [False] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R + 1, H + C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R + 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R * 1, H + C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R * 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H + C + 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C + 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, (H + C) * 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, (H + C) * 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "no_cycle[rx] = False",
      "mutated_line": "no_cycle[rx] = True",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = True\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if not no_cycle[rx] and (not no_cycle[ry]):",
      "mutated_line": "if not no_cycle[rx] or not no_cycle[ry]:",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] or not no_cycle[ry]:\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "UOI",
      "lineno": 2,
      "original_line": "RCA.sort(key=lambda x: -x[2])",
      "mutated_line": "RCA.sort(key=lambda x: +x[2])",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: +x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 2, H + C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 2, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 0, H + C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 0, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 0, H + C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 0, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - -1, H + C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - -1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H - C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H - C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H * C - 1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H * C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H + C - 2)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 2)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H + C - 0)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 0)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H + C - 0)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 0)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(x, y) = (R - 1, H + C - 1)",
      "mutated_line": "(x, y) = (R - 1, H + C - -1)",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - -1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "RCA.sort(key=lambda x: -x[2])",
      "mutated_line": "RCA.sort(key=lambda x: -x[3])",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[3])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "RCA.sort(key=lambda x: -x[2])",
      "mutated_line": "RCA.sort(key=lambda x: -x[1])",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[1])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "RCA.sort(key=lambda x: -x[2])",
      "mutated_line": "RCA.sort(key=lambda x: -x[0])",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[0])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "RCA.sort(key=lambda x: -x[2])",
      "mutated_line": "RCA.sort(key=lambda x: -x[1])",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[1])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "RCA.sort(key=lambda x: -x[2])",
      "mutated_line": "RCA.sort(key=lambda x: -x[-2])",
      "code": "def max_card_sum(N, H, W, RCA):\n    RCA.sort(key=lambda x: -x[-2])\n    root = list(range(H + W))\n    size = [0] * (H + W)\n    no_cycle = [True] * (H + W)\n\n    def find_root(x):\n        y = root[x]\n        if x == y:\n            return y\n        z = find_root(y)\n        root[x] = z\n        return z\n\n    def merge(x, y):\n        (x, y) = (find_root(x), find_root(y))\n        (sx, sy) = (size[x], size[y])\n        if sx < sy:\n            (sx, sy) = (sy, sx)\n            (x, y) = (y, x)\n        root[y] = x\n        no_cycle[x] = no_cycle[x] and no_cycle[y]\n    answer = 0\n    for (R, C, A) in RCA:\n        (x, y) = (R - 1, H + C - 1)\n        (rx, ry) = (find_root(x), find_root(y))\n        if rx == ry:\n            if not no_cycle[rx]:\n                continue\n            no_cycle[rx] = False\n        else:\n            if not no_cycle[rx] and (not no_cycle[ry]):\n                continue\n            merge(rx, ry)\n        answer += A\n    return answer"
    }
  ]
}