{
  "task_id": "taco_7986",
  "entry_point": "minimum_bullets_needed",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 * 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 * 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 + 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 + 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BUL = 1000",
      "mutated_line": "BUL = 1001",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1001\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BUL = 1000",
      "mutated_line": "BUL = 999",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 999\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BUL = 1000",
      "mutated_line": "BUL = 0",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 0\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BUL = 1000",
      "mutated_line": "BUL = 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BUL = 1000",
      "mutated_line": "BUL = -1000",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = -1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 3 ** 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 3 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 1 ** 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 1 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 0 ** 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 0 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 1 ** 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 1 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = -2 ** 29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = -2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 ** 30",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 30\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 ** 28",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 28\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 ** 0",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 0\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 ** 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 1\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2 ** 29",
      "mutated_line": "INF = 2 ** -29",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** -29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i != 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][1] + 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] + 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][1] * 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] * 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 1:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == -1:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 1:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][2] = dp[i][1] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][2] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][0] = dp[i][1] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][0] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][0] = dp[i][1] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][0] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][-1] = dp[i][1] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][-1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][1] - 2",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 2\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][1] - 0",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 0\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][1] - 0",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 0\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][1] - -1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - -1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(3, BUL + 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(3, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(1, BUL + 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(1, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(0, BUL + 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(0, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(1, BUL + 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(1, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(-2, BUL + 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(-2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(2, BUL - 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL - 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(2, BUL * 1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL * 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 1][2])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 1][0])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 1][0])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 1][-1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][2] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][2] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][0] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][0] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][0] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][0] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp1[i][1] = dp[i][1] - 1",
      "mutated_line": "dp1[i][1] = dp[i][-1] - 1",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][-1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(2, BUL + 2):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 2):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(2, BUL + 0):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 0):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(2, BUL + 0):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 0):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(2, BUL + 1):",
      "mutated_line": "for j in range(2, BUL + -1):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + -1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] + j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] + j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] * j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] * j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in reversed(range(1, BUL)):",
      "mutated_line": "for j in reversed(range(2, BUL)):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(2, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in reversed(range(1, BUL)):",
      "mutated_line": "for j in reversed(range(0, BUL)):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(0, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in reversed(range(1, BUL)):",
      "mutated_line": "for j in reversed(range(0, BUL)):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(0, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in reversed(range(1, BUL)):",
      "mutated_line": "for j in reversed(range(-1, BUL)):",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(-1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N + 1][1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N + 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N * 1][1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N * 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp = [[INF for _ in range(BUL - 1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL - 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp = [[INF for _ in range(BUL * 1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL * 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp1 = [[INF for _ in range(BUL - 1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL - 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp1 = [[INF for _ in range(BUL * 1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL * 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp2 = [[INF for _ in range(BUL - 1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL - 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp2 = [[INF for _ in range(BUL * 1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL * 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] - powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] - powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] * powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] * powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j + 1], dp[i][j] - j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j + 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j * 1], dp[i][j] - j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j * 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2[i][j] = min(dp2[i][j + 1], dp[i][j])",
      "mutated_line": "dp2[i][j] = min(dp2[i][j - 1], dp[i][j])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j - 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp2[i][j] = min(dp2[i][j + 1], dp[i][j])",
      "mutated_line": "dp2[i][j] = min(dp2[i][j * 1], dp[i][j])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j * 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 2][1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 2][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 0][1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 0][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - 0][1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 0][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "results.append(dp2[N - 1][1])",
      "mutated_line": "results.append(dp2[N - -1][1])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - -1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp = [[INF for _ in range(BUL + 2)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 2)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp = [[INF for _ in range(BUL + 0)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 0)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp = [[INF for _ in range(BUL + 0)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 0)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp = [[INF for _ in range(BUL + -1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + -1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp1 = [[INF for _ in range(BUL + 2)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 2)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp1 = [[INF for _ in range(BUL + 0)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 0)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp1 = [[INF for _ in range(BUL + 0)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 0)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp1 = [[INF for _ in range(BUL + -1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + -1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp2 = [[INF for _ in range(BUL + 2)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 2)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp2 = [[INF for _ in range(BUL + 0)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 0)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp2 = [[INF for _ in range(BUL + 0)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 0)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]",
      "mutated_line": "dp2 = [[INF for _ in range(BUL + -1)] for _ in range(N)]",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + -1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j - 2], dp[i][j] - j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 2], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j - 0], dp[i][j] - j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 0], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j - 0], dp[i][j] - j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 0], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)",
      "mutated_line": "dp1[i][j] = min(dp1[i][j - -1], dp[i][j] - j)",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - -1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2[i][j] = min(dp2[i][j + 1], dp[i][j])",
      "mutated_line": "dp2[i][j] = min(dp2[i][j + 2], dp[i][j])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 2], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2[i][j] = min(dp2[i][j + 1], dp[i][j])",
      "mutated_line": "dp2[i][j] = min(dp2[i][j + 0], dp[i][j])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 0], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2[i][j] = min(dp2[i][j + 1], dp[i][j])",
      "mutated_line": "dp2[i][j] = min(dp2[i][j + 0], dp[i][j])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 0], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp2[i][j] = min(dp2[i][j + 1], dp[i][j])",
      "mutated_line": "dp2[i][j] = min(dp2[i][j + -1], dp[i][j])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + -1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i + 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i + 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i * 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i * 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i + 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i + 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i * 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i * 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 2][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 2][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 0][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 0][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 0][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 0][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - -1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - -1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 2][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 2][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 0][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 0][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 0][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 0][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - 1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "mutated_line": "dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - -1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])",
      "code": "def minimum_bullets_needed(T, test_cases):\n    results = []\n    INF = 2 ** 29\n    BUL = 1000\n    for case in test_cases:\n        (N, M, powers, bullets) = case\n        dp = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp1 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        dp2 = [[INF for _ in range(BUL + 1)] for _ in range(N)]\n        for i in range(N):\n            if i == 0:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], powers[i][j])\n            else:\n                for j in range(M):\n                    dp[i][bullets[i][j]] = min(dp[i][bullets[i][j]], dp1[i - -1][powers[i][j]] + powers[i][j], dp2[i - 1][powers[i][j]])\n            dp1[i][1] = dp[i][1] - 1\n            for j in range(2, BUL + 1):\n                dp1[i][j] = min(dp1[i][j - 1], dp[i][j] - j)\n            dp2[i][BUL] = dp[i][BUL]\n            for j in reversed(range(1, BUL)):\n                dp2[i][j] = min(dp2[i][j + 1], dp[i][j])\n        results.append(dp2[N - 1][1])\n    return results"
    }
  ]
}