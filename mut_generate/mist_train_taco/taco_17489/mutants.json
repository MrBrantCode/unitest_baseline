{
  "task_id": "taco_17489",
  "entry_point": "count_almost_sorted_intervals",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_height = 0",
      "mutated_line": "cur_height = 1",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 1\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_height = 0",
      "mutated_line": "cur_height = -1",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = -1\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_height = 0",
      "mutated_line": "cur_height = 1",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 1\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_sequences = 0",
      "mutated_line": "total_sequences = 1",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 1\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_sequences = 0",
      "mutated_line": "total_sequences = -1",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = -1\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total_sequences = 0",
      "mutated_line": "total_sequences = 1",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 1\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "total_sequences += len(cur_interval)",
      "mutated_line": "total_sequences -= len(cur_interval)",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences -= len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if ai < cur_height:",
      "mutated_line": "if ai <= cur_height:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai <= cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if ai < cur_height:",
      "mutated_line": "if ai >= cur_height:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai >= cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if ai < cur_height:",
      "mutated_line": "if ai != cur_height:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai != cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "total_sequences += pi_lower",
      "mutated_line": "total_sequences -= pi_lower",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences -= pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "merged = True",
      "mutated_line": "merged = False",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = False\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "prev_min = cur_interval[0]",
      "mutated_line": "prev_min = cur_interval[1]",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[1]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "prev_min = cur_interval[0]",
      "mutated_line": "prev_min = cur_interval[-1]",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[-1]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "prev_min = cur_interval[0]",
      "mutated_line": "prev_min = cur_interval[1]",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[1]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) + 1, -1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) + 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) * 1, -1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) * 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, +1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, +1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -1, +1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, +1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[-1] >= ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] >= ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[-1] <= ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] <= ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[-1] != ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] != ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pi_lower > 0:",
      "mutated_line": "if pi_lower >= 0:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower >= 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pi_lower > 0:",
      "mutated_line": "if pi_lower <= 0:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower <= 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if pi_lower > 0:",
      "mutated_line": "if pi_lower != 0:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower != 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals and intervals[-1][-1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals and intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 2, -1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 2, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 0, -1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 0, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 0, -1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 0, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - -1, -1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - -1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -2, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -2, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -0, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -0, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -0, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -0, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, --1, -1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, --1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -1, -2):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -2):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -1, -0):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -0):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -1, -0):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -0):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for prev_interval_i in range(len(intervals) - 1, -1, -1):",
      "mutated_line": "for prev_interval_i in range(len(intervals) - 1, -1, --1):",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, --1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if pi_lower > 0:",
      "mutated_line": "if pi_lower > 1:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 1:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if pi_lower > 0:",
      "mutated_line": "if pi_lower > -1:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > -1:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if pi_lower > 0:",
      "mutated_line": "if pi_lower > 1:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 1:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] >= cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] >= cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] <= cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] <= cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] != cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] != cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[+1] > ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[+1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "prev_min = pi[0]",
      "mutated_line": "prev_min = pi[1]",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[1]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "prev_min = pi[0]",
      "mutated_line": "prev_min = pi[-1]",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[-1]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "prev_min = pi[0]",
      "mutated_line": "prev_min = pi[1]",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[1]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mpi_top = bisect.bisect_right(pi, cur_interval[0])",
      "mutated_line": "mpi_top = bisect.bisect_right(pi, cur_interval[1])",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[1])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mpi_top = bisect.bisect_right(pi, cur_interval[0])",
      "mutated_line": "mpi_top = bisect.bisect_right(pi, cur_interval[-1])",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[-1])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mpi_top = bisect.bisect_right(pi, cur_interval[0])",
      "mutated_line": "mpi_top = bisect.bisect_right(pi, cur_interval[1])",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[1])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[-2] > ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-2] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[-0] > ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-0] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[-0] > ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-0] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if pi[-1] > ai:",
      "mutated_line": "if pi[--1] > ai:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[--1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][+1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][+1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] > cur_interval[+1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[+1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[+1][-1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[+1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-2] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-2] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-0] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-0] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-0] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-0] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][--1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][--1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] > cur_interval[-2]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-2]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] > cur_interval[-0]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-0]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] > cur_interval[-0]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[-0]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-1][-1] > cur_interval[--1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-1][-1] > cur_interval[--1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-2][-1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-2][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-0][-1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-0][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[-0][-1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[-0][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if not intervals or intervals[-1][-1] > cur_interval[-1]:",
      "mutated_line": "if not intervals or intervals[--1][-1] > cur_interval[-1]:",
      "code": "import bisect\n\ndef count_almost_sorted_intervals(N, ais):\n    intervals = []\n    cur_interval = []\n    cur_height = 0\n    total_sequences = 0\n    for (i, ai) in enumerate(ais):\n        if ai < cur_height:\n            merged = True\n            while merged:\n                if not intervals or intervals[--1][-1] > cur_interval[-1]:\n                    intervals.append(cur_interval)\n                    break\n                pi = intervals.pop()\n                mpi_top = bisect.bisect_right(pi, cur_interval[0])\n                pi[mpi_top:] = cur_interval\n                cur_interval = pi\n            cur_interval = []\n        cur_height = ai\n        cur_interval.append(ai)\n        total_sequences += len(cur_interval)\n        prev_min = cur_interval[0]\n        for prev_interval_i in range(len(intervals) - 1, -1, -1):\n            pi = intervals[prev_interval_i]\n            if pi[-1] > ai:\n                break\n            pi_lower = bisect.bisect_right(pi, prev_min)\n            if pi_lower > 0:\n                prev_min = pi[0]\n            total_sequences += pi_lower\n    return total_sequences"
    }
  ]
}