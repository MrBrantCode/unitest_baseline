{
  "task_id": "taco_1823",
  "entry_point": "can_connect_islands",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] / (n - 1)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] / (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] + (n - 1)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] + (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] ** (n - 1)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] ** (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "gap_index = 0",
      "mutated_line": "for (bridge, original_index) in sorted_bridges:",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 1\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "gap_index = 0",
      "mutated_line": "for (bridge, original_index) in sorted_bridges:",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = -1\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "gap_index = 0",
      "mutated_line": "for (bridge, original_index) in sorted_bridges:",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 1\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if None in result:",
      "mutated_line": "return 'No'",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None not in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n + 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n * 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "min_gap = l_next - r_i",
      "mutated_line": "min_gap = l_next + r_i",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next + r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "min_gap = l_next - r_i",
      "mutated_line": "min_gap = l_next * r_i",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next * r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "max_gap = r_next - l_i",
      "mutated_line": "max_gap = r_next + l_i",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next + l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "max_gap = r_next - l_i",
      "mutated_line": "max_gap = r_next * l_i",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next * l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] * (n + 1)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n + 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] * (n * 1)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n * 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) or gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "gap_index += 1",
      "mutated_line": "gap_index -= 1",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index -= 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return \"No\"",
      "mutated_line": "return ''",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return ''\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 2):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 0):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 0):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - -1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "l_next, r_next = islands[i + 1]",
      "mutated_line": "(l_next, r_next) = islands[i - 1]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i - 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "l_next, r_next = islands[i + 1]",
      "mutated_line": "(l_next, r_next) = islands[i * 1]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i * 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] * (n - 2)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 2)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] * (n - 0)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 0)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] * (n - 0)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 0)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result = [None] * (n - 1)",
      "mutated_line": "result = [None] * (n - -1)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - -1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index <= len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index >= len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index != len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] < bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] > bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] == bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "gap_index += 1",
      "mutated_line": "gap_index += 2",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 2\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "gap_index += 1",
      "mutated_line": "gap_index += 0",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 0\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "gap_index += 1",
      "mutated_line": "gap_index += 0",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 0\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "gap_index += 1",
      "mutated_line": "gap_index += -1",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += -1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if min_gap <= bridge <= max_gap:",
      "mutated_line": "if min_gap < bridge <= max_gap:",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap < bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if min_gap <= bridge <= max_gap:",
      "mutated_line": "if min_gap > bridge <= max_gap:",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap > bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if min_gap <= bridge <= max_gap:",
      "mutated_line": "if min_gap == bridge <= max_gap:",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap == bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return \"Yes\", result",
      "mutated_line": "return ('', result)",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('', result)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l_next, r_next = islands[i + 1]",
      "mutated_line": "(l_next, r_next) = islands[i + 2]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 2]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l_next, r_next = islands[i + 1]",
      "mutated_line": "(l_next, r_next) = islands[i + 0]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 0]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l_next, r_next = islands[i + 1]",
      "mutated_line": "(l_next, r_next) = islands[i + 0]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 0]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "l_next, r_next = islands[i + 1]",
      "mutated_line": "(l_next, r_next) = islands[i + -1]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + -1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_gap, min_gap, gap_index_in_original = bridge_heap[0]",
      "mutated_line": "(max_gap, min_gap, gap_index_in_original) = bridge_heap[1]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[1]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_gap, min_gap, gap_index_in_original = bridge_heap[0]",
      "mutated_line": "(max_gap, min_gap, gap_index_in_original) = bridge_heap[-1]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[-1]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "max_gap, min_gap, gap_index_in_original = bridge_heap[0]",
      "mutated_line": "(max_gap, min_gap, gap_index_in_original) = bridge_heap[1]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[1]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "result[gap_index_in_original] = original_index + 1",
      "mutated_line": "result[gap_index_in_original] = original_index - 1",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index - 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "result[gap_index_in_original] = original_index + 1",
      "mutated_line": "result[gap_index_in_original] = original_index * 1",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index * 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][1] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][-1] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:",
      "mutated_line": "(min_gap, max_gap, gap_index_in_original) = gaps[gap_index]",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][1] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "result[gap_index_in_original] = original_index + 1",
      "mutated_line": "result[gap_index_in_original] = original_index + 2",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 2\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "result[gap_index_in_original] = original_index + 1",
      "mutated_line": "result[gap_index_in_original] = original_index + 0",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 0\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "result[gap_index_in_original] = original_index + 1",
      "mutated_line": "result[gap_index_in_original] = original_index + 0",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + 0\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "result[gap_index_in_original] = original_index + 1",
      "mutated_line": "result[gap_index_in_original] = original_index + -1",
      "code": "import heapq\n\ndef can_connect_islands(n, m, islands, bridges):\n    gaps = []\n    for i in range(n - 1):\n        (l_i, r_i) = islands[i]\n        (l_next, r_next) = islands[i + 1]\n        min_gap = l_next - r_i\n        max_gap = r_next - l_i\n        gaps.append((min_gap, max_gap, i))\n    gaps.sort()\n    sorted_bridges = sorted(((bridge, i) for (i, bridge) in enumerate(bridges)))\n    result = [None] * (n - 1)\n    bridge_heap = []\n    gap_index = 0\n    for (bridge, original_index) in sorted_bridges:\n        while gap_index < len(gaps) and gaps[gap_index][0] <= bridge:\n            (min_gap, max_gap, gap_index_in_original) = gaps[gap_index]\n            heapq.heappush(bridge_heap, (max_gap, min_gap, gap_index_in_original))\n            gap_index += 1\n        if bridge_heap:\n            (max_gap, min_gap, gap_index_in_original) = bridge_heap[0]\n            if min_gap <= bridge <= max_gap:\n                result[gap_index_in_original] = original_index + -1\n                heapq.heappop(bridge_heap)\n    if None in result:\n        return 'No'\n    else:\n        return ('Yes', result)"
    }
  ]
}