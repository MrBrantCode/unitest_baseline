{
  "task_id": "taco_10341",
  "entry_point": "can_agent_finish_patrol",
  "mutant_count": 203,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ds = 'LURD'",
      "mutated_line": "ds = ''",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = ''\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] / 26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] / 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] + 26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] + 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] ** 26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] ** 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 1\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = -1\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 1\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 1\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = 0",
      "mutated_line": "y = -1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = -1\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 1\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] / (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] / (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] + (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] + (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] ** (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] ** (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 * 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 + 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] / (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] / (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] + (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] + (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] ** (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] ** (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "D[0] = 0",
      "mutated_line": "D[0] = 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 1\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "D[0] = 0",
      "mutated_line": "D[0] = -1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = -1\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "D[0] = 0",
      "mutated_line": "D[0] = 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 1\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] / (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] / (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] + (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] + (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] ** (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] ** (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] / (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] / (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] + (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] + (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] ** (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] ** (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "C[k] += 1",
      "mutated_line": "C[k] -= 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] -= 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return C[L] > 0",
      "mutated_line": "return C[L] >= 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] >= 0"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return C[L] > 0",
      "mutated_line": "return C[L] <= 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] <= 0"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "return C[L] > 0",
      "mutated_line": "return C[L] != 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] != 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cA = ord('A')",
      "mutated_line": "cA = ord('')",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] * 27",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 27\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] * 25",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 25\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] * 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 0\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] * 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 1\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [0] * -26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * -26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "x += dx",
      "mutated_line": "x -= dx",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x -= dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "y += dy",
      "mutated_line": "y -= dy",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y -= dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] * (L - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L - 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] * (L * 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L * 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i + 1] = SS[i] - RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] - RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i + 1] = SS[i] * RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] * RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 11 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 9 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 0 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 1 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = -10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 19\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 17\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 0\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 1\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** -18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "D[0] = 0",
      "mutated_line": "D[1] = 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[1] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "D[0] = 0",
      "mutated_line": "D[-1] = 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[-1] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "D[0] = 0",
      "mutated_line": "D[1] = 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[1] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] * (L - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L - 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] * (L * 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L * 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(hi, k) = check(HPinit, 0)",
      "mutated_line": "(hi, k) = check(HPinit, 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 1)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(hi, k) = check(HPinit, 0)",
      "mutated_line": "(hi, k) = check(HPinit, -1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, -1)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(hi, k) = check(HPinit, 0)",
      "mutated_line": "(hi, k) = check(HPinit, 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 1)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if D[state] < df or U[state]:",
      "mutated_line": "if D[state] < df and U[state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df and U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "C[k] += 1",
      "mutated_line": "C[k] += 2",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 2\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "C[k] += 1",
      "mutated_line": "C[k] += 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 0\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "C[k] += 1",
      "mutated_line": "C[k] += 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 0\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "C[k] += 1",
      "mutated_line": "C[k] += -1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += -1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "U[state] = 1",
      "mutated_line": "U[state] = 2",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 2\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "U[state] = 1",
      "mutated_line": "U[state] = 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 0\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "U[state] = 1",
      "mutated_line": "U[state] = 0",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 0\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "U[state] = 1",
      "mutated_line": "U[state] = -1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = -1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return C[L] > 0",
      "mutated_line": "return C[L] > 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return C[L] > 0",
      "mutated_line": "return C[L] > -1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > -1"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return C[L] > 0",
      "mutated_line": "return C[L] > 1",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [1] * 26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [1] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [-1] * 26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [-1] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "D = [0] * 26",
      "mutated_line": "D = [1] * 26",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [1] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "D[ord(trap) - cA] = damage",
      "mutated_line": "D[ord(trap) + cA] = damage",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) + cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "D[ord(trap) - cA] = damage",
      "mutated_line": "D[ord(trap) * cA] = damage",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) * cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[0][0]) + cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) + cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[0][0]) * cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) * cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((+1, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((+1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 1), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 1), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, -1), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, -1), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 1), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 1), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (1, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (1, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (-1, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (1, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (1, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, +1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, +1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (2, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (2, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (0, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (0, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (0, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (0, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (-1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 1), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 1), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, -1), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, -1), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 1), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 1), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (1, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (1, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (-1, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (-1, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (1, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (1, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 2))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 2))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 0))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 0))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 0))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 0))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, -1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, -1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [1] * (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [1] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [-1] * (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [-1] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [1] * (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [1] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] * (L + 2)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 2)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] * (L + 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 0)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] * (L + 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 0)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "SS = [0] * (L + 1)",
      "mutated_line": "SS = [0] * (L + -1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + -1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i - 1] = SS[i] + RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i - 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i * 1] = SS[i] + RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i * 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] + h + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h + 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, (SS[i] + h) * 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, (SS[i] + h) * 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h + (SS[idx - 1] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h + (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h * (SS[idx - 1] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h * (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] - SS[i]), idx + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx + 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] - SS[i]), idx * 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx * 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] * (2 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (2 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] * (0 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (0 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] * (0 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (0 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "D = [INF] * (1 << len(potions))",
      "mutated_line": "D = [INF] * (-1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (-1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [1] * (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [1] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [-1] * (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [-1] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [1] * (L + 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [1] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] * (L + 2)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 2)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] * (L + 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 0)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] * (L + 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 0)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "C = [0] * (L + 1)",
      "mutated_line": "C = [0] * (L + -1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + -1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [1] * (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [1] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [-1] * (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [-1] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [1] * (1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [1] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] * (2 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (2 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] * (0 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (0 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] * (0 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (0 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "U = [0] * (1 << len(potions))",
      "mutated_line": "U = [0] * (-1 << len(potions))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (-1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, 0, k, hi)]",
      "mutated_line": "que = [(1, 0, k, hi)]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(1, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, 0, k, hi)]",
      "mutated_line": "que = [(-1, 0, k, hi)]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(-1, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, 0, k, hi)]",
      "mutated_line": "que = [(1, 0, k, hi)]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(1, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, 0, k, hi)]",
      "mutated_line": "que = [(0, 1, k, hi)]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 1, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, 0, k, hi)]",
      "mutated_line": "que = [(0, -1, k, hi)]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, -1, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, 0, k, hi)]",
      "mutated_line": "que = [(0, 1, k, hi)]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 1, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if D[state] < df or U[state]:",
      "mutated_line": "if D[state] <= df or U[state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] <= df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if D[state] < df or U[state]:",
      "mutated_line": "if D[state] >= df or U[state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] >= df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if D[state] < df or U[state]:",
      "mutated_line": "if D[state] != df or U[state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] != df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "n_state = state | 1 << i",
      "mutated_line": "n_state = state & 1 << i",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state & 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "n_state = state | 1 << i",
      "mutated_line": "n_state = state ^ 1 << i",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state ^ 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if state == n_state:",
      "mutated_line": "if state != n_state:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state != n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df - max(h0 + potions[i] - HPmax, 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df - max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df * max(h0 + potions[i] - HPmax, 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df * max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if n_df < D[n_state]:",
      "mutated_line": "if n_df <= D[n_state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df <= D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if n_df < D[n_state]:",
      "mutated_line": "if n_df >= D[n_state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df >= D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if n_df < D[n_state]:",
      "mutated_line": "if n_df != D[n_state]:",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df != D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-2, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-2, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-0, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-0, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-0, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-0, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((--1, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((--1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -2), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -2), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -0), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -0), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -0), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -0), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, --1), (1, 0), (0, 1))",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, --1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = D[ord(cave[y][x]) - cA]",
      "mutated_line": "v = D[ord(cave[y][x]) + cA]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) + cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "v = D[ord(cave[y][x]) - cA]",
      "mutated_line": "v = D[ord(cave[y][x]) * cA]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) * cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i + 2] = SS[i] + RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 2] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i + 0] = SS[i] + RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 0] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i + 0] = SS[i] + RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 0] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "SS[i + 1] = SS[i] + RS[i]",
      "mutated_line": "SS[i + -1] = SS[i] + RS[i]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + -1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] - h - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] - h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] * h - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] * h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] + h - 2)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 2)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] + h - 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 0)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] + h - 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 0)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "idx = bisect(SS, SS[i] + h - 1)",
      "mutated_line": "idx = bisect(SS, SS[i] + h - -1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - -1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] + SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] + SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - SS[idx - 1] * SS[i], idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - SS[idx - 1] * SS[i], idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] - SS[i]), idx - 2)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 2)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] - SS[i]), idx - 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 0)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] - SS[i]), idx - 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 0)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 1] - SS[i]), idx - -1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - -1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_state = state | 1 << i",
      "mutated_line": "n_state = state | 2 << i",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 2 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_state = state | 1 << i",
      "mutated_line": "n_state = state | 0 << i",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 0 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_state = state | 1 << i",
      "mutated_line": "n_state = state | 0 << i",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 0 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "n_state = state | 1 << i",
      "mutated_line": "n_state = state | -1 << i",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | -1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "(h, k0) = check(min(h0 + potions[i], HPmax), k)",
      "mutated_line": "(h, k0) = check(min(h0 - potions[i], HPmax), k)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 - potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "(h, k0) = check(min(h0 + potions[i], HPmax), k)",
      "mutated_line": "(h, k0) = check(min(h0 * potions[i], HPmax), k)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 * potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max(h0 + potions[i] + HPmax, 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] + HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max((h0 + potions[i]) * HPmax, 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max((h0 + potions[i]) * HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max(h0 + potions[i] - HPmax, 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 1)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max(h0 + potions[i] - HPmax, -1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, -1)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max(h0 + potions[i] - HPmax, 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 1)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[0][1]) - cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][1]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[0][-1]) - cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][-1]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[0][1]) - cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][1]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx + 1] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx + 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx * 1] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx * 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max(h0 - potions[i] - HPmax, 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 - potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n_df = df + max(h0 + potions[i] - HPmax, 0)",
      "mutated_line": "n_df = df + max(h0 * potions[i] - HPmax, 0)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 * potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[1][0]) - cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[1][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[-1][0]) - cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[-1][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "RS = [D[ord(cave[0][0]) - cA]]",
      "mutated_line": "RS = [D[ord(cave[1][0]) - cA]]",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[1][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 2] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 2] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 0] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 0] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - 0] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - 0] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (h - (SS[idx - 1] - SS[i]), idx - 1)",
      "mutated_line": "return (h - (SS[idx - -1] - SS[i]), idx - 1)",
      "code": "from bisect import bisect\nfrom heapq import heappush, heappop\n\ndef can_agent_finish_patrol(HPinit, HPmax, R, C, cave, trap_damage, steps, potions):\n    cA = ord('A')\n    ds = 'LURD'\n    D = [0] * 26\n    for (trap, damage) in trap_damage.items():\n        D[ord(trap) - cA] = damage\n    RS = [D[ord(cave[0][0]) - cA]]\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    x = 0\n    y = 0\n    for (c, n) in steps:\n        (dx, dy) = dd[ds.index(c)]\n        for _ in range(n):\n            x += dx\n            y += dy\n            v = D[ord(cave[y][x]) - cA]\n            if v:\n                RS.append(v)\n    L = len(RS)\n    SS = [0] * (L + 1)\n    for i in range(L):\n        SS[i + 1] = SS[i] + RS[i]\n\n    def check(h, i):\n        idx = bisect(SS, SS[i] + h - 1)\n        return (h - (SS[idx - -1] - SS[i]), idx - 1)\n    INF = 10 ** 18\n    D = [INF] * (1 << len(potions))\n    D[0] = 0\n    C = [0] * (L + 1)\n    U = [0] * (1 << len(potions))\n    (hi, k) = check(HPinit, 0)\n    que = [(0, 0, k, hi)]\n    while que:\n        (df, state, k, h0) = heappop(que)\n        if D[state] < df or U[state]:\n            continue\n        C[k] += 1\n        U[state] = 1\n        for i in range(len(potions)):\n            n_state = state | 1 << i\n            if state == n_state:\n                continue\n            (h, k0) = check(min(h0 + potions[i], HPmax), k)\n            n_df = df + max(h0 + potions[i] - HPmax, 0)\n            if n_df < D[n_state]:\n                heappush(que, (n_df, n_state, k0, h))\n    return C[L] > 0"
    }
  ]
}