{
  "task_id": "taco_15723",
  "entry_point": "determine_point_position",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = p1 - p0",
      "mutated_line": "a = p1 + p0",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 + p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "a = p1 - p0",
      "mutated_line": "a = p1 * p0",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 * p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "b = p2 - p0",
      "mutated_line": "b = p2 + p0",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 + p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "b = p2 - p0",
      "mutated_line": "b = p2 * p0",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 * p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if cross(a, b) > 0:",
      "mutated_line": "return 'COUNTER_CLOCKWISE'",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) >= 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if cross(a, b) > 0:",
      "mutated_line": "return 'COUNTER_CLOCKWISE'",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) <= 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if cross(a, b) > 0:",
      "mutated_line": "return 'COUNTER_CLOCKWISE'",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) != 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real - a.imag * b.imag",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real - a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real * (a.imag * b.imag)",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real * (a.imag * b.imag)\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag + a.imag * b.real",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag + a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag * (a.imag * b.real)",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag * (a.imag * b.real)\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if cross(a, b) > 0:",
      "mutated_line": "return 'COUNTER_CLOCKWISE'",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 1:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if cross(a, b) > 0:",
      "mutated_line": "return 'COUNTER_CLOCKWISE'",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > -1:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if cross(a, b) > 0:",
      "mutated_line": "return 'COUNTER_CLOCKWISE'",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 1:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return \"COUNTER_CLOCKWISE\"",
      "mutated_line": "return ''",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return ''\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif cross(a, b) < 0:",
      "mutated_line": "elif cross(a, b) <= 0:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) <= 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif cross(a, b) < 0:",
      "mutated_line": "elif cross(a, b) >= 0:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) >= 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif cross(a, b) < 0:",
      "mutated_line": "elif cross(a, b) != 0:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) != 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real / b.real + a.imag * b.imag",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real / b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real + b.real + a.imag * b.imag",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real + b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real ** b.real + a.imag * b.imag",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real ** b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real + a.imag / b.imag",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag / b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real + (a.imag + b.imag)",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + (a.imag + b.imag)\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real + a.imag ** b.imag",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag ** b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real / b.imag - a.imag * b.real",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real / b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real + b.imag - a.imag * b.real",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real + b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real ** b.imag - a.imag * b.real",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real ** b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - a.imag / b.real",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag / b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - (a.imag + b.real)",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - (a.imag + b.real)\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - a.imag ** b.real",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag ** b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif cross(a, b) < 0:",
      "mutated_line": "elif cross(a, b) < 1:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 1:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif cross(a, b) < 0:",
      "mutated_line": "elif cross(a, b) < -1:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < -1:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "elif cross(a, b) < 0:",
      "mutated_line": "elif cross(a, b) < 1:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 1:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return \"CLOCKWISE\"",
      "mutated_line": "return ''",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return ''\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif dot(a, b) < 0:",
      "mutated_line": "elif dot(a, b) <= 0:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) <= 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif dot(a, b) < 0:",
      "mutated_line": "elif dot(a, b) >= 0:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) >= 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif dot(a, b) < 0:",
      "mutated_line": "elif dot(a, b) != 0:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) != 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif dot(a, b) < 0:",
      "mutated_line": "elif dot(a, b) < 1:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 1:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif dot(a, b) < 0:",
      "mutated_line": "elif dot(a, b) < -1:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < -1:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif dot(a, b) < 0:",
      "mutated_line": "elif dot(a, b) < 1:",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 1:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return \"ONLINE_BACK\"",
      "mutated_line": "return ''",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return ''\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif abs(a) < abs(b):",
      "mutated_line": "elif abs(a) <= abs(b):",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) <= abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif abs(a) < abs(b):",
      "mutated_line": "elif abs(a) >= abs(b):",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) >= abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif abs(a) < abs(b):",
      "mutated_line": "elif abs(a) != abs(b):",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) != abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return \"ONLINE_FRONT\"",
      "mutated_line": "return ''",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return ''\n    else:\n        return 'ON_SEGMENT'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return \"ON_SEGMENT\"",
      "mutated_line": "return ''",
      "code": "def determine_point_position(p0: complex, p1: complex, p2: complex) -> str:\n\n    def dot(a: complex, b: complex) -> float:\n        return a.real * b.real + a.imag * b.imag\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n    a = p1 - p0\n    b = p2 - p0\n    if cross(a, b) > 0:\n        return 'COUNTER_CLOCKWISE'\n    elif cross(a, b) < 0:\n        return 'CLOCKWISE'\n    elif dot(a, b) < 0:\n        return 'ONLINE_BACK'\n    elif abs(a) < abs(b):\n        return 'ONLINE_FRONT'\n    else:\n        return ''"
    }
  ]
}