{
  "task_id": "taco_1853",
  "entry_point": "dfs",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(999999999)",
      "mutated_line": "sys.setrecursionlimit(1000000000)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000000)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(999999999)",
      "mutated_line": "sys.setrecursionlimit(999999998)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999998)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(999999999)",
      "mutated_line": "sys.setrecursionlimit(0)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(0)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(999999999)",
      "mutated_line": "sys.setrecursionlimit(1)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "sys.setrecursionlimit(999999999)",
      "mutated_line": "sys.setrecursionlimit(-999999999)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(-999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "vis[node] = True",
      "mutated_line": "vis[node] = False",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = False\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 1 or node != 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 or node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) != 1 and node != 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) != 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 1 and node == 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node == 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x += 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b += 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vis = [False] * N",
      "mutated_line": "vis = [False] / N",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] / N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vis = [False] * N",
      "mutated_line": "vis = [False] + N",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] + N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vis = [False] * N",
      "mutated_line": "vis = [False] ** N",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] ** N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 1\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = -1\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 1\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 1\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = -1\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 1\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 1\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = -1\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 1\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i < M or j < len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M or j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i -= 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 2 and node != 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 2 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 0 and node != 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 0 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 0 and node != 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 0 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == -1 and node != 0:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == -1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 1 and node != 1:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 1:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 1 and node != -1:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != -1:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if len(graph[node]) == 1 and node != 0:",
      "mutated_line": "if len(graph[node]) == 1 and node != 1:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 1:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 2\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 0\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 0\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= -1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 2\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 0\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 0\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= -1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(1, graph, 0, 0, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(1, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(-1, graph, 0, 0, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(-1, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(1, graph, 0, 0, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(1, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(0, graph, 1, 0, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 1, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(0, graph, -1, 0, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, -1, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(0, graph, 1, 0, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 1, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(0, graph, 0, 1, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 1, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(0, graph, 0, -1, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, -1, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(0, graph, 0, 0, vis, arr)",
      "mutated_line": "dfs(0, graph, 0, 1, vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 1, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i <= M and j < len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i <= M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i >= M and j < len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i >= M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i != M and j < len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i != M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i < M and j <= len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j <= len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i < M and j >= len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j >= len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while i < M and j < len(arr):",
      "mutated_line": "while i < M and j != len(arr):",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j != len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if pilgrim_energies[i] >= arr[j]:",
      "mutated_line": "if pilgrim_energies[i] > arr[j]:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] > arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if pilgrim_energies[i] >= arr[j]:",
      "mutated_line": "if pilgrim_energies[i] < arr[j]:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] < arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if pilgrim_energies[i] >= arr[j]:",
      "mutated_line": "if pilgrim_energies[i] == arr[j]:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] == arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j -= 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans -= 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 2\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 0\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 0\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += -1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count - 1, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count - 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count * 1, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count * 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance - (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance - (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance * ((count + 1) * i[1]), vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance * ((count + 1) * i[1]), vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vis = [False] * N",
      "mutated_line": "vis = [True] * N",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [True] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 2\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 0\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 0\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += -1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 2\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 0\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 0\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += -1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if not vis[i[0]]:",
      "mutated_line": "if not vis[i[1]]:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[1]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if not vis[i[0]]:",
      "mutated_line": "if not vis[i[-1]]:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[-1]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if not vis[i[0]]:",
      "mutated_line": "if not vis[i[1]]:",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[1]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[1], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[1], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[-1], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[-1], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[1], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[1], graph, count + 1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 2, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 2, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 0, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 0, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 0, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 0, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + -1, distance + (count + 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + -1, distance + (count + 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1) / i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) / i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1 + i[1]), vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1 + i[1]), vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1) ** i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) ** i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count - 1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count - 1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + count * 1 * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + count * 1 * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 2) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 2) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 0) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 0) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 0) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 0) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + -1) * i[1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + -1) * i[1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[2], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[2], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[0], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[0], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[0], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[0], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[1], vis, arr)",
      "mutated_line": "dfs(i[0], graph, count + 1, distance + (count + 1) * i[-1], vis, arr)",
      "code": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(999999999)\n\ndef dfs(node, graph, count, distance, vis, arr):\n    vis[node] = True\n    if len(graph[node]) == 1 and node != 0:\n        arr.append(distance)\n    for i in graph[node]:\n        if not vis[i[0]]:\n            dfs(i[0], graph, count + 1, distance + (count + 1) * i[-1], vis, arr)\n\ndef max_non_empty_special_cities(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, M, pilgrim_energies, edges) = case\n        graph = defaultdict(list)\n        for (x, b, c) in edges:\n            x -= 1\n            b -= 1\n            graph[x].append([b, c])\n            graph[b].append([x, c])\n        arr = []\n        vis = [False] * N\n        dfs(0, graph, 0, 0, vis, arr)\n        pilgrim_energies.sort()\n        arr.sort()\n        ans = 0\n        i = 0\n        j = 0\n        while i < M and j < len(arr):\n            if pilgrim_energies[i] >= arr[j]:\n                j += 1\n                ans += 1\n            i += 1\n        results.append(ans)\n    return results"
    }
  ]
}