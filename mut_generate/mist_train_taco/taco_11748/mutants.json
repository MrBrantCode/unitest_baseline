{
  "task_id": "taco_11748",
  "entry_point": "min_operations_to_equalize_array",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n is None:",
      "mutated_line": "if n is not None:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is not None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n != 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 2:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 0:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 0:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == -1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 1\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return -1\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 1\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "min_operations = float('inf')",
      "mutated_line": "min_operations = float('')",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "current_segment_sum = 0",
      "mutated_line": "current_segment_sum = 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 1\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "current_segment_sum = 0",
      "mutated_line": "current_segment_sum = -1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = -1\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "current_segment_sum = 0",
      "mutated_line": "current_segment_sum = 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 1\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "valid_segment = True",
      "mutated_line": "valid_segment = False",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = False\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "current_segment_sum += a[j]",
      "mutated_line": "current_segment_sum -= a[j]",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum -= a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if valid_segment and current_segment_sum == 0:",
      "mutated_line": "if valid_segment or current_segment_sum == 0:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment or current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i - 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i * 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if current_segment_sum == current_sum:",
      "mutated_line": "if current_segment_sum != current_sum:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum != current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if valid_segment and current_segment_sum == 0:",
      "mutated_line": "if valid_segment and current_segment_sum != 0:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum != 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 2, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 0, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 0, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + -1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_segment_sum = 0",
      "mutated_line": "current_segment_sum = 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 1\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_segment_sum = 0",
      "mutated_line": "current_segment_sum = -1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = -1\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "current_segment_sum = 0",
      "mutated_line": "current_segment_sum = 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 1\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif current_segment_sum > current_sum:",
      "mutated_line": "elif current_segment_sum >= current_sum:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum >= current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif current_segment_sum > current_sum:",
      "mutated_line": "elif current_segment_sum <= current_sum:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum <= current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif current_segment_sum > current_sum:",
      "mutated_line": "elif current_segment_sum != current_sum:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum != current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if valid_segment and current_segment_sum == 0:",
      "mutated_line": "if valid_segment and current_segment_sum == 1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 1:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if valid_segment and current_segment_sum == 0:",
      "mutated_line": "if valid_segment and current_segment_sum == -1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == -1:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if valid_segment and current_segment_sum == 0:",
      "mutated_line": "if valid_segment and current_segment_sum == 1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 1:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "current_sum = sum(a[:i + 1])",
      "mutated_line": "current_sum = sum(a[:i - 1])",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i - 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "current_sum = sum(a[:i + 1])",
      "mutated_line": "current_sum = sum(a[:i * 1])",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i * 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "valid_segment = False",
      "mutated_line": "valid_segment = True",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = True\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif current_segment_sum != 0:",
      "mutated_line": "elif current_segment_sum == 0:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum == 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "moves += 1",
      "mutated_line": "moves -= 1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves -= 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_sum = sum(a[:i + 1])",
      "mutated_line": "current_sum = sum(a[:i + 2])",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 2])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_sum = sum(a[:i + 1])",
      "mutated_line": "current_sum = sum(a[:i + 0])",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 0])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_sum = sum(a[:i + 1])",
      "mutated_line": "current_sum = sum(a[:i + 0])",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 0])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "current_sum = sum(a[:i + 1])",
      "mutated_line": "current_sum = sum(a[:i + -1])",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + -1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif current_segment_sum != 0:",
      "mutated_line": "elif current_segment_sum != 1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 1:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif current_segment_sum != 0:",
      "mutated_line": "elif current_segment_sum != -1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != -1:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif current_segment_sum != 0:",
      "mutated_line": "elif current_segment_sum != 1:",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 1:\n                moves += 1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "moves += 1",
      "mutated_line": "moves += 2",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 2\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "moves += 1",
      "mutated_line": "moves += 0",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 0\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "moves += 1",
      "mutated_line": "moves += 0",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += 0\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "moves += 1",
      "mutated_line": "moves += -1",
      "code": "def min_operations_to_equalize_array(a, n=None):\n    if n is None:\n        n = len(a)\n    if n == 1:\n        return 0\n    min_operations = float('inf')\n    for i in range(n):\n        current_sum = sum(a[:i + 1])\n        moves = i\n        current_segment_sum = 0\n        valid_segment = True\n        for j in range(i + 1, n):\n            current_segment_sum += a[j]\n            if current_segment_sum == current_sum:\n                current_segment_sum = 0\n            elif current_segment_sum > current_sum:\n                valid_segment = False\n                break\n            elif current_segment_sum != 0:\n                moves += -1\n        if valid_segment and current_segment_sum == 0:\n            min_operations = min(min_operations, moves)\n    return min_operations"
    }
  ]
}