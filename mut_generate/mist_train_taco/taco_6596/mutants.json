{
  "task_id": "taco_6596",
  "entry_point": "find_smallest_subarray_size",
  "mutant_count": 221,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = N + 1",
      "mutated_line": "res = N - 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N - 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = N + 1",
      "mutated_line": "res = N * 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N * 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rt = 0",
      "mutated_line": "rt = 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 1\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rt = 0",
      "mutated_line": "rt = -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = -1\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "rt = 0",
      "mutated_line": "rt = 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 1\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "idx += self.n",
      "mutated_line": "idx -= self.n",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx -= self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "lt += self.n",
      "mutated_line": "lt -= self.n",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt -= self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "rt += self.n",
      "mutated_line": "rt -= self.n",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt -= self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = N + 1",
      "mutated_line": "res = N + 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 2\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = N + 1",
      "mutated_line": "res = N + 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 0\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = N + 1",
      "mutated_line": "res = N + 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 0\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = N + 1",
      "mutated_line": "res = N + -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + -1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "st = SegmentTree([0] * K)",
      "mutated_line": "st = SegmentTree([0] / K)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] / K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "st = SegmentTree([0] * K)",
      "mutated_line": "st = SegmentTree([0] + K)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] + K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "st = SegmentTree([0] * K)",
      "mutated_line": "st = SegmentTree([0] ** K)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] ** K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N or st.tree[1] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N or st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "rt += 1",
      "mutated_line": "rt -= 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt -= 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[1] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] == 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if A[lt] <= K:",
      "mutated_line": "if A[lt] < K:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] < K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if A[lt] <= K:",
      "mutated_line": "if A[lt] > K:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] > K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if A[lt] <= K:",
      "mutated_line": "if A[lt] == K:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] == K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "return res if res <= N else 0",
      "mutated_line": "return res if res < N else 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res < N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "return res if res <= N else 0",
      "mutated_line": "return res if res > N else 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res > N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "return res if res <= N else 0",
      "mutated_line": "return res if res == N else 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res == N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return res if res <= N else 0",
      "mutated_line": "return res if res <= N else 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return res if res <= N else 0",
      "mutated_line": "return res if res <= N else -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return res if res <= N else 0",
      "mutated_line": "return res if res <= N else 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 * 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 + 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = 2 * self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 * self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = 2 + self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 + self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt - lt >= 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt >= 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt - lt <= 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt <= 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt - lt != 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt != 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt <= N and st.tree[1] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt <= N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt >= N and st.tree[1] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt >= N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt != N and st.tree[1] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt != N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[1] != 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] != 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if A[rt] <= K:",
      "mutated_line": "if A[rt] < K:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] < K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if A[rt] <= K:",
      "mutated_line": "if A[rt] > K:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] > K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if A[rt] <= K:",
      "mutated_line": "if A[rt] == K:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] == K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rt += 1",
      "mutated_line": "rt += 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 2\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rt += 1",
      "mutated_line": "rt += 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 0\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rt += 1",
      "mutated_line": "rt += 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 0\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rt += 1",
      "mutated_line": "rt += -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += -1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[1] != 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 1:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[1] != -1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != -1:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[1] != 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 1:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=3 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=1 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=0 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=1 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=-2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 64):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 62):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 0):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 1):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, arr, func=min, ie=2 ** 63):",
      "mutated_line": "",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** -63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = 3 ** self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 3 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = 1 ** self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 1 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = 0 ** self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 0 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = 1 ** self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 1 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.n = 2 ** self.h",
      "mutated_line": "self.n = -2 ** self.h",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = -2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "idx >>= 1",
      "mutated_line": "idx >>= 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 2\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "idx >>= 1",
      "mutated_line": "idx >>= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 0\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "idx >>= 1",
      "mutated_line": "idx >>= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 0\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "idx >>= 1",
      "mutated_line": "idx >>= -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= -1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt + lt > 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt + lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt * lt > 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt * lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt - lt > 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 1:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt - lt > -1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > -1:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while rt - lt > 0:",
      "mutated_line": "while rt - lt > 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 1:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if lt & 1:",
      "mutated_line": "if lt | 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt | 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "lt += 1",
      "mutated_line": "lt -= 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt -= 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if rt & 1:",
      "mutated_line": "if rt | 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt | 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "rt -= 1",
      "mutated_line": "rt += 1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt += 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "lt >>= 1",
      "mutated_line": "lt >>= 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 2\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "lt >>= 1",
      "mutated_line": "lt >>= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 0\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "lt >>= 1",
      "mutated_line": "lt >>= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 0\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "lt >>= 1",
      "mutated_line": "lt >>= -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= -1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rt >>= 1",
      "mutated_line": "rt >>= 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 2\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rt >>= 1",
      "mutated_line": "rt >>= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 0\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rt >>= 1",
      "mutated_line": "rt >>= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 0\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "rt >>= 1",
      "mutated_line": "rt >>= -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= -1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "st = SegmentTree([0] * K)",
      "mutated_line": "st = SegmentTree([1] * K)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([1] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "st = SegmentTree([0] * K)",
      "mutated_line": "st = SegmentTree([-1] * K)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([-1] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "st = SegmentTree([0] * K)",
      "mutated_line": "st = SegmentTree([1] * K)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([1] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[1] == 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 1:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[1] == -1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == -1:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[1] == 1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 1:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[2] != 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[2] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[0] != 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[0] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[0] != 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[0] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if st.tree[1] != 0:",
      "mutated_line": "if st.tree[-1] != 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[-1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = min(res, rt - lt)",
      "mutated_line": "res = min(res, rt + lt)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt + lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "res = min(res, rt - lt)",
      "mutated_line": "res = min(res, rt * lt)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt * lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] + 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] + 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] * 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] * 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) + 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) * 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) * 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.h = (len(arr) - 1).bit_length()",
      "mutated_line": "self.h = (len(arr) + 1).bit_length()",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) + 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.h = (len(arr) - 1).bit_length()",
      "mutated_line": "self.h = (len(arr) * 1).bit_length()",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) * 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "self.tree[self.n + i] = arr[i]",
      "mutated_line": "self.tree[self.n - i] = arr[i]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n - i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "self.tree[self.n + i] = arr[i]",
      "mutated_line": "self.tree[self.n * i] = arr[i]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n * i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(2, self.n)[::-1]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(2, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(0, self.n)[::-1]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(0, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(0, self.n)[::-1]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(0, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(-1, self.n)[::-1]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(-1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(1, self.n)[::+1]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::+1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if lt & 1:",
      "mutated_line": "if lt & 2:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 2:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if lt & 1:",
      "mutated_line": "if lt & 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 0:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if lt & 1:",
      "mutated_line": "if lt & 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 0:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if lt & 1:",
      "mutated_line": "if lt & -1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & -1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lt += 1",
      "mutated_line": "lt += 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 2\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lt += 1",
      "mutated_line": "lt += 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 0\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lt += 1",
      "mutated_line": "lt += 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 0\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "lt += 1",
      "mutated_line": "lt += -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += -1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if rt & 1:",
      "mutated_line": "if rt & 2:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 2:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if rt & 1:",
      "mutated_line": "if rt & 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 0:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if rt & 1:",
      "mutated_line": "if rt & 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 0:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if rt & 1:",
      "mutated_line": "if rt & -1:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & -1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rt -= 1",
      "mutated_line": "rt -= 2",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 2\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rt -= 1",
      "mutated_line": "rt -= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 0\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rt -= 1",
      "mutated_line": "rt -= 0",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 0\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "rt -= 1",
      "mutated_line": "rt -= -1",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= -1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[2] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[2] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[0] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[0] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[0] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[0] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while rt < N and st.tree[1] == 0:",
      "mutated_line": "while rt < N and st.tree[-1] == 0:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[-1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] + 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] + 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] * 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] * 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) - 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) * 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) * 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 2, st.query(A[lt] - 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 2, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 0, st.query(A[lt] - 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 0, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 0, st.query(A[lt] - 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 0, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - -1, st.query(A[lt] - 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - -1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 2)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 2)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 0)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 0)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 0)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 0)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - -1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - -1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.h = (len(arr) - 1).bit_length()",
      "mutated_line": "self.h = (len(arr) - 2).bit_length()",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 2).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.h = (len(arr) - 1).bit_length()",
      "mutated_line": "self.h = (len(arr) - 0).bit_length()",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 0).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.h = (len(arr) - 1).bit_length()",
      "mutated_line": "self.h = (len(arr) - 0).bit_length()",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 0).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.h = (len(arr) - 1).bit_length()",
      "mutated_line": "self.h = (len(arr) - -1).bit_length()",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - -1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(2 / self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 / self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(2 + self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 + self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(2 ** self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 ** self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(1, self.n)[::-2]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-2]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(1, self.n)[::-0]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-0]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(1, self.n)[::-0]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-0]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, self.n)[::-1]:",
      "mutated_line": "for i in range(1, self.n)[::--1]:",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::--1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 / i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 / i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 + i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 + i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 ** i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 ** i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i - 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i - 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i * 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i * 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 / idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 / idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 + idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 + idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 ** idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 ** idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx - 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx - 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx * 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx * 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 2, st.query(A[rt] - 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 2, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 0, st.query(A[rt] - 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 0, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 0, st.query(A[rt] - 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 0, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - -1, st.query(A[rt] - 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - -1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 2)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 2)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 0)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 0)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 0)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 0)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + -1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + -1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] + 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] + 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] * 1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] * 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(3 * self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(3 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(1 * self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(1 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(0 * self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(0 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(1 * self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(1 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.tree = [ie for _ in range(2 * self.n)]",
      "mutated_line": "self.tree = [ie for _ in range(-2 * self.n)]",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(-2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[3 * i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[3 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[1 * i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[1 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[0 * i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[0 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[1 * i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[1 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[-2 * i], self.tree[2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[-2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 / i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 / i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 + i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 + i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 ** i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 ** i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 2])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 2])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 0])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 0])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 0])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 0])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + -1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + -1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[3 * idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[3 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[1 * idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[1 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[0 * idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[0 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[1 * idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[1 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[-2 * idx], self.tree[2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[-2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 / idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 / idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 + idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 + idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 ** idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 ** idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 2])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 2])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 0])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 0])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 0])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 0])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + -1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + -1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] + 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] + 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] * 1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] * 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 2, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 2, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 0, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 0, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - 0, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 0, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)",
      "mutated_line": "st.set(A[lt] - 1, st.query(A[lt] - -1, A[lt]) - 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - -1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[3 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[3 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[1 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[1 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[0 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[0 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[1 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[1 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])",
      "mutated_line": "self.tree[i] = func(self.tree[2 * i], self.tree[-2 * i + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[-2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[3 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[3 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[1 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[1 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[0 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[0 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[1 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[1 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])",
      "mutated_line": "self.tree[idx] = self.func(self.tree[2 * idx], self.tree[-2 * idx + 1])",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[-2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 2, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 2, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 0, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 0, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - 0, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - 0, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "st.set(A[rt] - 1, st.query(A[rt] - 1, A[rt]) + 1)",
      "mutated_line": "st.set(A[rt] - 1, st.query(A[rt] - -1, A[rt]) + 1)",
      "code": "def find_smallest_subarray_size(N, K, A):\n\n    class SegmentTree:\n\n        def __init__(self, arr, func=min, ie=2 ** 63):\n            self.h = (len(arr) - 1).bit_length()\n            self.n = 2 ** self.h\n            self.ie = ie\n            self.func = func\n            self.tree = [ie for _ in range(2 * self.n)]\n            for i in range(len(arr)):\n                self.tree[self.n + i] = arr[i]\n            for i in range(1, self.n)[::-1]:\n                self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n        def set(self, idx, x):\n            idx += self.n\n            self.tree[idx] = x\n            while idx:\n                idx >>= 1\n                self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n        def query(self, lt, rt):\n            lt += self.n\n            rt += self.n\n            vl = vr = self.ie\n            while rt - lt > 0:\n                if lt & 1:\n                    vl = self.func(vl, self.tree[lt])\n                    lt += 1\n                if rt & 1:\n                    rt -= 1\n                    vr = self.func(self.tree[rt], vr)\n                lt >>= 1\n                rt >>= 1\n            return self.func(vl, vr)\n    res = N + 1\n    st = SegmentTree([0] * K)\n    rt = 0\n    for lt in range(N):\n        while rt < N and st.tree[1] == 0:\n            if A[rt] <= K:\n                st.set(A[rt] - 1, st.query(A[rt] - -1, A[rt]) + 1)\n            rt += 1\n        if st.tree[1] != 0:\n            res = min(res, rt - lt)\n        if A[lt] <= K:\n            st.set(A[lt] - 1, st.query(A[lt] - 1, A[lt]) - 1)\n    return res if res <= N else 0"
    }
  ]
}