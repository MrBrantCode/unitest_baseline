{
  "task_id": "taco_5473",
  "entry_point": "count_walks_with_cost",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] / 6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] / 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] + 6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] + 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] ** 6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] ** 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "freq = 0",
      "mutated_line": "freq = 1",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 1\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "freq = 0",
      "mutated_line": "freq = -1",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = -1\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "freq = 0",
      "mutated_line": "freq = 1",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 1\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "freq -= B[u][X] * B[u][X]",
      "mutated_line": "freq += B[u][X] * B[u][X]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq += B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] * 7",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 7\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] * 5",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 5\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] * 0",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 0\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] * 1",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 1\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [0] * -6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * -6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if l == 2:",
      "mutated_line": "if l != 2:",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l != 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "B[u][maxiedges[l]] += 1",
      "mutated_line": "B[u][maxiedges[l]] -= 1",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] -= 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(2, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(0, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(0, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(-1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n - 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n * 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(2, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(2, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(0, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(0, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(0, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(0, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(-1, n + 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(-1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n - 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n - 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n * 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n * 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq -= 2 * B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq -= 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "freq -= B[u][X] * B[u][X]",
      "mutated_line": "freq -= B[u][X] / B[u][X]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] / B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "freq -= B[u][X] * B[u][X]",
      "mutated_line": "freq -= B[u][X] + B[u][X]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] + B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "freq -= B[u][X] * B[u][X]",
      "mutated_line": "freq -= B[u][X] ** B[u][X]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] ** B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [1] * 6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [1] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [-1] * 6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [-1] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "maxiedges = [0] * 6",
      "mutated_line": "maxiedges = [1] * 6",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [1] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[1 for _ in range(101)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[1 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[-1 for _ in range(101)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[-1 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[1 for _ in range(101)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[1 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if l == 2:",
      "mutated_line": "if l == 3:",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 3:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if l == 2:",
      "mutated_line": "if l == 1:",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 1:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if l == 2:",
      "mutated_line": "if l == 0:",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 0:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if l == 2:",
      "mutated_line": "if l == 1:",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 1:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if l == 2:",
      "mutated_line": "if l == -2:",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == -2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "B[u][maxiedges[l]] += 1",
      "mutated_line": "B[u][maxiedges[l]] += 2",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 2\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "B[u][maxiedges[l]] += 1",
      "mutated_line": "B[u][maxiedges[l]] += 0",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 0\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "B[u][maxiedges[l]] += 1",
      "mutated_line": "B[u][maxiedges[l]] += 0",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 0\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "B[u][maxiedges[l]] += 1",
      "mutated_line": "B[u][maxiedges[l]] += -1",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += -1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 2):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 0):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 0):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + -1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "func(i, i, 0)",
      "mutated_line": "func(i, i, 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 1)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "func(i, i, 0)",
      "mutated_line": "func(i, i, -1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, -1)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "func(i, i, 0)",
      "mutated_line": "func(i, i, 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 1)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + 2):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 2):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + 0):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 0):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + 0):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 0):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + -1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + -1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for x in range(X + 1):",
      "mutated_line": "for x in range(X - 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X - 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for x in range(X + 1):",
      "mutated_line": "for x in range(X * 1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X * 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 2 * B[u][X] / B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] / B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 2 * B[u][X] + B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] + B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += (2 * B[u][X]) ** B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += (2 * B[u][X]) ** B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(101)] for _ in range(102)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(102)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(101)] for _ in range(100)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(100)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(101)] for _ in range(0)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(0)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(101)] for _ in range(1)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(1)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(101)] for _ in range(-101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(-101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for x in range(X + 1):",
      "mutated_line": "for x in range(X + 2):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 2):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for x in range(X + 1):",
      "mutated_line": "for x in range(X + 0):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 0):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for x in range(X + 1):",
      "mutated_line": "for x in range(X + 0):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 0):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for x in range(X + 1):",
      "mutated_line": "for x in range(X + -1):",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + -1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 2 / B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 / B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += (2 + B[u][X]) * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += (2 + B[u][X]) * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 2 ** B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 ** B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(102)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(102)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(100)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(100)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(0)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(0)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(1)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(1)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "B = [[0 for _ in range(101)] for _ in range(101)]",
      "mutated_line": "B = [[0 for _ in range(-101)] for _ in range(101)]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(-101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l - 1] = max(maxiedges[l], j[1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l - 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l * 1] = max(maxiedges[l], j[1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l * 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[0], l - 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l - 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[0], l * 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l * 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 3 * B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 3 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 1 * B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 1 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 0 * B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 0 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += 1 * B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 1 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "freq += 2 * B[u][X] * B[u][x]",
      "mutated_line": "freq += -2 * B[u][X] * B[u][x]",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += -2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 2] = max(maxiedges[l], j[1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 2] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 0] = max(maxiedges[l], j[1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 0] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 0] = max(maxiedges[l], j[1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 0] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + -1] = max(maxiedges[l], j[1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + -1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 1] = max(maxiedges[l], j[2])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[2])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 1] = max(maxiedges[l], j[0])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[0])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 1] = max(maxiedges[l], j[0])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[0])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "maxiedges[l + 1] = max(maxiedges[l], j[1])",
      "mutated_line": "maxiedges[l + 1] = max(maxiedges[l], j[-1])",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[-1])\n                    func(u, j[0], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[1], l + 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[1], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[-1], l + 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[-1], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[1], l + 1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[1], l + 1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[0], l + 2)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 2)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[0], l + 0)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 0)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[0], l + 0)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + 0)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "func(u, j[0], l + 1)",
      "mutated_line": "func(u, j[0], l + -1)",
      "code": "from collections import defaultdict\n\ndef count_walks_with_cost(n, edges, queries):\n\n    def create_graph(edges):\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def precompute(graph, n):\n        maxiedges = [0] * 6\n        B = [[0 for _ in range(101)] for _ in range(101)]\n\n        def func(u, v, l):\n            if l == 2:\n                B[u][maxiedges[l]] += 1\n            else:\n                for j in graph[v]:\n                    maxiedges[l + 1] = max(maxiedges[l], j[1])\n                    func(u, j[0], l + -1)\n        for i in range(1, n + 1):\n            func(i, i, 0)\n        return B\n\n    def paths(B, n, X):\n        freq = 0\n        for u in range(1, n + 1):\n            for x in range(X + 1):\n                freq += 2 * B[u][X] * B[u][x]\n            freq -= B[u][X] * B[u][X]\n        return freq\n    graph = create_graph(edges)\n    B = precompute(graph, n)\n    results = []\n    for X in queries:\n        results.append(paths(B, n, X))\n    return results"
    }
  ]
}