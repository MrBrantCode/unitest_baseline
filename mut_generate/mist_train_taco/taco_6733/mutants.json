{
  "task_id": "taco_6733",
  "entry_point": "find_pth_special_number",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum = 0",
      "mutated_line": "sum = 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 1\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum = 0",
      "mutated_line": "sum = -1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = -1\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sum = 0",
      "mutated_line": "sum = 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 1\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum -= a_i * mul_inv(p, n_i) * p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum -= a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return sum % prod",
      "mutated_line": "return sum * prod",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum * prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return sum % prod",
      "mutated_line": "return sum + prod",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum + prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b != 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b != 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a >= 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a <= 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a != 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 <= 0:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 <= 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 >= 0:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 >= 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 != 0:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 != 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 < 0:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 -= b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = 2",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 2\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 0\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 0\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "x = 1",
      "mutated_line": "x = -1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = -1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "x *= n[i][j]",
      "mutated_line": "x /= n[i][j]",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x /= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y - (p[i] - 1) * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y - (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y * ((p[i] - 1) * y)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y * ((p[i] - 1) * y)\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "p = prod // n_i",
      "mutated_line": "p = prod / n_i",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod / n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "p = prod // n_i",
      "mutated_line": "p = prod * n_i",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod * n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum += a_i * mul_inv(p, n_i) / p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) / p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum += a_i * mul_inv(p, n_i) + p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) + p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum += (a_i * mul_inv(p, n_i)) ** p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += (a_i * mul_inv(p, n_i)) ** p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (1, 1)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (1, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (-1, 1)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (-1, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (1, 1)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (1, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (0, 2)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 2)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (0, 0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 0)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (0, 0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 0)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x0, x1 = 0, 1",
      "mutated_line": "(x0, x1) = (0, -1)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, -1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 2:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 2:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 0:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 0:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 0:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 0:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == -1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == -1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 2\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 0\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 0\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if b == 1: return 1",
      "mutated_line": "if b == 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return -1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 2:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 0:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 0:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while a > 1:",
      "mutated_line": "return 1",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > -1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = a // b",
      "mutated_line": "q = a / b",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a / b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q = a // b",
      "mutated_line": "q = a * b",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a * b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 < 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 1:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 < -1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < -1:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if x1 < 0: x1 += b0",
      "mutated_line": "if x1 < 1:",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 1:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - 1) / y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) / y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - 1 + y)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1 + y)\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - 1) ** y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) ** y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y * 1000000007)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y * 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y + 1000000007)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y + 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prod = reduce(lambda a, b: a*b, n)",
      "mutated_line": "prod = reduce(lambda a, b: a / b, n)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a / b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prod = reduce(lambda a, b: a*b, n)",
      "mutated_line": "prod = reduce(lambda a, b: a + b, n)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a + b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prod = reduce(lambda a, b: a*b, n)",
      "mutated_line": "prod = reduce(lambda a, b: a ** b, n)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a ** b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum += a_i / mul_inv(p, n_i) * p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i / mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum += (a_i + mul_inv(p, n_i)) * p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += (a_i + mul_inv(p, n_i)) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sum += a_i * mul_inv(p, n_i) * p",
      "mutated_line": "sum += a_i ** mul_inv(p, n_i) * p",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i ** mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a, b = b, a % b",
      "mutated_line": "(a, b) = (b, a * b)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a * b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a, b = b, a % b",
      "mutated_line": "(a, b) = (b, a + b)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a + b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "x0, x1 = x1 - q * x0, x0",
      "mutated_line": "(x0, x1) = (x1 + q * x0, x0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 + q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "x0, x1 = x1 - q * x0, x0",
      "mutated_line": "(x0, x1) = (x1 * (q * x0), x0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 * (q * x0), x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] + 1) * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] + 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + p[i] * 1 * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + p[i] * 1 * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y % 1000000008)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000008)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y % 1000000006)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000006)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y % 0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y % 1)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(y % 1000000007)",
      "mutated_line": "results.append(y % -1000000007)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % -1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "x0, x1 = x1 - q * x0, x0",
      "mutated_line": "(x0, x1) = (x1 - q / x0, x0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q / x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "x0, x1 = x1 - q * x0, x0",
      "mutated_line": "(x0, x1) = (x1 - (q + x0), x0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - (q + x0), x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "x0, x1 = x1 - q * x0, x0",
      "mutated_line": "(x0, x1) = (x1 - q ** x0, x0)",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q ** x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 1) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - 2) * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 2) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - 0) * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 0) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - 0) * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - 0) * y\n        results.append(y % 1000000007)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y = y + (p[i] - 1) * y",
      "mutated_line": "y = y + (p[i] - -1) * y",
      "code": "import functools\nfrom functools import reduce\n\ndef find_pth_special_number(t, k, p, n, a):\n\n    def chinese_remainder(n, a, k):\n        sum = 0\n        prod = reduce(lambda a, b: a * b, n)\n        for (n_i, a_i) in zip(n, a):\n            p = prod // n_i\n            sum += a_i * mul_inv(p, n_i) * p\n        return sum % prod\n\n    def mul_inv(a, b):\n        b0 = b\n        (x0, x1) = (0, 1)\n        if b == 1:\n            return 1\n        while a > 1:\n            q = a // b\n            (a, b) = (b, a % b)\n            (x0, x1) = (x1 - q * x0, x0)\n        if x1 < 0:\n            x1 += b0\n        return x1\n    results = []\n    for i in range(t):\n        x = 1\n        for j in range(k):\n            x *= n[i][j]\n        y = chinese_remainder(n[i], a[i], k)\n        y = y + (p[i] - -1) * y\n        results.append(y % 1000000007)\n    return results"
    }
  ]
}