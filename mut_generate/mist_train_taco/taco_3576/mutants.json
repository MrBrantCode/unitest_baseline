{
  "task_id": "taco_3576",
  "entry_point": "calculate_min_fuel_cost",
  "mutant_count": 65,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "start_point = 0",
      "mutated_line": "start_point = 1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 1\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "start_point = 0",
      "mutated_line": "start_point = -1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = -1\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "start_point = 0",
      "mutated_line": "start_point = 1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 1\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 1\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = -1\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 1\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while current_point != d:",
      "mutated_line": "while current_point == d:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point == d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "gas_tank_volume -= distance",
      "mutated_line": "gas_tank_volume += distance",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume += distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "gas_prices = {start_point: 0}",
      "mutated_line": "gas_prices = {start_point: 1}",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 1}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "gas_prices = {start_point: 0}",
      "mutated_line": "gas_prices = {start_point: -1}",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: -1}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "gas_prices = {start_point: 0}",
      "mutated_line": "gas_prices = {start_point: 1}",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 1}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "farthest_reachable_point = current_point + gas_tank_volume",
      "mutated_line": "farthest_reachable_point = current_point - gas_tank_volume",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point - gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "farthest_reachable_point = current_point + gas_tank_volume",
      "mutated_line": "farthest_reachable_point = current_point * gas_tank_volume",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point * gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points or points[-1] <= farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points or points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "distance = next_point - current_point",
      "mutated_line": "distance = next_point + current_point",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point + current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "distance = next_point - current_point",
      "mutated_line": "distance = next_point * current_point",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point * current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:",
      "mutated_line": "if next_point != d or gas_prices[current_point] <= gas_prices[next_point]:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d or gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if required_gas_volume > gas_tank_volume:",
      "mutated_line": "if required_gas_volume >= gas_tank_volume:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume >= gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if required_gas_volume > gas_tank_volume:",
      "mutated_line": "if required_gas_volume <= gas_tank_volume:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume <= gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if required_gas_volume > gas_tank_volume:",
      "mutated_line": "if required_gas_volume != gas_tank_volume:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume != gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "mutated_line": "count -= (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count -= (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "points = sorted(gas_prices.keys(), reverse=True)",
      "mutated_line": "points = sorted(gas_prices.keys(), reverse=False)",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=False)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[-1] < farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] < farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[-1] > farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] > farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[-1] == farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] == farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point >= d or (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d or (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif farthest_reachable_point >= d:",
      "mutated_line": "elif farthest_reachable_point > d:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point > d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif farthest_reachable_point >= d:",
      "mutated_line": "elif farthest_reachable_point < d:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point < d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif farthest_reachable_point >= d:",
      "mutated_line": "elif farthest_reachable_point == d:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point == d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:",
      "mutated_line": "if next_point == d and gas_prices[current_point] <= gas_prices[next_point]:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point == d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:",
      "mutated_line": "if next_point != d and gas_prices[current_point] < gas_prices[next_point]:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] < gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:",
      "mutated_line": "if next_point != d and gas_prices[current_point] > gas_prices[next_point]:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] > gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:",
      "mutated_line": "if next_point != d and gas_prices[current_point] == gas_prices[next_point]:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] == gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "mutated_line": "count += (required_gas_volume - gas_tank_volume) / gas_prices[current_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) / gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "mutated_line": "count += required_gas_volume - gas_tank_volume + gas_prices[current_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += required_gas_volume - gas_tank_volume + gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "mutated_line": "count += (required_gas_volume - gas_tank_volume) ** gas_prices[current_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) ** gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point > d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point > d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point < d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point < d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point == d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point == d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point >= d and (current_point == start_point and gas_prices[next_point] >= gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point and gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return +1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "mutated_line": "count += (required_gas_volume + gas_tank_volume) * gas_prices[current_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume + gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]",
      "mutated_line": "count += required_gas_volume * gas_tank_volume * gas_prices[current_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += required_gas_volume * gas_tank_volume * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[+1] <= farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[+1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])",
      "mutated_line": "next_point = cheaper_reachable_points[1] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[1] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])",
      "mutated_line": "next_point = cheaper_reachable_points[-1] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[-1] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])",
      "mutated_line": "next_point = cheaper_reachable_points[1] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[1] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point >= d and (current_point != start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point != start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] > gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] > gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] < gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] < gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):",
      "mutated_line": "if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] == gas_prices[current_point]):",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] == gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -2\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -0\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -0\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return --1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[-2] <= farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-2] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[-0] <= farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-0] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[-0] <= farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-0] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while points and points[-1] <= farthest_reachable_point:",
      "mutated_line": "while points and points[--1] <= farthest_reachable_point:",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[--1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))",
      "mutated_line": "cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] <= gas_prices[current_point], reachable_points))",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] <= gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))",
      "mutated_line": "cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] >= gas_prices[current_point], reachable_points))",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] >= gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))",
      "mutated_line": "cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] != gas_prices[current_point], reachable_points))",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] != gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point > next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "reachable_points = [point for point in reachable_points if point > next_point]",
      "mutated_line": "reachable_points = [point for point in reachable_points if point >= next_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point >= next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "reachable_points = [point for point in reachable_points if point > next_point]",
      "mutated_line": "reachable_points = [point for point in reachable_points if point <= next_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point <= next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "reachable_points = [point for point in reachable_points if point > next_point]",
      "mutated_line": "reachable_points = [point for point in reachable_points if point != next_point]",
      "code": "def calculate_min_fuel_cost(d, n, m, gas_stations):\n    start_point = 0\n    gas_prices = {start_point: 0}\n    for (xi, pi) in gas_stations:\n        gas_prices[xi] = pi\n    points = sorted(gas_prices.keys(), reverse=True)\n    current_point = start_point\n    count = 0\n    gas_tank_volume = n\n    reachable_points = []\n    while current_point != d:\n        farthest_reachable_point = current_point + gas_tank_volume\n        while points and points[-1] <= farthest_reachable_point:\n            reachable_points.append(points.pop())\n        if reachable_points:\n            cheaper_reachable_points = sorted(filter(lambda point: gas_prices[point] < gas_prices[current_point], reachable_points))\n            next_point = cheaper_reachable_points[0] if cheaper_reachable_points else min(reachable_points, key=lambda point: gas_prices[point])\n            if farthest_reachable_point >= d and (current_point == start_point or gas_prices[next_point] >= gas_prices[current_point]):\n                next_point = d\n            else:\n                reachable_points = [point for point in reachable_points if point != next_point]\n        elif farthest_reachable_point >= d:\n            next_point = d\n        else:\n            return -1\n        distance = next_point - current_point\n        if next_point != d and gas_prices[current_point] <= gas_prices[next_point]:\n            required_gas_volume = n\n        else:\n            required_gas_volume = distance\n        if required_gas_volume > gas_tank_volume:\n            count += (required_gas_volume - gas_tank_volume) * gas_prices[current_point]\n            gas_tank_volume = required_gas_volume\n        current_point = next_point\n        gas_tank_volume -= distance\n    return count"
    }
  ]
}