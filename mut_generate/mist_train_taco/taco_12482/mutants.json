{
  "task_id": "taco_12482",
  "entry_point": "calculate_minimum_slowness",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 * 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 * 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 + 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 + 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] / (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] / (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] + (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] + (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] ** (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] ** (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] / (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] / (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] + (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] + (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] ** (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] ** (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 1\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = -1",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = -1\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 1\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 11 ** 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 11 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 9 ** 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 9 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 0 ** 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 0 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 1 ** 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 1 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = -10 ** 9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = -10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 10",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 10\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 8",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 8\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 0",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 0\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 1",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 1\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** -9",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** -9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "count = [[0] * m for _ in range(m)]",
      "mutated_line": "count = [[0] / m for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] / m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "count = [[0] * m for _ in range(m)]",
      "mutated_line": "count = [[0] + m for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] + m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "count = [[0] * m for _ in range(m)]",
      "mutated_line": "count = [[0] ** m for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] ** m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ord_a = ord('a')",
      "mutated_line": "ord_a = ord('')",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c1 = ord(c1) - ord_a",
      "mutated_line": "c1 = ord(c1) + ord_a",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) + ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c1 = ord(c1) - ord_a",
      "mutated_line": "c1 = ord(c1) * ord_a",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) * ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "c2 = ord(c2) - ord_a",
      "mutated_line": "c2 = ord(c2) + ord_a",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) + ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "c2 = ord(c2) - ord_a",
      "mutated_line": "c2 = ord(c2) * ord_a",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) * ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if c1 != c2:",
      "mutated_line": "if c1 == c2:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 == c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "count[c1][c2] += 1",
      "mutated_line": "count[c1][c2] -= 1",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] -= 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] / (1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] / (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] + (1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] + (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] ** (1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] ** (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "total_adj = adj_in_subset[-1]",
      "mutated_line": "total_adj = adj_in_subset[+1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[+1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[1] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[-1] = 0",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[-1] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[1] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "return dp[-1]",
      "mutated_line": "return dp[+1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[+1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count[c1][c2] += 1",
      "mutated_line": "count[c1][c2] += 2",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 2\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count[c1][c2] += 1",
      "mutated_line": "count[c1][c2] += 0",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 0\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count[c1][c2] += 1",
      "mutated_line": "count[c1][c2] += 0",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 0\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count[c1][c2] += 1",
      "mutated_line": "count[c1][c2] += -1",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += -1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j == 0:",
      "mutated_line": "if j != 0:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j != 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "lsb = j & -j",
      "mutated_line": "lsb = j | -j",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j | -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] - count[i][lsb.bit_length() - 1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] - count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] * count[i][lsb.bit_length() - 1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] * count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [1] * (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [1] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [-1] * (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [-1] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [1] * (1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [1] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] * (2 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (2 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] * (0 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (0 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] * (0 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (0 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "adj_in_subset = [0] * (1 << m)",
      "mutated_line": "adj_in_subset = [0] * (-1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (-1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(2 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(2 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(0 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(0 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(0 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(0 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(-1 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(-1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i | 1 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i | 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "adj_in_subset[i] += sum_of_subset[j][i]",
      "mutated_line": "adj_in_subset[i] -= sum_of_subset[j][i]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] -= sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_adj = adj_in_subset[-1]",
      "mutated_line": "total_adj = adj_in_subset[-2]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-2]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_adj = adj_in_subset[-1]",
      "mutated_line": "total_adj = adj_in_subset[-0]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-0]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_adj = adj_in_subset[-1]",
      "mutated_line": "total_adj = adj_in_subset[-0]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-0]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "total_adj = adj_in_subset[-1]",
      "mutated_line": "total_adj = adj_in_subset[--1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[--1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] * (2 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (2 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] * (0 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (0 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] * (0 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (0 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp = [INF] * (1 << m)",
      "mutated_line": "dp = [INF] * (-1 << m)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (-1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(2 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(2 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(0 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(0 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(0 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(0 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1 << m):",
      "mutated_line": "for i in range(-1 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(-1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i | 1 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i | 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]",
      "mutated_line": "cost = total_adj - adj_in_subset[i] + adj_in_subset[~i]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] + adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]",
      "mutated_line": "cost = (total_adj - adj_in_subset[i]) * adj_in_subset[~i]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = (total_adj - adj_in_subset[i]) * adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[-1]",
      "mutated_line": "return dp[-2]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-2]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[-1]",
      "mutated_line": "return dp[-0]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[-1]",
      "mutated_line": "return dp[-0]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[-1]",
      "mutated_line": "return dp[--1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[--1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "count = [[0] * m for _ in range(m)]",
      "mutated_line": "count = [[1] * m for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[1] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "count = [[0] * m for _ in range(m)]",
      "mutated_line": "count = [[-1] * m for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[-1] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "count = [[0] * m for _ in range(m)]",
      "mutated_line": "count = [[1] * m for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[1] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (c1, c2) in zip(s, s[1:]):",
      "mutated_line": "for (c1, c2) in zip(s, s[2:]):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[2:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (c1, c2) in zip(s, s[1:]):",
      "mutated_line": "for (c1, c2) in zip(s, s[0:]):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[0:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (c1, c2) in zip(s, s[1:]):",
      "mutated_line": "for (c1, c2) in zip(s, s[0:]):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[0:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (c1, c2) in zip(s, s[1:]):",
      "mutated_line": "for (c1, c2) in zip(s, s[-1:]):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[-1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[1] * (1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[1] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[-1] * (1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[-1] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[1] * (1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[1] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] * (2 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (2 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] * (0 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (0 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] * (0 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (0 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sum_of_subset = [[0] * (1 << m) for _ in range(m)]",
      "mutated_line": "sum_of_subset = [[0] * (-1 << m) for _ in range(m)]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (-1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1 << m):",
      "mutated_line": "for j in range(2 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(2 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1 << m):",
      "mutated_line": "for j in range(0 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(0 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1 << m):",
      "mutated_line": "for j in range(0 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(0 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(1 << m):",
      "mutated_line": "for j in range(-1 << m):",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(-1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j == 0:",
      "mutated_line": "if j == 1:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 1:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j == 0:",
      "mutated_line": "if j == -1:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == -1:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j == 0:",
      "mutated_line": "if j == 1:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 1:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "lsb = j & -j",
      "mutated_line": "lsb = j & +j",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & +j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]",
      "mutated_line": "cost = total_adj + adj_in_subset[i] - adj_in_subset[~i]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj + adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]",
      "mutated_line": "cost = total_adj * adj_in_subset[i] - adj_in_subset[~i]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj * adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i & 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i & 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i ^ 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i ^ 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] - cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] - cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] * cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] * cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j | lsb] + count[i][lsb.bit_length() - 1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j | lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() + 1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() + 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() * 1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() * 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 2 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 2 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 0 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 0 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & -1 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & -1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 2 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 2 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 0 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & 0 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 0 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if i & 1 << j:",
      "mutated_line": "if i & -1 << j:",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & -1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i & 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i & 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i ^ 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i ^ 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 2]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 2]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 0]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 0]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 0]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 0]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]",
      "mutated_line": "sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - -1]",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - -1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 2 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 2 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 0 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 0 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 0 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 0 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | -1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | -1 << j] = min(dp[i | 1 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i | 2 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 2 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i | 0 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 0 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i | 0 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | 0 << j], dp[i] + cost)\n    return dp[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[i | 1 << j] = min(dp[i | 1 << j], dp[i] + cost)",
      "mutated_line": "dp[i | 1 << j] = min(dp[i | -1 << j], dp[i] + cost)",
      "code": "def calculate_minimum_slowness(n, m, s):\n    INF = 10 ** 9\n    count = [[0] * m for _ in range(m)]\n    ord_a = ord('a')\n    for (c1, c2) in zip(s, s[1:]):\n        c1 = ord(c1) - ord_a\n        c2 = ord(c2) - ord_a\n        if c1 != c2:\n            count[c1][c2] += 1\n    sum_of_subset = [[0] * (1 << m) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << m):\n            if j == 0:\n                continue\n            lsb = j & -j\n            sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]\n    adj_in_subset = [0] * (1 << m)\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                adj_in_subset[i] += sum_of_subset[j][i]\n    total_adj = adj_in_subset[-1]\n    dp = [INF] * (1 << m)\n    dp[0] = 0\n    for i in range(1 << m):\n        for j in range(m):\n            if i & 1 << j:\n                continue\n            cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]\n            dp[i | 1 << j] = min(dp[i | -1 << j], dp[i] + cost)\n    return dp[-1]"
    }
  ]
}