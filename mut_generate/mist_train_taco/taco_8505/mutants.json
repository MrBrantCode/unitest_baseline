{
  "task_id": "taco_8505",
  "entry_point": "calculate_left_polygon_area",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag + a.imag * b.real",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag + a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag * (a.imag * b.real)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag * (a.imag * b.real)\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "vec = d - c",
      "mutated_line": "vec = d + c",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d + c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "vec = d - c",
      "mutated_line": "vec = d * c",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d * c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c - v2 / v1 * vec",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c - v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c * (v2 / v1 * vec)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c * (v2 / v1 * vec)\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "lv = lt - ls",
      "mutated_line": "lv = lt + ls",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt + ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "lv = lt - ls",
      "mutated_line": "lv = lt * ls",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt * ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "area = 0.0",
      "mutated_line": "area = 1.0",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 1.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "area = 0.0",
      "mutated_line": "area = -1.0",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = -1.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "area = 0.0",
      "mutated_line": "area = 1",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 1\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 0 < cross(lv, prev - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 < cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 0 > cross(lv, prev - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 > cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 0 == cross(lv, prev - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 == cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if cp1 is not None and cp2 is not None:",
      "mutated_line": "if cp1 is not None or cp2 is not None:",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None or cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "area += cross(cp1, cp2)",
      "mutated_line": "area -= cross(cp1, cp2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area -= cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real / b.imag - a.imag * b.real",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real / b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real + b.imag - a.imag * b.real",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real + b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real ** b.imag - a.imag * b.real",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real ** b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - a.imag / b.real",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag / b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - (a.imag + b.real)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - (a.imag + b.real)\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return a.real * b.imag - a.imag * b.real",
      "mutated_line": "return a.real * b.imag - a.imag ** b.real",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag ** b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "v2 = cross(lv, lt - c)",
      "mutated_line": "v2 = cross(lv, lt + c)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt + c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "v2 = cross(lv, lt - c)",
      "mutated_line": "v2 = cross(lv, lt * c)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt * c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c + v2 / v1 / vec",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 / vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c + (v2 / v1 + vec)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + (v2 / v1 + vec)\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c + (v2 / v1) ** vec",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + (v2 / v1) ** vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 - 1j * y1, x2 + 1j * y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 - 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 * (1j * y1), x2 + 1j * y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 * (1j * y1), x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j * y1, x2 - 1j * y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 - 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j * y1, x2 * (1j * y2))",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 * (1j * y2))\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "prev = polygon_points[-1]",
      "mutated_line": "prev = polygon_points[+1]",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[+1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 1 <= cross(lv, prev - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 1 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = -1 <= cross(lv, prev - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = -1 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 1 <= cross(lv, prev - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 1 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 0 < cross(lv, p - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 < cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 0 > cross(lv, p - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 > cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 0 == cross(lv, p - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 == cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if prev_flag and curr_flag:",
      "mutated_line": "if prev_flag or curr_flag:",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag or curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "area += cross(prev, p)",
      "mutated_line": "area -= cross(prev, p)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area -= cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if cp1 is not None and cp2 is not None:",
      "mutated_line": "if cp1 is None and cp2 is not None:",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if cp1 is not None and cp2 is not None:",
      "mutated_line": "if cp1 is not None and cp2 is None:",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area * 2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area * 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area // 2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area // 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c + v2 * v1 * vec",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 * v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return c + v2 / v1 * vec",
      "mutated_line": "return c + v2 // v1 * vec",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 // v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j / y1, x2 + 1j * y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j / y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + (1j + y1), x2 + 1j * y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + (1j + y1), x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j ** y1, x2 + 1j * y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j ** y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j / y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j / y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j * y1, x2 + (1j + y2))",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + (1j + y2))\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)",
      "mutated_line": "(ls, lt) = (x1 + 1j * y1, x2 + 1j ** y2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j ** y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev = polygon_points[-1]",
      "mutated_line": "prev = polygon_points[-2]",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-2]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev = polygon_points[-1]",
      "mutated_line": "prev = polygon_points[-0]",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-0]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev = polygon_points[-1]",
      "mutated_line": "prev = polygon_points[-0]",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-0]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prev = polygon_points[-1]",
      "mutated_line": "prev = polygon_points[--1]",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[--1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 0 <= cross(lv, prev + ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev + ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "prev_flag = 0 <= cross(lv, prev - ls)",
      "mutated_line": "prev_flag = 0 <= cross(lv, prev * ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev * ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 1 <= cross(lv, p - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 1 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = -1 <= cross(lv, p - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = -1 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 1 <= cross(lv, p - ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 1 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif prev_flag != curr_flag:",
      "mutated_line": "elif prev_flag == curr_flag:",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag == curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area / 3)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 3)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area / 1)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area / 0)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area / 1)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "results.append(area / 2)",
      "mutated_line": "results.append(area / -2)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / -2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 0 <= cross(lv, p + ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p + ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "curr_flag = 0 <= cross(lv, p - ls)",
      "mutated_line": "curr_flag = 0 <= cross(lv, p * ls)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p * ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "area += cross(prev, cp)",
      "mutated_line": "area -= cross(prev, cp)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area -= cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area += cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "area += cross(cp, p)",
      "mutated_line": "area -= cross(cp, p)",
      "code": "def calculate_left_polygon_area(polygon_points: list, queries: list) -> list:\n\n    def cross(a: complex, b: complex) -> float:\n        return a.real * b.imag - a.imag * b.real\n\n    def cross_point(c: complex, d: complex) -> complex:\n        nonlocal lt, lv\n        vec = d - c\n        v1 = cross(lv, vec)\n        v2 = cross(lv, lt - c)\n        return c + v2 / v1 * vec\n    results = []\n    for query in queries:\n        (x1, y1, x2, y2) = query\n        (ls, lt) = (x1 + 1j * y1, x2 + 1j * y2)\n        lv = lt - ls\n        area = 0.0\n        prev = polygon_points[-1]\n        prev_flag = 0 <= cross(lv, prev - ls)\n        (cp1, cp2) = (None, None)\n        for p in polygon_points:\n            curr_flag = 0 <= cross(lv, p - ls)\n            if prev_flag and curr_flag:\n                area += cross(prev, p)\n            elif prev_flag != curr_flag:\n                cp = cross_point(prev, p)\n                if prev_flag:\n                    area += cross(prev, cp)\n                    cp1 = cp\n                else:\n                    area -= cross(cp, p)\n                    cp2 = cp\n            (prev, prev_flag) = (p, curr_flag)\n        if cp1 is not None and cp2 is not None:\n            area += cross(cp1, cp2)\n        results.append(area / 2)\n    return results"
    }
  ]
}