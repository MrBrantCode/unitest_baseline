{
  "task_id": "taco_14295",
  "entry_point": "calculate_minimum_detection_radius",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if ds >= city1_r + city2_r:",
      "mutated_line": "if ds > city1_r + city2_r:",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds > city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if ds >= city1_r + city2_r:",
      "mutated_line": "if ds < city1_r + city2_r:",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds < city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if ds >= city1_r + city2_r:",
      "mutated_line": "if ds == city1_r + city2_r:",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds == city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 - (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 - (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 * (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 * (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if ds >= city1_r + city2_r:",
      "mutated_line": "if ds >= city1_r - city2_r:",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r - city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if ds >= city1_r + city2_r:",
      "mutated_line": "if ds >= city1_r * city2_r:",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r * city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) * 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) * 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) // 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) // 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif ds <= abs(city1_r - city2_r):",
      "mutated_line": "elif ds < abs(city1_r - city2_r):",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds < abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif ds <= abs(city1_r - city2_r):",
      "mutated_line": "elif ds > abs(city1_r - city2_r):",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds > abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif ds <= abs(city1_r - city2_r):",
      "mutated_line": "elif ds == abs(city1_r - city2_r):",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds == abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) * 2 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) * 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt(city1_x - city2_x + 2 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt(city1_x - city2_x + 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) * 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) * 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y + 2))",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y + 2))\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r + city2_r) / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r + city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r) * city2_r / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r) * city2_r / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) / 3",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 3\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) / 1",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 1\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) / 0",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 0\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) / 1",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 1\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds - city1_r - city2_r) / -2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / -2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) * 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) * 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) // 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) // 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0.0",
      "mutated_line": "return 1.0",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 1.0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0.0",
      "mutated_line": "return -1.0",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0.0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x + city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x + city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x * city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x * city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 3 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 3 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 1 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 1 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 0 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 0 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 1 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 1 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** -2 + (city1_y - city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** -2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y + city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y + city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y * city2_y) ** 2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y * city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 3)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 3)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 1)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 1)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 0)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 0)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 1)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 1)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)",
      "mutated_line": "ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** -2)",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** -2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds + city1_r - city2_r) / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds + city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return (ds - city1_r - city2_r) / 2",
      "mutated_line": "return (ds * city1_r - city2_r) / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds * city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "elif ds <= abs(city1_r - city2_r):",
      "mutated_line": "elif ds <= abs(city1_r + city2_r):",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r + city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "elif ds <= abs(city1_r - city2_r):",
      "mutated_line": "elif ds <= abs(city1_r * city2_r):",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r * city2_r):\n        return (abs(city1_r - city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) + ds) / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) + ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return abs(city1_r - city2_r) * ds / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return abs(city1_r - city2_r) * ds / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) / 3",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 3\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) / 1",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 1\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) / 0",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 0\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) / 1",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / 1\n    else:\n        return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r - city2_r) - ds) / -2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r - city2_r) - ds) / -2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r + city2_r) - ds) / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r + city2_r) - ds) / 2\n    else:\n        return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (abs(city1_r - city2_r) - ds) / 2",
      "mutated_line": "return (abs(city1_r * city2_r) - ds) / 2",
      "code": "import math\n\ndef calculate_minimum_detection_radius(city1_x, city1_y, city1_r, city2_x, city2_y, city2_r):\n    ds = math.sqrt((city1_x - city2_x) ** 2 + (city1_y - city2_y) ** 2)\n    if ds >= city1_r + city2_r:\n        return (ds - city1_r - city2_r) / 2\n    elif ds <= abs(city1_r - city2_r):\n        return (abs(city1_r * city2_r) - ds) / 2\n    else:\n        return 0.0"
    }
  ]
}