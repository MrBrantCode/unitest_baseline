{
  "task_id": "taco_1598",
  "entry_point": "solve_lanterns",
  "mutant_count": 225,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if l > r:",
      "mutated_line": "if l >= r:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l >= r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if l > r:",
      "mutated_line": "if l <= r:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l <= r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if l > r:",
      "mutated_line": "if l != r:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l != r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 - l).bit_length() + 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() + 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 - l).bit_length() * 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() * 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = [0] + p  # Adjusting p to be 1-indexed",
      "mutated_line": "p = [0] - p",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] - p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p = [0] + p  # Adjusting p to be 1-indexed",
      "mutated_line": "p = [0] * p",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] * p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] / (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] / (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] + (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] + (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] ** (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] ** (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] / (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] / (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] + (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] + (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] ** (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] ** (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[-1] <= n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] <= n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[-1] >= n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] >= n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[-1] != n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] != n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.st = [[0] * mx for i in range(n)]",
      "mutated_line": "self.st = [[0] / mx for i in range(n)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] / mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.st = [[0] * mx for i in range(n)]",
      "mutated_line": "self.st = [[0] + mx for i in range(n)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] + mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.st = [[0] * mx for i in range(n)]",
      "mutated_line": "self.st = [[0] ** mx for i in range(n)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] ** mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(1, mx):",
      "mutated_line": "for j in range(2, mx):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(2, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(1, mx):",
      "mutated_line": "for j in range(0, mx):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(0, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(1, mx):",
      "mutated_line": "for j in range(0, mx):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(0, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(1, mx):",
      "mutated_line": "for j in range(-1, mx):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(-1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -inf",
      "mutated_line": "return +inf",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return +inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 - l).bit_length() - 2",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 2\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 - l).bit_length() - 0",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 0\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 - l).bit_length() - 0",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 0\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 - l).bit_length() - -1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - -1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i - p[i] for i in range(n + 1)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i - p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i * p[i] for i in range(n + 1)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i * p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n - 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n * 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n * 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] * (n - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n - 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] * (n * 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n * 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(3, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(0, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(-2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n - 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n * 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if j == i:",
      "mutated_line": "if j != i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j != i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = ['R'] * n",
      "mutated_line": "ans = ['R'] / n",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] / n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = ['R'] * n",
      "mutated_line": "ans = ['R'] + n",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] + n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans = ['R'] * n",
      "mutated_line": "ans = ['R'] ** n",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] ** n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.st[i][0] = arr[i]",
      "mutated_line": "self.st[i][1] = arr[i]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][1] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.st[i][0] = arr[i]",
      "mutated_line": "self.st[i][-1] = arr[i]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][-1] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "self.st[i][0] = arr[i]",
      "mutated_line": "self.st[i][1] = arr[i]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][1] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (1 << j) - 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) - 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range((n - (1 << j)) * 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range((n - (1 << j)) * 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p = [0] + p  # Adjusting p to be 1-indexed",
      "mutated_line": "p = [1] + p",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [1] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p = [0] + p  # Adjusting p to be 1-indexed",
      "mutated_line": "p = [-1] + p",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [-1] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p = [0] + p  # Adjusting p to be 1-indexed",
      "mutated_line": "p = [1] + p",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [1] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [1] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [-1] * (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [-1] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [1] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 2)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 2)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 0)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 0)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + -1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + -1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [1] * (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [1] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [-1] * (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [-1] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [1] * (n + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [1] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] * (n + 2)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 2)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] * (n + 0)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 0)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] * (n + 0)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 0)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "last = [0] * (n + 1)",
      "mutated_line": "last = [0] * (n + -1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + -1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 2):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 0):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 0):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + -1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] + 1, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] + 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, (i - p[i]) * 1, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, (i - p[i]) * 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - 1, 1, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 1, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - 1, -1, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, -1, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - 1, 1, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 1, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - 1] > i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] > i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - 1] < i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] < i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - 1] == i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] == i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[+1] < n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[+1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if last[cur] != cur:",
      "mutated_line": "if last[cur] == cur:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] == cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "cur -= 1",
      "mutated_line": "cur += 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur += 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.st = [[0] * mx for i in range(n)]",
      "mutated_line": "self.st = [[1] * mx for i in range(n)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[1] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.st = [[0] * mx for i in range(n)]",
      "mutated_line": "self.st = [[-1] * mx for i in range(n)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[-1] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.st = [[0] * mx for i in range(n)]",
      "mutated_line": "self.st = [[1] * mx for i in range(n)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[1] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n + (1 << j) + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n + (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n * (1 << j) + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n * (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (1 << j) + 2):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 2):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (1 << j) + 0):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 0):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (1 << j) + 0):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 0):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (1 << j) + -1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + -1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 1 + l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 + l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = ((r + 1) * l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = ((r + 1) * l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (1 << s) - 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) - 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[(r - (1 << s)) * 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[(r - (1 << s)) * 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i + p[i] for i in range(n - 1)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n - 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i + p[i] for i in range(n * 1)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n * 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i + 1]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i + 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i * 1]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i * 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i + p[i] - 1, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i + p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i * p[i] - 1, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i * p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - 2, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 2, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - 0, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 0, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - 0, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 0, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "j = bisect_left(dp, i - p[i] - 1, 0, i)",
      "mutated_line": "j = bisect_left(dp, i - p[i] - -1, 0, i)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - -1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i + 1]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i + 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i * 1]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i * 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i + 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i + 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i * 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i * 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] <= max(dp[i - 1], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] <= max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] >= max(dp[i - 1], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] >= max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] != max(dp[i - 1], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] != max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[-2] < n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-2] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[-0] < n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-0] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[-0] < n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-0] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if dp[-1] < n:",
      "mutated_line": "if dp[--1] < n:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[--1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "results.append(('NO', None))",
      "mutated_line": "results.append(('', None))",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans = ['R'] * n",
      "mutated_line": "ans = [''] * n",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = [''] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur - 1] = ''",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = ''\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= 2",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 2\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= 0",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 0\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= 0",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 0\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "cur -= 1",
      "mutated_line": "cur -= -1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= -1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "results.append(('YES', ''.join(ans)))",
      "mutated_line": "results.append(('', ''.join(ans)))",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j + 1], self.st[i + (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j + 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j * 1], self.st[i + (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j * 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j + 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j + 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j * 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j * 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r - 1 - l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r - 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r * 1 - l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r * 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r + (1 << s) + 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r + (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r * (1 << s) + 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r * (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (1 << s) + 2][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 2][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (1 << s) + 0][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 0][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (1 << s) + 0][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 0][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (1 << s) + -1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + -1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i + p[i] for i in range(n + 2)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 2)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i + p[i] for i in range(n + 0)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 0)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i + p[i] for i in range(n + 0)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 0)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a = [i + p[i] for i in range(n + 1)]",
      "mutated_line": "a = [i + p[i] for i in range(n + -1)]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + -1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - 2]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 2]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - 0]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 0]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - 0]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 0]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - -1]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - -1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - 2]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 2]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - 0]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 0]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - 0]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 0]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[i] = dp[i - 1]",
      "mutated_line": "dp[i] = dp[i - -1]",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - -1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j - 1, i - 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j - 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j * 1, i - 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j * 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i + 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i + 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i * 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i * 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 2)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 2)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 0)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 0)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 0)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 0)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - -1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - -1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i + 1] >= i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i + 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i * 1] >= i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i * 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur + 1] = 'L'",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur + 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur * 1] = 'L'",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur * 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (2 << j) + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (2 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (0 << j) + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (0 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (0 << j) + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (0 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(n - (1 << j) + 1):",
      "mutated_line": "for i in range(n - (-1 << j) + 1):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (-1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 2], self.st[i + (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 2], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 0], self.st[i + (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 0], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 0], self.st[i + (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 0], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - -1], self.st[i + (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - -1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i - (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i - (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i * (1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i * (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 2])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 2])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 0])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 0])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 0])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 0])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - -1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - -1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 2 - l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 2 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 0 - l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 0 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + 0 - l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 0 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = (r + 1 - l).bit_length() - 1",
      "mutated_line": "s = (r + -1 - l).bit_length() - 1",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + -1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 2, i - 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 2, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 0, i - 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 0, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 0, i - 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 0, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + -1, i - 1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + -1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 2), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 2), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 0), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 0), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - 0), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 0), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)",
      "mutated_line": "dp[i] = max(dp[j], st.query(j + 1, i - -1), i - 1)",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - -1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - 2] >= i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 2] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - 0] >= i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 0] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - 0] >= i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 0] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if dp[i - 1] >= i:",
      "mutated_line": "if dp[i - -1] >= i:",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - -1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i - 1], i - p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i - p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i - 1], i * p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i * p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i - 1], i - p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i - p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i - 1], i * p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i * p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur - 2] = 'L'",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 2] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur - 0] = 'L'",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 0] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur - 0] = 'L'",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 0] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans[cur - 1] = 'L'",
      "mutated_line": "ans[cur - -1] = 'L'",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - -1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "results.append(('YES', ''.join(ans)))",
      "mutated_line": "results.append(('YES', 'MUTATED'.join(ans)))",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', 'MUTATED'.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (2 << s) + 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (2 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (0 << s) + 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (0 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (0 << s) + 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (0 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return max(self.st[l][s], self.st[r - (1 << s) + 1][s])",
      "mutated_line": "return max(self.st[l][s], self.st[r - (-1 << s) + 1][s])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (-1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i + 1], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i + 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i * 1], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i * 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i + 1], i + p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i + 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i * 1], i + p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i * 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (2 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (2 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (0 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (0 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (0 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (0 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (-1 << j - 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (-1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j + 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j + 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j * 1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j * 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i - 2], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 2], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i - 0], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 0], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i - 0], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 0], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dp[i] < max(dp[i - 1], i + p[i]):",
      "mutated_line": "if dp[i] < max(dp[i - -1], i + p[i]):",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - -1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i - 2], i + p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 2], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i - 0], i + p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 0], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i - 0], i + p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 0], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[i] = max(dp[i - 1], i + p[i])",
      "mutated_line": "dp[i] = max(dp[i - -1], i + p[i])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - -1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 2)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 2)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 0)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 0)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 0)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 0)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - 1)][j - 1])",
      "mutated_line": "self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - -1)][j - 1])",
      "code": "from bisect import bisect_left\nfrom math import inf\n\nclass ST:\n\n    def __init__(self, arr):\n        n = len(arr)\n        mx = n.bit_length()\n        self.st = [[0] * mx for i in range(n)]\n        for i in range(n):\n            self.st[i][0] = arr[i]\n        for j in range(1, mx):\n            for i in range(n - (1 << j) + 1):\n                self.st[i][j] = max(self.st[i][j - 1], self.st[i + (1 << j - -1)][j - 1])\n\n    def query(self, l, r):\n        if l > r:\n            return -inf\n        s = (r + 1 - l).bit_length() - 1\n        return max(self.st[l][s], self.st[r - (1 << s) + 1][s])\n\ndef solve_lanterns(t, test_cases):\n    results = []\n    for case in test_cases:\n        (n, p) = case\n        p = [0] + p\n        a = [i + p[i] for i in range(n + 1)]\n        st = ST(a)\n        dp = [0] * (n + 1)\n        last = [0] * (n + 1)\n        for i in range(2, n + 1):\n            if not p[i]:\n                dp[i] = dp[i - 1]\n                last[i] = i\n                continue\n            j = bisect_left(dp, i - p[i] - 1, 0, i)\n            last[i] = j\n            if j == i:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = max(dp[j], st.query(j + 1, i - 1), i - 1)\n                if dp[i - 1] >= i:\n                    if dp[i] < max(dp[i - 1], i + p[i]):\n                        dp[i] = max(dp[i - 1], i + p[i])\n                        last[i] = i\n        if dp[-1] < n:\n            results.append(('NO', None))\n        else:\n            cur = n\n            ans = ['R'] * n\n            while cur:\n                if last[cur] != cur:\n                    ans[cur - 1] = 'L'\n                    cur = last[cur]\n                else:\n                    cur -= 1\n            results.append(('YES', ''.join(ans)))\n    return results"
    }
  ]
}