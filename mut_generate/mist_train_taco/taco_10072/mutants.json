{
  "task_id": "taco_10072",
  "entry_point": "calculate_tracks_before_turn_off",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = 1",
      "mutated_line": "l = 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 2\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = 1",
      "mutated_line": "l = 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 0\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = 1",
      "mutated_line": "l = 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 0\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "l = 1",
      "mutated_line": "l = -1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = -1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [0] / n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] / n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [0] + n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] + n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [0] ** n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] ** n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi = 0",
      "mutated_line": "pi = 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 1\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi = 0",
      "mutated_line": "pi = -1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = -1\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "pi = 0",
      "mutated_line": "pi = 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 1\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + 1 <= r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 <= r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + 1 >= r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 >= r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + 1 != r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 != r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 - 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 - 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 * 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 * 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [+1, 0]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [+1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [-1, 1]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 1]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [-1, -1]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, -1]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [-1, 1]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 1]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for (i, a) in enumerate(coolness + coolness):",
      "mutated_line": "for (i, a) in enumerate(coolness - coolness):",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness - coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for (i, a) in enumerate(coolness + coolness):",
      "mutated_line": "for (i, a) in enumerate(coolness * coolness):",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness * coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 2 <= stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 <= stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 2 >= stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 >= stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 2 != stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 != stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[-1] < a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] < a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[-1] > a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] > a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[-1] == a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] == a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [-1] / n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] / n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [-1] + n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] + n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [-1] ** n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] ** n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res[i] = nt - i",
      "mutated_line": "res[i] = nt + i",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt + i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res[i] = nt - i",
      "mutated_line": "res[i] = nt * i",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt * i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if i == ns:",
      "mutated_line": "if i != ns:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i != ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "pi += 1",
      "mutated_line": "pi -= 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi -= 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l - 1 < r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l - 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l * 1 < r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l * 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) / 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) * 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if a[m] <= v:",
      "mutated_line": "if a[m] < v:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] < v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if a[m] <= v:",
      "mutated_line": "if a[m] > v:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] > v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if a[m] <= v:",
      "mutated_line": "if a[m] == v:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] == v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "max2 = lambda x, y: x if x > y else y",
      "mutated_line": "max2 = lambda x, y: x if x >= y else y",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x >= y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "max2 = lambda x, y: x if x > y else y",
      "mutated_line": "max2 = lambda x, y: x if x <= y else y",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x <= y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "max2 = lambda x, y: x if x > y else y",
      "mutated_line": "max2 = lambda x, y: x if x != y else y",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x != y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "min2 = lambda x, y: x if x < y else y",
      "mutated_line": "min2 = lambda x, y: x if x <= y else y",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x <= y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "min2 = lambda x, y: x if x < y else y",
      "mutated_line": "min2 = lambda x, y: x if x >= y else y",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x >= y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "min2 = lambda x, y: x if x < y else y",
      "mutated_line": "min2 = lambda x, y: x if x != y else y",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x != y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 * 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 * 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 + 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 + 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + 2, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 2, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + 0, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 0, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + 0, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 0, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + -1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + -1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + 1, coolness[1]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[1]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + 1, coolness[-1]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[-1]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 9 + 1, coolness[1]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[1]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [-2, 0]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-2, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [-0, 0]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-0, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [-0, 0]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-0, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack_ind = [-1, 0]",
      "mutated_line": "stack_ind = [--1, 0]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [--1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a / 2 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a / 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a + 2 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a + 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a ** 2 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a ** 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j >= n:",
      "mutated_line": "if j > n:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j > n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j >= n:",
      "mutated_line": "if j < n:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j < n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j >= n:",
      "mutated_line": "if j == n:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j == n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = k + 1",
      "mutated_line": "l = k - 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k - 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = k + 1",
      "mutated_line": "l = k * 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k * 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l = min2(l, len(stack_ind) - 1)",
      "mutated_line": "l = min2(l, len(stack_ind) + 1)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) + 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l = min2(l, len(stack_ind) - 1)",
      "mutated_line": "l = min2(l, len(stack_ind) * 1)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) * 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] - n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] - n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] * n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] * n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[0][1] - n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] - n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[0][1] * n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] * n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [1] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [1] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [-1] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [-1] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [1] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [1] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pi += 1",
      "mutated_line": "pi += 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 2\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 0\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pi += 1",
      "mutated_line": "pi += 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 0\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "pi += 1",
      "mutated_line": "pi += -1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += -1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + 2 < r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 2 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + 0 < r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 0 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + 0 < r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 0 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while l + 1 < r:",
      "mutated_line": "while l + -1 < r:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + -1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l - r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = l * r // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 3\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 1\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 0\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 1\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // -2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [11 ** 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [11 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [9 ** 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [9 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [0 ** 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [0 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [1 ** 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [1 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [-10 ** 9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [-10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 10 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 10 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 8 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 8 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 0 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 0 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** 1 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 1 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "stack_val = [10 ** 9 + 1, coolness[0]]",
      "mutated_line": "stack_val = [10 ** -9 + 1, coolness[0]]",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** -9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 3 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 3 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 1 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 1 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 0 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 0 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * 1 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 1 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if a * 2 < stack_val[l]:",
      "mutated_line": "if a * -2 < stack_val[l]:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * -2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a / 2, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a / 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a + 2, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a + 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a ** 2, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a ** 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = k + 1",
      "mutated_line": "l = k + 2",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 2\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = k + 1",
      "mutated_line": "l = k + 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 0\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = k + 1",
      "mutated_line": "l = k + 0",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 0\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = k + 1",
      "mutated_line": "l = k + -1",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + -1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[+1] <= a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[+1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = min2(l, len(stack_ind) - 1)",
      "mutated_line": "l = min2(l, len(stack_ind) - 2)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 2)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = min2(l, len(stack_ind) - 1)",
      "mutated_line": "l = min2(l, len(stack_ind) - 0)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 0)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = min2(l, len(stack_ind) - 1)",
      "mutated_line": "l = min2(l, len(stack_ind) - 0)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 0)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l = min2(l, len(stack_ind) - 1)",
      "mutated_line": "l = min2(l, len(stack_ind) - -1)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - -1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [+1] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [+1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a * 3, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 3, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a * 1, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 1, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a * 0, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 0, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a * 1, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 1, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k = bisect_rev(stack_val, a * 2, l)",
      "mutated_line": "k = bisect_rev(stack_val, a * -2, l)",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * -2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[-2] <= a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-2] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[-0] <= a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-0] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[-0] <= a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-0] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while stack_val[-1] <= a:",
      "mutated_line": "while stack_val[--1] <= a:",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[--1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [-2] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-2] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [-0] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-0] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [-0] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-0] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [-1] * n",
      "mutated_line": "return [--1] * n",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [--1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][1] + n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][1] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][-1] + n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][-1] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][1] + n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][1] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[0][2] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][2] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[0][0] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][0] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[0][0] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][0] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[0][-1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[0][-1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[1][0] + n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[1][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[-1][0] + n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[-1][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[1][0] + n, pairs[0][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[1][0] + n, pairs[0][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[1][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[1][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[-1][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[-1][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pairs.append((pairs[0][0] + n, pairs[0][1] + n))",
      "mutated_line": "pairs.append((pairs[0][0] + n, pairs[1][1] + n))",
      "code": "def calculate_tracks_before_turn_off(n, coolness):\n\n    def bisect_rev(a, v, l):\n        r = len(a)\n        while l + 1 < r:\n            m = (l + r) // 2\n            if a[m] <= v:\n                r = m\n            else:\n                l = m\n        return l\n    max2 = lambda x, y: x if x > y else y\n    min2 = lambda x, y: x if x < y else y\n    pairs = []\n    stack_val = [10 ** 9 + 1, coolness[0]]\n    stack_ind = [-1, 0]\n    l = 1\n    for (i, a) in enumerate(coolness + coolness):\n        if a * 2 < stack_val[l]:\n            k = bisect_rev(stack_val, a * 2, l)\n            j = stack_ind[k]\n            if j >= n:\n                break\n            l = k + 1\n            pairs.append((j, i))\n        while stack_val[-1] <= a:\n            stack_val.pop()\n            stack_ind.pop()\n        stack_val.append(a)\n        stack_ind.append(i)\n        l = min2(l, len(stack_ind) - 1)\n    if not pairs:\n        return [-1] * n\n    pairs.append((pairs[0][0] + n, pairs[1][1] + n))\n    res = [0] * n\n    pi = 0\n    (ns, nt) = pairs[pi]\n    for i in range(n):\n        res[i] = nt - i\n        if i == ns:\n            pi += 1\n            (ns, nt) = pairs[pi]\n    return res"
    }
  ]
}