{
  "task_id": "taco_14467",
  "entry_point": "find_kth_smallest_shortest_path",
  "mutant_count": 233,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] - [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] - [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] * [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] * [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "flg = 1",
      "mutated_line": "flg = 2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 2\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "flg = 1",
      "mutated_line": "flg = 0",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 0\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "flg = 1",
      "mutated_line": "flg = 0",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 0\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "flg = 1",
      "mutated_line": "flg = -1",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = -1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "flg = 0",
      "mutated_line": "flg = 1",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 1\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "flg = 0",
      "mutated_line": "flg = -1",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = -1\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "flg = 0",
      "mutated_line": "flg = 1",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 1\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-1][3]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][3]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-1][1]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-1][0]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-1][1]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-1][-2]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][-2]"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[+1][2]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[+1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[1, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[1, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[-1, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[-1, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[1, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[1, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 1, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 1, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, -1, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, -1, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 1, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 1, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 * 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 * 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 + 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 + 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** 6 - y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 - y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** 6 * y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 * y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(shortest_paths)):",
      "mutated_line": "for j in range(i - 1, len(shortest_paths)):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i - 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(shortest_paths)):",
      "mutated_line": "for j in range(i * 1, len(shortest_paths)):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i * 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x1 == x2:",
      "mutated_line": "if x1 != x2:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 != x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-2][2]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-2][2]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-0][2]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-0][2]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[-0][2]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-0][2]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return shortest_paths[-1][2]",
      "mutated_line": "return shortest_paths[--1][2]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[--1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[3])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[1])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[0])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[1])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "edges = sorted(edges, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[-2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 11 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 11 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 9 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 9 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 0 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 0 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 1 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 1 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, -10 ** 20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, -10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 21] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 21] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 19] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 19] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 0] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 0] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** 1] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 1] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "shortest_paths = edges[:k] + [[0, 0, 10**20] for _ in range(k)]",
      "mutated_line": "shortest_paths = edges[:k] + [[0, 0, 10 ** -20] for _ in range(k)]",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** -20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x / 10 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x / 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x + 10 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x + 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x ** 10 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x ** 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(shortest_paths)):",
      "mutated_line": "for j in range(i + 2, len(shortest_paths)):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 2, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(shortest_paths)):",
      "mutated_line": "for j in range(i + 0, len(shortest_paths)):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 0, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(shortest_paths)):",
      "mutated_line": "for j in range(i + 0, len(shortest_paths)):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 0, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for j in range(i + 1, len(shortest_paths)):",
      "mutated_line": "for j in range(i + -1, len(shortest_paths)):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + -1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif y1 == y2:",
      "mutated_line": "elif y1 != y2:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 != y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if (a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b]) and (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if (a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b]) and (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * (10 * 6) + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * (10 * 6) + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * (10 + 6) + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * (10 + 6) + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif x1 == y2:",
      "mutated_line": "elif x1 != y2:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 != y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if (a * 10 ** 6 + b in path_dict or w1 + w2 < path_dict[a * 10 ** 6 + b]) or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if (a * 10 ** 6 + b in path_dict or w1 + w2 < path_dict[a * 10 ** 6 + b]) or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict or w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 6 + b not in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b not in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 6 + b] = w1 - w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 - w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 6 + b] = w1 * w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 * w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "flg = 1",
      "mutated_line": "flg = 2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 2\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "flg = 1",
      "mutated_line": "flg = 0",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 0\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "flg = 1",
      "mutated_line": "flg = 0",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 0\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "flg = 1",
      "mutated_line": "flg = -1",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = -1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 11 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 11 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 9 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 9 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 0 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 0 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 1 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 1 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * -10 ** 6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * -10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** 7 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 7 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** 5 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 5 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** 0 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 0 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** 1 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 1 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "path_dict[x * 10**6 + y] = w",
      "mutated_line": "path_dict[x * 10 ** -6 + y] = w",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** -6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif x2 == y1:",
      "mutated_line": "elif x2 != y1:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 != y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b not in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b not in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 <= path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 <= path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 >= path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 >= path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 != path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 != path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 <= shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 >= shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 != shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 6 - b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 - b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 6 * b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 * b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 6 - b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 - b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 6 * b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 * b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 - b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 - b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 * b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 * b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 - w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 - w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 * w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 * w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 - b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 * b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 - w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 * w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a / 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a / 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a + 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a + 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a ** 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a ** 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] == a or shortest_paths[k][1] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a or shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a / 10 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a / 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a + 10 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a + 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a ** 10 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a ** 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = (0, 0)",
      "mutated_line": "(a, b) = (1, 0)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (1, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = (0, 0)",
      "mutated_line": "(a, b) = (-1, 0)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (-1, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = (0, 0)",
      "mutated_line": "(a, b) = (1, 0)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (1, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = (0, 0)",
      "mutated_line": "(a, b) = (0, 1)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 1)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = (0, 0)",
      "mutated_line": "(a, b) = (0, -1)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, -1)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(a, b) = (0, 0)",
      "mutated_line": "(a, b) = (0, 1)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 1)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a / 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a / 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a + 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a + 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a ** 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a ** 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 - b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 - b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 * b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 * b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a / 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a + 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a ** 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][3]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][1]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][0]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][1]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][-2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * (10 * 6) + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * (10 * 6) + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * (10 + 6) + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * (10 + 6) + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] != a and shortest_paths[k][1] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] != a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] != b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] != b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][2] = w1 - w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 - w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][2] = w1 * w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 * w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** 6 - y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 - y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** 6 * y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 * y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "shortest_paths.append([a, b, w1 + w2])",
      "mutated_line": "shortest_paths.append([a, b, w1 - w2])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 - w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "shortest_paths.append([a, b, w1 + w2])",
      "mutated_line": "shortest_paths.append([a, b, w1 * w2])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 * w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * (10 * 6) + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * (10 * 6) + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * (10 + 6) + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * (10 + 6) + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * (10 * 6) + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * (10 * 6) + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * (10 + 6) + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * (10 + 6) + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a / 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a / 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a + 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a + 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a ** 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a ** 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * (10 * 6) + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * (10 + 6) + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[+1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 11 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 11 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 9 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 9 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 0 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 0 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 1 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 1 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * -10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * -10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 7 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 7 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 5 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 5 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 0 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 0 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** 1 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 1 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a * 10**6 + b in path_dict:",
      "mutated_line": "if a * 10 ** -6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** -6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][3] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][3] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][1] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][1] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][0] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][0] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][1] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][1] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "shortest_paths[k][2] = w1 + w2",
      "mutated_line": "shortest_paths[k][-2] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][-2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x / 10 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x / 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x + 10 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x + 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x ** 10 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x ** 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 11 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 11 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 9 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 9 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 0 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 0 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 1 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 1 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * -10 ** 6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * -10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 7 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 7 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 5 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 5 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 0 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 0 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** 1 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 1 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path_dict[a * 10**6 + b] = w1 + w2",
      "mutated_line": "path_dict[a * 10 ** -6 + b] = w1 + w2",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** -6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[3])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[3])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[1])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[1])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[0])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[0])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[1])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[1])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[2])",
      "mutated_line": "shortest_paths = sorted(shortest_paths, key=lambda x: x[-2])",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[-2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 11 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 11 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 9 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 9 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 0 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 0 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 1 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 1 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * -10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * -10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 7 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 7 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 5 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 5 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 0 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 0 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 1 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 1 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** -6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** -6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * (10 * 6) + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * (10 * 6) + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * (10 + 6) + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * (10 + 6) + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 11 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 9 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 0 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 1 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * -10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 7 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 5 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 0 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 1 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** -6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-2][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-0][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-0][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(a * 10**6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "mutated_line": "if a * 10 ** 6 + b in path_dict:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[--1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][1] == a and shortest_paths[k][1] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][1] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][-1] == a and shortest_paths[k][1] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][-1] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][1] == a and shortest_paths[k][1] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][1] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] == a and shortest_paths[k][2] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][2] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] == a and shortest_paths[k][0] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][0] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] == a and shortest_paths[k][0] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][0] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if shortest_paths[k][0] == a and shortest_paths[k][1] == b:",
      "mutated_line": "if shortest_paths[k][0] == a and shortest_paths[k][-1] == b:",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][-1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * (10 * 6) + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * (10 * 6) + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * (10 + 6) + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * (10 + 6) + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 11 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 11 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 9 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 9 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 0 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 0 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 1 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 1 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * -10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * -10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 7 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 7 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 5 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 5 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 0 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 0 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 1 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 1 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (a * 10**6 + b in path_dict and w1 + w2 < path_dict[a * 10**6 + b]) or \\",
      "mutated_line": "if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** -6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** -6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 11 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 11 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 9 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 9 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 0 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 0 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 1 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 1 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * -10 ** 6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * -10 ** 6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** 7 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 7 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** 5 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 5 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** 0 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 0 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** 1 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** 1 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "path_dict.pop(x * 10**6 + y)",
      "mutated_line": "path_dict.pop(x * 10 ** -6 + y)",
      "code": "def find_kth_smallest_shortest_path(n, m, k, edges):\n    edges = sorted(edges, key=lambda x: x[2])\n    shortest_paths = edges[:k] + [[0, 0, 10 ** 20] for _ in range(k)]\n    path_dict = {}\n    for (x, y, w) in edges:\n        if x:\n            path_dict[x * 10 ** 6 + y] = w\n    flg = 1\n    while flg:\n        flg = 0\n        for i in range(len(shortest_paths)):\n            (x1, y1, w1) = shortest_paths[i]\n            for j in range(i + 1, len(shortest_paths)):\n                (x2, y2, w2) = shortest_paths[j]\n                if x1 == x2:\n                    (a, b) = (min(y1, y2), max(y1, y2))\n                elif y1 == y2:\n                    (a, b) = (min(x1, x2), max(x1, x2))\n                elif x1 == y2:\n                    (a, b) = (x2, y1)\n                elif x2 == y1:\n                    (a, b) = (x1, y2)\n                else:\n                    (a, b) = (0, 0)\n                if a:\n                    if a * 10 ** 6 + b in path_dict and w1 + w2 < path_dict[a * 10 ** 6 + b] or (a * 10 ** 6 + b not in path_dict and w1 + w2 < shortest_paths[-1][2]):\n                        if a * 10 ** 6 + b in path_dict:\n                            for k in range(len(shortest_paths)):\n                                if shortest_paths[k][0] == a and shortest_paths[k][1] == b:\n                                    shortest_paths[k][2] = w1 + w2\n                        else:\n                            (x, y, w) = shortest_paths.pop()\n                            if x:\n                                path_dict.pop(x * 10 ** -6 + y)\n                            shortest_paths.append([a, b, w1 + w2])\n                        path_dict[a * 10 ** 6 + b] = w1 + w2\n                        shortest_paths = sorted(shortest_paths, key=lambda x: x[2])\n                        flg = 1\n                        break\n            if flg:\n                break\n    return shortest_paths[-1][2]"
    }
  ]
}