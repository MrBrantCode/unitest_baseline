{
  "task_id": "taco_14097",
  "entry_point": "inverse",
  "mutant_count": 239,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "import math\nMOD = 10 ** 9 - 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "import math\nMOD = 10 ** 9 * 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "import math\nMOD = 10 * 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "import math\nMOD = 10 + 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "import math\nMOD = 10 ** 9 + 8\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "import math\nMOD = 10 ** 9 + 6\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "import math\nMOD = 10 ** 9 + 0\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "import math\nMOD = 10 ** 9 + 1\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "import math\nMOD = 10 ** 9 + -7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = p * one_hand % MOD",
      "mutated_line": "p = p * one_hand * MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand * MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = p * one_hand % MOD",
      "mutated_line": "p = p * one_hand + MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand + MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) / math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) / math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) * math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) * math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "tx += diffx",
      "mutated_line": "tx -= diffx",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx -= diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ty += diffy",
      "mutated_line": "ty -= diffy",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty -= diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "import math\nMOD = 11 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "import math\nMOD = 9 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "import math\nMOD = 0 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "import math\nMOD = 1 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "import math\nMOD = -10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "import math\nMOD = 10 ** 10 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "import math\nMOD = 10 ** 8 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "import math\nMOD = 10 ** 0 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "import math\nMOD = 10 ** 1 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "import math\nMOD = 10 ** -9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod + 2, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod + 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod * 2, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod * 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "one_hand = inverse(100, MOD)",
      "mutated_line": "one_hand = inverse(101, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(101, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "one_hand = inverse(100, MOD)",
      "mutated_line": "one_hand = inverse(99, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(99, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "one_hand = inverse(100, MOD)",
      "mutated_line": "one_hand = inverse(0, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(0, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "one_hand = inverse(100, MOD)",
      "mutated_line": "one_hand = inverse(1, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(1, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "one_hand = inverse(100, MOD)",
      "mutated_line": "one_hand = inverse(-100, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(-100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = p * one_hand % MOD",
      "mutated_line": "p = p / one_hand % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p / one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = p * one_hand % MOD",
      "mutated_line": "p = (p + one_hand) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = (p + one_hand) % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = p * one_hand % MOD",
      "mutated_line": "p = p ** one_hand % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p ** one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 / (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 / (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = (2 * (n - 1) * 2 + (m - 1)) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = (2 * (n - 1) * 2 + (m - 1)) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = (2 * (n - 1) * 2) ** (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = (2 * (n - 1) * 2) ** (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n == 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n == 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 2 if n != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 2 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 0 if n != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 0 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 0 if n != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 0 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = -1 if n != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = -1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != 1 else 1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 1\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != 1 else -1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else -1\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != 1 else 1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 1\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if tx == r_d:",
      "mutated_line": "if tx != r_d:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx != r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "diffx *= -1",
      "mutated_line": "diffx /= -1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx /= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m == 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m == 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 2 if m != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 2 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 0 if m != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 0 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 0 if m != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 0 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = -1 if m != 1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = -1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != 1 else 1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 1\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != 1 else -1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else -1\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != 1 else 1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 1\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if ty == c_d:",
      "mutated_line": "if ty != c_d:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty != c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "diffy *= -1",
      "mutated_line": "diffy /= -1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy /= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (1, 1)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (1, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (-1, 1)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (-1, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (1, 1)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (1, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (0, 2)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 2)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (0, 0)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 0)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (0, 0)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 0)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "lasta, lastb = 0, 1",
      "mutated_line": "(lasta, lastb) = (0, -1)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, -1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) + 1, -1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) + 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) * 1, -1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) * 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, +1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, +1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -1, +1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, +1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i != len(lis) - 1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i != len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p) * (lasta + kai) * MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) * MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p) * (lasta + kai) + MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) + MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (1 - p) * lastb * MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb * MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (1 - p) * lastb + MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb + MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i != 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 3, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 3, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 1, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 1, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 0, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 0, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - 1, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 1, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return pow(n, mod - 2, mod)",
      "mutated_line": "return pow(n, mod - -2, mod)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - -2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) / 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) / 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = (2 * (n - 1) + 2) * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = (2 * (n - 1) + 2) * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = (2 * (n - 1)) ** 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = (2 * (n - 1)) ** 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m + 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m + 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m * 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m * 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 / (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 / (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 + (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 + (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 ** (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 ** (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 / (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 / (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 + (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 + (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 ** (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 ** (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != 2 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 2 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != 0 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 0 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != 0 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 0 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "diffx = 1 if n != 1 else 0",
      "mutated_line": "diffx = 1 if n != -1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != -1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 1 < tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 < tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 1 > tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 > tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 1 == tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 == tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "diffx *= -1",
      "mutated_line": "diffx *= +1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= +1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != 2 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 2 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != 0 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 0 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != 0 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 0 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "diffy = 1 if m != 1 else 0",
      "mutated_line": "diffy = 1 if m != -1 else 0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != -1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 1 < ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 < ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 1 > ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 > ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 1 == ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 == ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "diffy *= -1",
      "mutated_line": "diffy *= +1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= +1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 2, -1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 2, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 0, -1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 0, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 0, -1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 0, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - -1, -1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - -1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -2, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -2, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -0, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -0, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -0, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -0, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, --1, -1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, --1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -1, -2):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -2):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -1, -0):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -0):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -1, -0):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -0):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for i in range(len(lis) - 1, -1, -1):",
      "mutated_line": "for i in range(len(lis) - 1, -1, --1):",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, --1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i == len(lis) + 1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) + 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i == len(lis) * 1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) * 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "kai = loop - lis[i]",
      "mutated_line": "kai = loop + lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop + lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "kai = loop - lis[i]",
      "mutated_line": "kai = loop * lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop * lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i + 1] + lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] + lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i + 1] * lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] * lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p) / (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) / (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p + (lasta + kai)) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p + (lasta + kai)) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p) ** (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) ** (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (1 - p) / lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) / lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (1 - p + lastb) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p + lastb) % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (1 - p) ** lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) ** lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 1:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == -1:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 1:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) / inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) / inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = newa + lis[0] + inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = newa + lis[0] + inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) ** inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) ** inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return ans % MOD",
      "mutated_line": "return ans * MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans * MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return ans % MOD",
      "mutated_line": "return ans + MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans + MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 / (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 / (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = (2 + (n - 1)) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = (2 + (n - 1)) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 ** (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 ** (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 3 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 3 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 1 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 1 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 0 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 0 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 1 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 1 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * -2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * -2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 2) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 2) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 0) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 0) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 0) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 0) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - -1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - -1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(3 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(3 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(1 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(1 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(0 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(0 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(1 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(1 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(-2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(-2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n + 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n + 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n * 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n * 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 3 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 3 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 1 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 1 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 0 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 0 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 1 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 1 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), -2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), -2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m + 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m + 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m * 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m * 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 2 <= tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 2 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 0 <= tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 0 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 0 <= tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 0 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not -1 <= tx + diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not -1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 1 <= tx - diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx - diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if not 1 <= tx + diffx <= n:",
      "mutated_line": "if not 1 <= tx * diffx <= n:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx * diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "diffx *= -1",
      "mutated_line": "diffx *= -2",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -2\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "diffx *= -1",
      "mutated_line": "diffx *= -0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -0\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "diffx *= -1",
      "mutated_line": "diffx *= -0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -0\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "diffx *= -1",
      "mutated_line": "diffx *= --1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= --1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 2 <= ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 2 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 0 <= ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 0 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 0 <= ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 0 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not -1 <= ty + diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not -1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 1 <= ty - diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty - diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if not 1 <= ty + diffy <= m:",
      "mutated_line": "if not 1 <= ty * diffy <= m:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty * diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "diffy *= -1",
      "mutated_line": "diffy *= -2",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -2\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "diffy *= -1",
      "mutated_line": "diffy *= -0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -0\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "diffy *= -1",
      "mutated_line": "diffy *= -0",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -0\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "diffy *= -1",
      "mutated_line": "diffy *= --1",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= --1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i == len(lis) - 2:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 2:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i == len(lis) - 0:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 0:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i == len(lis) - 0:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 0:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if i == len(lis) - 1:",
      "mutated_line": "if i == len(lis) - -1:",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - -1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 + p) * (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 + p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = 1 * p * (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = 1 * p * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p) * (lasta - kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta - kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (1 - p) * (lasta * kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta * kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (1 + p) * lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 + p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = 1 * p * lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = 1 * p * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa - lis[0]) * inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa - lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = newa * lis[0] * inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = newa * lis[0] * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 3 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 3 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 1 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 1 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 0 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 0 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 1 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 1 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = -2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = -2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n + 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n + 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n * 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n * 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 2), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 2), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 0), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 0), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 0), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 0), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - -1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - -1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 2))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 2))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 0))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 0))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 0))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 0))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - -1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - -1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i - 1] - lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i - 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i * 1] - lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i * 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (2 - p) * (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (2 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (0 - p) * (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (0 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (0 - p) * (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (0 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "newa = (1 - p) * (lasta + kai) % MOD",
      "mutated_line": "newa = (-1 - p) * (lasta + kai) % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (-1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (2 - p) * lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (2 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (0 - p) * lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (0 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (0 - p) * lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (0 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "newb = (1 - p) * lastb % MOD",
      "mutated_line": "newb = (-1 - p) * lastb % MOD",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (-1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) * inverse(1 + newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 + newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) * inverse(1 * newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 * newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 2) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 2) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 0) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 0) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - 0) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 0) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "mutated_line": "loop = 2 * (n - -1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - -1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i + 2] - lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 2] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i + 0] - lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 0] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i + 0] - lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 0] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "kai = lis[i + 1] - lis[i]",
      "mutated_line": "kai = lis[i + -1] - lis[i]",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + -1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[1]) * inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[1]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[-1]) * inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[-1]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[1]) * inverse(1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[1]) * inverse(1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) * inverse(2 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(2 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) * inverse(0 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(0 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) * inverse(0 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(0 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = (newa + lis[0]) * inverse(1 - newb, MOD)",
      "mutated_line": "ans = (newa + lis[0]) * inverse(-1 - newb, MOD)",
      "code": "import math\nMOD = 10 ** 9 + 7\n\ndef inverse(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef calculate_expected_time(n, m, r_b, c_b, r_d, c_d, p):\n    one_hand = inverse(100, MOD)\n    p = p * one_hand % MOD\n    loop = 2 * (n - 1) * 2 * (m - 1) // math.gcd(2 * (n - 1), 2 * (m - 1))\n    xmods = []\n    tx = r_b\n    diffx = 1 if n != 1 else 0\n    for i in range(loop):\n        if tx == r_d:\n            xmods.append(i)\n        if not 1 <= tx + diffx <= n:\n            diffx *= -1\n        tx += diffx\n    ymods = []\n    ty = c_b\n    diffy = 1 if m != 1 else 0\n    for i in range(loop):\n        if ty == c_d:\n            ymods.append(i)\n        if not 1 <= ty + diffy <= m:\n            diffy *= -1\n        ty += diffy\n    s = set(xmods)\n    for i in ymods:\n        s.add(i)\n    lis = sorted(s)\n    (lasta, lastb) = (0, 1)\n    for i in range(len(lis) - 1, -1, -1):\n        if i == len(lis) - 1:\n            kai = loop - lis[i]\n        else:\n            kai = lis[i + 1] - lis[i]\n        newa = (1 - p) * (lasta + kai) % MOD\n        newb = (1 - p) * lastb % MOD\n        if i == 0:\n            ans = (newa + lis[0]) * inverse(-1 - newb, MOD)\n            return ans % MOD\n        (lasta, lastb) = (newa, newb)"
    }
  ]
}