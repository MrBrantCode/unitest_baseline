{
  "task_id": "taco_15923",
  "entry_point": "min_steps_to_reach_target",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if kx == tx and ky == ty:",
      "mutated_line": "if kx == tx or ky == ty:",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx or ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[kx][ky] = True",
      "mutated_line": "visited[kx][ky] = False",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = False\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "steps = 0",
      "mutated_line": "steps = 1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 1\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "steps = 0",
      "mutated_line": "steps = -1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = -1\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "steps = 0",
      "mutated_line": "steps = 1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 1\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "steps += 1",
      "mutated_line": "steps -= 1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps -= 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] + 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] * 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] + 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] * 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] + 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] + 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] * 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] * 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] + 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] + 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] * 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] * 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if kx == tx and ky == ty:",
      "mutated_line": "if kx != tx and ky == ty:",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx != tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if kx == tx and ky == ty:",
      "mutated_line": "if kx == tx and ky != ty:",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky != ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 1\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return -1\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 1\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "steps += 1",
      "mutated_line": "steps += 2",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 2\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "steps += 1",
      "mutated_line": "steps += 0",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 0\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "steps += 1",
      "mutated_line": "steps += 0",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 0\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "steps += 1",
      "mutated_line": "steps += -1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += -1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 2, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 0, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 0, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - -1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 2)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 0)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 0)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - -1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 2, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 2, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 0, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 0, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 0, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 0, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - -1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - -1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 2)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 2)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 0)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 0)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 0)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 0)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - -1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - -1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(+1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(+1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 3), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 3), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 1), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 1), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 0), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 0), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 1), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 1), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, -2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, -2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (+2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (+2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 2), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 2), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 0), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 0), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 0), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 0), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, -1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, -1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (+2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (+2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, +1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, +1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (+1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (+1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, +2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, +2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (2, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (2, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (0, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (0, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (0, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (0, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (-1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (-1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, +2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, +2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (3, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (3, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (1, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (1, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (0, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (0, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (1, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (1, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (-2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (-2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, +1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, +1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (3, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (3, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (1, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (1, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (0, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (0, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (1, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (1, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (-2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (-2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 2), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 2), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 0), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 0), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 0), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 0), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, -1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, -1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (2, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (2, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (0, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (0, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (0, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (0, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (-1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (-1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 3)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 3)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 1)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 1)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 0)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 0)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 1)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 1)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, -2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, -2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [[False for _ in range(N)] for _ in range(N)]",
      "mutated_line": "visited = [[True for _ in range(N)] for _ in range(N)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[True for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[1] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[-1] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[1] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[2] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[0] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[0] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "kx, ky = knight_pos[0] - 1, knight_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[-1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[1] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[1] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[-1] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[-1] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[1] - 1, target_pos[1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[1] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[2] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[2] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[0] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[0] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[0] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[0] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tx, ty = target_pos[0] - 1, target_pos[1] - 1",
      "mutated_line": "(tx, ty) = (target_pos[0] - 1, target_pos[-1] - 1)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[-1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-2, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-2, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-0, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-0, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-0, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-0, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(--1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(--1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-3, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-3, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-1, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-1, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-0, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-0, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-1, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-1, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (--2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (--2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-3, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-3, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-1, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-1, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-0, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-0, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-1, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-1, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (--2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (--2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -2), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -2), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -0), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -0), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -0), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -0), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, --1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, --1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-2, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-2, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-0, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-0, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-0, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-0, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (--1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (--1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -3), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -3), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -1), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -1), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -0), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -0), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -1), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -1), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(-1, 2), (-2, 1), (-2, -1), (-1, -2),",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, --2), (1, -2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, --2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -3), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -3), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -1), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -1), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -0), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -0), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -1), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -1), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, --2), (2, -1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, --2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -2), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -2), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -0), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -0), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -0), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -0), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(1, -2), (2, -1), (2, 1), (1, 2)",
      "mutated_line": "moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, --1), (2, 1), (1, 2)]",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, --1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N or 0 <= ny < N or (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N or 0 <= ny < N or (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx - dx, cy + dy)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx - dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx * dx, cy + dy)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx * dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx + dx, cy - dy)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy - dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "nx, ny = cx + dx, cy + dy",
      "mutated_line": "(nx, ny) = (cx + dx, cy * dy)",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy * dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 < nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 < nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 > nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 > nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 == nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 == nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 0 < ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 < ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 0 > ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 > ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 0 == ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 == ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if nx == tx and ny == ty:",
      "mutated_line": "if nx == tx or ny == ty:",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx or ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "visited[nx][ny] = True",
      "mutated_line": "visited[nx][ny] = False",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = False\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if -1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if -1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 1 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and -1 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and -1 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny]:",
      "mutated_line": "if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 1 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if nx == tx and ny == ty:",
      "mutated_line": "if nx != tx and ny == ty:",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx != tx and ny == ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if nx == tx and ny == ty:",
      "mutated_line": "if nx == tx and ny != ty:",
      "code": "from collections import deque\n\ndef min_steps_to_reach_target(N, knight_pos, target_pos):\n    (kx, ky) = (knight_pos[0] - 1, knight_pos[1] - 1)\n    (tx, ty) = (target_pos[0] - 1, target_pos[1] - 1)\n    if kx == tx and ky == ty:\n        return 0\n    moves = [(-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2)]\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    queue = deque([(kx, ky)])\n    visited[kx][ky] = True\n    steps = 0\n    while queue:\n        steps += 1\n        size = len(queue)\n        for _ in range(size):\n            (cx, cy) = queue.popleft()\n            for (dx, dy) in moves:\n                (nx, ny) = (cx + dx, cy + dy)\n                if 0 <= nx < N and 0 <= ny < N and (not visited[nx][ny]):\n                    if nx == tx and ny != ty:\n                        return steps\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n    return -1"
    }
  ]
}