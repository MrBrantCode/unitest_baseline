{
  "task_id": "taco_14767",
  "entry_point": "calculate_earliest_timesteps",
  "mutant_count": 109,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] / (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] / (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] + (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] + (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] ** (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] ** (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "answer[0] = 0",
      "mutated_line": "answer[0] = 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 1\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "answer[0] = 0",
      "mutated_line": "answer[0] = -1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = -1\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "answer[0] = 0",
      "mutated_line": "answer[0] = 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 1\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 * 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 * 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 + 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 + 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] * (m - 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m - 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] * (m * 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m * 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "answer[0] = 0",
      "mutated_line": "answer[1] = 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[1] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "answer[0] = 0",
      "mutated_line": "answer[-1] = 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[-1] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "answer[0] = 0",
      "mutated_line": "answer[1] = 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[1] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = x_prime / BASE",
      "mutated_line": "x = x_prime * BASE",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime * BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "x = x_prime / BASE",
      "mutated_line": "x = x_prime // BASE",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime // BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] / (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] / (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] + (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] + (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] ** (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] ** (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 1\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cur = 0",
      "mutated_line": "cur = -1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = -1\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 1\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) != m + 1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) != m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(11 ** 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(11 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(9 ** 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(9 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(0 ** 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(0 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(1 ** 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(1 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(-10 ** 5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(-10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 ** 6)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 6)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 ** 4)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 4)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 ** 0)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 0)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 ** 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 1)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "BASE = int(10 ** 5)",
      "mutated_line": "BASE = int(10 ** -5)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** -5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [+1] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [+1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] * (m + 2)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 2)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] * (m + 0)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 0)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] * (m + 0)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 0)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-1] * (m + -1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + -1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] * (m - 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m - 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] * (m * 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m * 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m - 1):",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m - 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m * 1):",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m * 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if answer[i] != -1:",
      "mutated_line": "if answer[i] == -1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] == -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) == m - 1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m - 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) == m * 1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m * 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if dis[u] == y:",
      "mutated_line": "if dis[u] != y:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] != y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t == 1:",
      "mutated_line": "if t != 1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t != 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if v > m:",
      "mutated_line": "if v >= m:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v >= m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if v > m:",
      "mutated_line": "if v <= m:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v <= m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if v > m:",
      "mutated_line": "if v != m:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v != m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dis[v] == -1:",
      "mutated_line": "if dis[v] != -1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] != -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return answer[1:]",
      "mutated_line": "return answer[2:]",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return answer[1:]",
      "mutated_line": "return answer[0:]",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return answer[1:]",
      "mutated_line": "return answer[0:]",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return answer[1:]",
      "mutated_line": "return answer[-1:]",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[-1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-2] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-2] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-0] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-0] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [-0] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-0] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "answer = [-1] * (m + 1)",
      "mutated_line": "answer = [--1] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [--1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [+1] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [+1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] * (m + 2)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 2)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] * (m + 0)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 0)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] * (m + 0)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 0)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-1] * (m + -1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + -1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + 2):",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 2):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + 0):",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 0):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + 0):",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 0):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(m + 1):",
      "mutated_line": "for i in range(m + -1):",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + -1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if answer[i] != -1:",
      "mutated_line": "if answer[i] != +1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != +1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis[i] = 0",
      "mutated_line": "dis[i] = 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 1\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis[i] = 0",
      "mutated_line": "dis[i] = -1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = -1\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dis[i] = 0",
      "mutated_line": "dis[i] = 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 1\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) == m + 2:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 2:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) == m + 0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 0:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) == m + 0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 0:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(bfs) == m + 1:",
      "mutated_line": "if len(bfs) == m + -1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + -1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t == 1:",
      "mutated_line": "if t == 2:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 2:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t == 1:",
      "mutated_line": "if t == 0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 0:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t == 1:",
      "mutated_line": "if t == 0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 0:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t == 1:",
      "mutated_line": "if t == -1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == -1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if dis[v] == -1:",
      "mutated_line": "if dis[v] == +1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == +1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dis[v] = dis[u] + 1",
      "mutated_line": "dis[v] = dis[u] - 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] - 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dis[v] = dis[u] + 1",
      "mutated_line": "dis[v] = dis[u] * 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] * 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "answer[v] = step + 1",
      "mutated_line": "answer[v] = step - 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step - 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "answer[v] = step + 1",
      "mutated_line": "answer[v] = step * 1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step * 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-2] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-2] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-0] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-0] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [-0] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-0] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dis = [-1] * (m + 1)",
      "mutated_line": "dis = [--1] * (m + 1)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [--1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if answer[i] != -1:",
      "mutated_line": "if answer[i] != -2:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -2:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if answer[i] != -1:",
      "mutated_line": "if answer[i] != -0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -0:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if answer[i] != -1:",
      "mutated_line": "if answer[i] != -0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -0:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if answer[i] != -1:",
      "mutated_line": "if answer[i] != --1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != --1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "v = math.ceil(u + x)",
      "mutated_line": "v = math.ceil(u - x)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u - x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "v = math.ceil(u + x)",
      "mutated_line": "v = math.ceil(u * x)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u * x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "v = math.ceil(u * x)",
      "mutated_line": "v = math.ceil(u / x)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u / x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "v = math.ceil(u * x)",
      "mutated_line": "v = math.ceil(u + x)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u + x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "v = math.ceil(u * x)",
      "mutated_line": "v = math.ceil(u ** x)",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u ** x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dis[v] == -1:",
      "mutated_line": "if dis[v] == -2:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -2:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dis[v] == -1:",
      "mutated_line": "if dis[v] == -0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -0:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dis[v] == -1:",
      "mutated_line": "if dis[v] == -0:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -0:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dis[v] == -1:",
      "mutated_line": "if dis[v] == --1:",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == --1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dis[v] = dis[u] + 1",
      "mutated_line": "dis[v] = dis[u] + 2",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 2\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dis[v] = dis[u] + 1",
      "mutated_line": "dis[v] = dis[u] + 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 0\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dis[v] = dis[u] + 1",
      "mutated_line": "dis[v] = dis[u] + 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 0\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dis[v] = dis[u] + 1",
      "mutated_line": "dis[v] = dis[u] + -1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + -1\n                bfs.append(v)\n                answer[v] = step + 1\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "answer[v] = step + 1",
      "mutated_line": "answer[v] = step + 2",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 2\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "answer[v] = step + 1",
      "mutated_line": "answer[v] = step + 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 0\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "answer[v] = step + 1",
      "mutated_line": "answer[v] = step + 0",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + 0\n    return answer[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "answer[v] = step + 1",
      "mutated_line": "answer[v] = step + -1",
      "code": "import math\n\ndef calculate_earliest_timesteps(n, m, operations):\n    BASE = int(10 ** 5)\n    answer = [-1] * (m + 1)\n    answer[0] = 0\n    for step in range(n):\n        (t, x_prime, y) = operations[step]\n        x = x_prime / BASE\n        bfs = []\n        dis = [-1] * (m + 1)\n        cur = 0\n        for i in range(m + 1):\n            if answer[i] != -1:\n                bfs.append(i)\n                dis[i] = 0\n        if len(bfs) == m + 1:\n            break\n        for u in bfs:\n            if dis[u] == y:\n                continue\n            if t == 1:\n                v = math.ceil(u + x)\n            else:\n                v = math.ceil(u * x)\n            if v > m:\n                continue\n            if dis[v] == -1:\n                dis[v] = dis[u] + 1\n                bfs.append(v)\n                answer[v] = step + -1\n    return answer[1:]"
    }
  ]
}