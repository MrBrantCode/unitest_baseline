{
  "task_id": "taco_2805",
  "entry_point": "calculate_mst_weight",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [0] * N",
      "mutated_line": "self.rank = [0] / N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] / N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [0] * N",
      "mutated_line": "self.rank = [0] + N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] + N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [0] * N",
      "mutated_line": "self.rank = [0] ** N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] ** N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [1] / N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] / N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [1] + N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] + N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [1] ** N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] ** N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if self.par[x] == x:",
      "mutated_line": "if self.par[x] != x:",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] != x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if x != y:",
      "mutated_line": "if x == y:",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] <= self.rank[y]:",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] <= self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] >= self.rank[y]:",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] >= self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if self.rank[x] < self.rank[y]:",
      "mutated_line": "if self.rank[x] != self.rank[y]:",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] != self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "return self.find(x) == self.find(y)",
      "mutated_line": "return self.find(x) != self.find(y)",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) != self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 1\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = -1\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 1\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z = self.counter[x] + self.counter[y]",
      "mutated_line": "z = self.counter[x] - self.counter[y]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] - self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "z = self.counter[x] + self.counter[y]",
      "mutated_line": "z = self.counter[x] * self.counter[y]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] * self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if self.rank[x] == self.rank[y]:",
      "mutated_line": "if self.rank[x] != self.rank[y]:",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] != self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] -= 1",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] -= 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "res += e[2]",
      "mutated_line": "res -= e[2]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res -= e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [0] * N",
      "mutated_line": "self.rank = [1] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [1] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [0] * N",
      "mutated_line": "self.rank = [-1] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [-1] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [0] * N",
      "mutated_line": "self.rank = [1] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [1] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [2] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [2] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [0] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [0] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [0] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [0] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.counter = [1] * N",
      "mutated_line": "self.counter = [-1] * N",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [-1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 2",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 2\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 0",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 0\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += 0",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 0\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "self.rank[x] += 1",
      "mutated_line": "self.rank[x] += -1",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += -1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res += e[2]",
      "mutated_line": "res += e[3]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[3]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res += e[2]",
      "mutated_line": "res += e[1]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[1]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res += e[2]",
      "mutated_line": "res += e[0]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[0]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res += e[2]",
      "mutated_line": "res += e[1]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[1]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res += e[2]",
      "mutated_line": "res += e[-2]",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[-2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "edges = sorted(self.edges, key=lambda x: x[2])",
      "mutated_line": "edges = sorted(self.edges, key=lambda x: x[3])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[3])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "edges = sorted(self.edges, key=lambda x: x[2])",
      "mutated_line": "edges = sorted(self.edges, key=lambda x: x[1])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[1])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "edges = sorted(self.edges, key=lambda x: x[2])",
      "mutated_line": "edges = sorted(self.edges, key=lambda x: x[0])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[0])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "edges = sorted(self.edges, key=lambda x: x[2])",
      "mutated_line": "edges = sorted(self.edges, key=lambda x: x[1])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[1])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "edges = sorted(self.edges, key=lambda x: x[2])",
      "mutated_line": "edges = sorted(self.edges, key=lambda x: x[-2])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[-2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[1], e[1]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[1], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[-1], e[1]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[-1], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[1], e[1]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[1], e[1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[0], e[2]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[2]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[0], e[0]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[0]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[0], e[0]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[0]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if not self.same(e[0], e[1]):",
      "mutated_line": "if not self.same(e[0], e[-1]):",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[-1]):\n                self.unite(e[0], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[1], e[1])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[1], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[-1], e[1])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[-1], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[1], e[1])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[1], e[1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[0], e[2])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[2])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[0], e[0])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[0])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[0], e[0])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[0])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "self.unite(e[0], e[1])",
      "mutated_line": "self.unite(e[0], e[-1])",
      "code": "class Kruskal_UnionFind:\n\n    def __init__(self, N):\n        self.edges = []\n        self.rank = [0] * N\n        self.par = [i for i in range(N)]\n        self.counter = [1] * N\n\n    def add(self, u, v, d):\n        self.edges.append([u, v, d])\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            z = self.counter[x] + self.counter[y]\n            (self.counter[x], self.counter[y]) = (z, z)\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def size(self, x):\n        x = self.find(x)\n        return self.counter[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def Kruskal(self):\n        edges = sorted(self.edges, key=lambda x: x[2])\n        res = 0\n        for e in edges:\n            if not self.same(e[0], e[1]):\n                self.unite(e[0], e[-1])\n                res += e[2]\n        return res\n\ndef calculate_mst_weight(V, edges):\n    graph = Kruskal_UnionFind(V)\n    for (s, t, w) in edges:\n        graph.add(s, t, w)\n    return graph.Kruskal()"
    }
  ]
}