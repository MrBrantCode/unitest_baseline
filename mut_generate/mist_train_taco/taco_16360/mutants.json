{
  "task_id": "taco_16360",
  "entry_point": "prims_minimum_spanning_tree",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "D[start] = 0",
      "mutated_line": "D[start] = 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 1\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "D[start] = 0",
      "mutated_line": "D[start] = -1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = -1\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "D[start] = 0",
      "mutated_line": "D[start] = 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 1\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [1 for _ in range(n + 1)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [1 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [-1 for _ in range(n + 1)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [-1 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [1 for _ in range(n + 1)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [1 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(2, n + 1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(2, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(0, n + 1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(0, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(0, n + 1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(0, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(-1, n + 1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(-1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n - 1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n - 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n * 1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n * 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[1]] -= 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] -= 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "H = [(0, start)]",
      "mutated_line": "H = [(1, start)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(1, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "H = [(0, start)]",
      "mutated_line": "H = [(-1, start)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(-1, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "H = [(0, start)]",
      "mutated_line": "H = [(1, start)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(1, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + 2):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 2):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + 0):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 0):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + 0):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 0):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for node in range(1, n + 1):",
      "mutated_line": "for node in range(1, n + -1):",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + -1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "D[node] = float('inf')",
      "mutated_line": "D[node] = float('')",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == 0 or D[neighbor] > weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 or D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[1]] += 2",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 2\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[1]] += 0",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 0\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[1]] += 0",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 0\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[1]] += -1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += -1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [0 for _ in range(n - 1)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n - 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [0 for _ in range(n * 1)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n * 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for weight, neighbor in G[t[1]]:",
      "mutated_line": "for (weight, neighbor) in G[t[2]]:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[2]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for weight, neighbor in G[t[1]]:",
      "mutated_line": "for (weight, neighbor) in G[t[0]]:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[0]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for weight, neighbor in G[t[1]]:",
      "mutated_line": "for (weight, neighbor) in G[t[0]]:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[0]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for weight, neighbor in G[t[1]]:",
      "mutated_line": "for (weight, neighbor) in G[t[-1]]:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[-1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] != 0 and D[neighbor] > weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] != 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == 0 and D[neighbor] >= weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] >= weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == 0 and D[neighbor] <= weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] <= weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == 0 and D[neighbor] != weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] != weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (D[neighbor], neighbor) in H:",
      "mutated_line": "if (D[neighbor], neighbor) not in H:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) not in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "total_weight = sum(T[1:])",
      "mutated_line": "total_weight = sum(T[2:])",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[2:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "total_weight = sum(T[1:])",
      "mutated_line": "total_weight = sum(T[0:])",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[0:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "total_weight = sum(T[1:])",
      "mutated_line": "total_weight = sum(T[0:])",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[0:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "total_weight = sum(T[1:])",
      "mutated_line": "total_weight = sum(T[-1:])",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[-1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [0 for _ in range(n + 2)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 2)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [0 for _ in range(n + 0)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 0)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [0 for _ in range(n + 0)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 0)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "T = [0 for _ in range(n + 1)]",
      "mutated_line": "T = [0 for _ in range(n + -1)]",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + -1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == 1 and D[neighbor] > weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 1 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == -1 and D[neighbor] > weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == -1 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if E[neighbor] == 0 and D[neighbor] > weight:",
      "mutated_line": "if E[neighbor] == 1 and D[neighbor] > weight:",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 1 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[2]] += 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[2]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[0]] += 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[0]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[0]] += 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[0]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "E[t[1]] += 1",
      "mutated_line": "E[t[-1]] += 1",
      "code": "from collections import defaultdict\nimport heapq\n\ndef prims_minimum_spanning_tree(n, edges, start):\n    G = defaultdict(set)\n    for (u, v, w) in edges:\n        G[u].add((w, v))\n        G[v].add((w, u))\n    E = defaultdict(int)\n    D = {}\n    T = [0 for _ in range(n + 1)]\n    H = [(0, start)]\n    for node in range(1, n + 1):\n        D[node] = float('inf')\n    D[start] = 0\n    while H:\n        t = heapq.heappop(H)\n        for (weight, neighbor) in G[t[1]]:\n            if E[neighbor] == 0 and D[neighbor] > weight:\n                D[neighbor] = weight\n                if (D[neighbor], neighbor) in H:\n                    H.remove((D[neighbor], neighbor))\n                    heapq.heapify(H)\n                heapq.heappush(H, (D[neighbor], neighbor))\n                T[neighbor] = D[neighbor]\n            E[t[-1]] += 1\n    total_weight = sum(T[1:])\n    return total_weight"
    }
  ]
}