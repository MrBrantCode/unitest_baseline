{
  "task_id": "taco_8596",
  "entry_point": "determine_flat_floor",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(2, 1000):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(2, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(0, 1000):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(0, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(0, 1000):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(0, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(-1, 1000):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(-1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(1, 1001):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1001):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(1, 999):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 999):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(1, 0):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 0):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(1, 1):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for flats_per_floor in range(1, 1000):",
      "mutated_line": "for flats_per_floor in range(1, -1000):",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, -1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "consistent = True",
      "mutated_line": "consistent = False",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = False\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) // flats_per_floor - 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor - 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) // flats_per_floor * 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor * 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return +1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "first_floor = possible_floors[0]",
      "mutated_line": "first_floor = possible_floors[1]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[1]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "first_floor = possible_floors[0]",
      "mutated_line": "first_floor = possible_floors[-1]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[-1]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "first_floor = possible_floors[0]",
      "mutated_line": "first_floor = possible_floors[1]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[1]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if floor != first_floor:",
      "mutated_line": "if floor == first_floor:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor == first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor == f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor == f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) / flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) / flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) * flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) * flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) // flats_per_floor + 2 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 2 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) // flats_per_floor + 0 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 0 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) // flats_per_floor + 0 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 0 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 1) // flats_per_floor + -1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + -1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -2\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -0\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -0\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return --1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return +1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) / flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) / flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) * flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) * flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor != f + 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f + 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor != f * 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f * 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "consistent = False",
      "mutated_line": "consistent = True",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = True\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n + 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n + 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [n * 1 // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [n * 1 // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -2\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -0\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -0\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return --1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k + 1) // flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k + 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if k * 1 // flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if k * 1 // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor != f - 2:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 2:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor != f - 0:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 0:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor != f - 0:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 0:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 1) // flats_per_floor != f - -1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - -1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 2) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 2) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 0) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 0) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - 0) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 0) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "mutated_line": "possible_floors = [(n - -1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - -1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 2) // flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 2) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 0) // flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 0) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - 0) // flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - 0) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if (k - 1) // flats_per_floor != f - 1:",
      "mutated_line": "if (k - -1) // flats_per_floor != f - 1:",
      "code": "def determine_flat_floor(n, m, memory):\n    possible_flats_per_floor = []\n    for flats_per_floor in range(1, 1000):\n        consistent = True\n        for (k, f) in memory:\n            if (k - -1) // flats_per_floor != f - 1:\n                consistent = False\n                break\n        if consistent:\n            possible_flats_per_floor.append(flats_per_floor)\n    possible_floors = [(n - 1) // flats_per_floor + 1 for flats_per_floor in possible_flats_per_floor]\n    if not possible_floors:\n        return -1\n    first_floor = possible_floors[0]\n    for floor in possible_floors:\n        if floor != first_floor:\n            return -1\n    return first_floor"
    }
  ]
}