{
  "task_id": "taco_17344",
  "entry_point": "find_shortest_route_time",
  "mutant_count": 76,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, -1] = 1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 1\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, -1] = -1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = -1\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, -1] = 1",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 1\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 'unreachable'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return ''\n    return dijkstra(s)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur == g or vel1 == 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g or vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "used[v] = True",
      "mutated_line": "used[v] = False",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = False\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 1, -1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 1, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, -1, -1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, -1, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 1, -1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 1, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, +1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, +1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (1, (s, 0, -1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (1, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (-1, (s, 0, -1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (-1, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (1, (s, 0, -1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (1, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur != g and vel1 == 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur != g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur == g and vel1 != 1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 != 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if to == prev1:",
      "mutated_line": "if to != prev1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to != prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = defaultdict(lambda: float('INF'))",
      "mutated_line": "d = defaultdict(lambda : float(''))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float(''))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, -2] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -2] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, -0] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -0] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, -0] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -0] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[s, 0, -1] = 0",
      "mutated_line": "d[s, 0, --1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, --1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 1, -1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 1, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, -1, -1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, -1, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 1, -1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 1, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 0, +1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, +1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[1], v[1], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[1], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[-1], v[1], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[-1], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[1], v[1], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[1], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[2], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[2], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[0], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[0], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[0], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[0], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[-1], v[2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[-1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[1], v[3])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[3])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[1], v[1])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[1])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[1], v[0])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[0])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[1], v[1])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[1])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(cur, vel1, prev1) = (v[0], v[1], v[2])",
      "mutated_line": "(cur, vel1, prev1) = (v[0], v[1], v[-2])",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[-2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur == g and vel1 == 2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 2:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur == g and vel1 == 0:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 0:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur == g and vel1 == 0:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 0:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if cur == g and vel1 == 1:",
      "mutated_line": "if cur == g and vel1 == -1:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == -1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 + 1, vel1 + 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 + 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 * 1, vel1 + 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 * 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 - 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 - 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 * 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 * 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 1 and ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 and ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elapsed2 = elapsed + dist / vel2",
      "mutated_line": "elapsed2 = elapsed - dist / vel2",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed - dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elapsed2 = elapsed + dist / vel2",
      "mutated_line": "elapsed2 = elapsed * (dist / vel2)",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed * (dist / vel2)\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d[nxt] > elapsed2:",
      "mutated_line": "if d[nxt] >= elapsed2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] >= elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d[nxt] > elapsed2:",
      "mutated_line": "if d[nxt] <= elapsed2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] <= elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d[nxt] > elapsed2:",
      "mutated_line": "if d[nxt] != elapsed2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] != elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 0, -2)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -2)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 0, -0)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -0)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 0, -0)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -0)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heappush(q, (0, (s, 0, -1)))",
      "mutated_line": "heappush(q, (0, (s, 0, --1)))",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, --1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 2, vel1 + 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 2, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 0, vel1 + 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 0, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 0, vel1 + 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 0, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - -1, vel1 + 2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - -1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 + 3):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 3):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 + 1):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 1):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 + 0):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 0):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 + 1):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 1):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for vel2 in range(vel1 - 1, vel1 + 2):",
      "mutated_line": "for vel2 in range(vel1 - 1, vel1 + -2):",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + -2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 <= 1 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 <= 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 >= 1 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 >= 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 != 1 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 != 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 1 or ct <= vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct <= vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 1 or ct >= vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct >= vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 1 or ct != vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct != vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elapsed2 = elapsed + dist / vel2",
      "mutated_line": "elapsed2 = elapsed + dist * vel2",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist * vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "elapsed2 = elapsed + dist / vel2",
      "mutated_line": "elapsed2 = elapsed + dist // vel2",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist // vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 2 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 2 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 0 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 0 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < 0 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < 0 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if vel2 < 1 or ct < vel2:",
      "mutated_line": "if vel2 < -1 or ct < vel2:",
      "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef find_shortest_route_time(n, m, s, g, roads):\n    graph = defaultdict(list)\n    for (x, y, d, c) in roads:\n        graph[x].append((y, d, c))\n        graph[y].append((x, d, c))\n\n    def dijkstra(s):\n        d = defaultdict(lambda : float('INF'))\n        d[s, 0, -1] = 0\n        used = defaultdict(bool)\n        q = []\n        heappush(q, (0, (s, 0, -1)))\n        while len(q):\n            (elapsed, v) = heappop(q)\n            (cur, vel1, prev1) = (v[0], v[1], v[2])\n            if cur == g and vel1 == 1:\n                return elapsed\n            if used[v]:\n                continue\n            used[v] = True\n            for (to, dist, ct) in graph[cur]:\n                if to == prev1:\n                    continue\n                for vel2 in range(vel1 - 1, vel1 + 2):\n                    if vel2 < -1 or ct < vel2:\n                        continue\n                    nxt = (to, vel2, cur)\n                    if used[nxt]:\n                        continue\n                    elapsed2 = elapsed + dist / vel2\n                    if d[nxt] > elapsed2:\n                        d[nxt] = elapsed2\n                        heappush(q, (elapsed2, nxt))\n        return 'unreachable'\n    return dijkstra(s)"
    }
  ]
}