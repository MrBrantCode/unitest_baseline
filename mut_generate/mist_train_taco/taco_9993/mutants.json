{
  "task_id": "taco_9993",
  "entry_point": "count_stack_exterminable_subarrays",
  "mutant_count": 115,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter = 0",
      "mutated_line": "counter = 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 1\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter = 0",
      "mutated_line": "counter = -1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = -1\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "counter = 0",
      "mutated_line": "counter = 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 1\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter += (value - 1) * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter += (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter -= value * (value - 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter -= value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "trie = node_stack[-1]",
      "mutated_line": "trie = node_stack[+1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[+1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 and stack[-1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 and stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[0] -= 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] -= 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][0] -= 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] -= 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) / 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) / 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) * 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) * 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) / 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) / 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) * 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) * 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "node_stack = [[1, {}]]",
      "mutated_line": "node_stack = [[2, {}]]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[2, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "node_stack = [[1, {}]]",
      "mutated_line": "node_stack = [[0, {}]]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[0, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "node_stack = [[1, {}]]",
      "mutated_line": "node_stack = [[0, {}]]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[0, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "node_stack = [[1, {}]]",
      "mutated_line": "node_stack = [[-1, {}]]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[-1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "trie = node_stack[-1]",
      "mutated_line": "trie = node_stack[-2]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-2]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "trie = node_stack[-1]",
      "mutated_line": "trie = node_stack[-0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-0]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "trie = node_stack[-1]",
      "mutated_line": "trie = node_stack[-0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-0]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "trie = node_stack[-1]",
      "mutated_line": "trie = node_stack[--1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[--1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) != 0 or stack[-1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) != 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 or stack[-1] == el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] == el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if el not in current_node[1]:",
      "mutated_line": "if el in current_node[1]:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[0] += 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 2\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[0] += 0",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 0\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[0] += 0",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 0\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[0] += -1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += -1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][0] += 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 2\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][0] += 0",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 0\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][0] += 0",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 0\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][0] += -1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += -1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[-1][1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][1]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[-1][-1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][-1]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[-1][1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][1]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) / (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) / (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1 + (value - 2)) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1 + (value - 2)) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) ** (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) ** (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) // 3",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 3\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) // 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 1\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) // 0",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 0\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) // 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 1\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 2) // -2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // -2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value / (value - 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value / (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += (value + (value - 1)) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += (value + (value - 1)) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value ** (value - 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value ** (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) // 3",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 3\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) // 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 1\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) // 0",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 0\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) // 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 1\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 1) // -2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // -2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 1 or stack[-1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 1 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == -1 or stack[-1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == -1 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 1 or stack[-1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 1 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "current_node = node_stack[-1]",
      "mutated_line": "current_node = node_stack[+1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[+1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[1] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[1] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[-1] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[-1] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "next_node[0] += 1",
      "mutated_line": "next_node[1] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[1] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][1] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][1] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][-1] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][-1] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-1][1] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][1] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[+1][0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[+1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value + 1) * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value + 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= value * 1 * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= value * 1 * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value + 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value + 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value * 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value * 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value + 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value + 1) // 2\n    return counter"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value * 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value * 1) // 2\n    return counter"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 or stack[+1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[+1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current_node = node_stack[-1]",
      "mutated_line": "current_node = node_stack[-2]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-2]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current_node = node_stack[-1]",
      "mutated_line": "current_node = node_stack[-0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-0]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current_node = node_stack[-1]",
      "mutated_line": "current_node = node_stack[-0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-0]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "current_node = node_stack[-1]",
      "mutated_line": "current_node = node_stack[--1]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[--1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if el not in current_node[1]:",
      "mutated_line": "if el not in current_node[2]:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[2]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if el not in current_node[1]:",
      "mutated_line": "if el not in current_node[0]:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[0]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if el not in current_node[1]:",
      "mutated_line": "if el not in current_node[0]:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[0]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if el not in current_node[1]:",
      "mutated_line": "if el not in current_node[-1]:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[-1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[1][el] = [1, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [1, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[1][el] = [-1, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [-1, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[1][el] = [1, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [1, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_node = current_node[1][el]",
      "mutated_line": "next_node = current_node[2][el]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[2][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_node = current_node[1][el]",
      "mutated_line": "next_node = current_node[0][el]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[0][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_node = current_node[1][el]",
      "mutated_line": "next_node = current_node[0][el]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[0][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "next_node = current_node[1][el]",
      "mutated_line": "next_node = current_node[-1][el]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[-1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[+1][0] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[+1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[-2][0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-2][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[-0][0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-0][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[-0][0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-0][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "value = node_stack[-1][0]",
      "mutated_line": "value = node_stack[--1][0]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[--1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 2) * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 2) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 0) * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 0) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 0) * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 0) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - -1) * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - -1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 3) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 3) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 1) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 0) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 0) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - 1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 1) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "counter -= (value - 1) * (value - 2) // 2",
      "mutated_line": "counter -= (value - 1) * (value - -2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - -2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 2) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 2) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 0) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 0) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - 0) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 0) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "counter += value * (value - 1) // 2",
      "mutated_line": "counter += value * (value - -1) // 2",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - -1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 or stack[-2] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-2] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 or stack[-0] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-0] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 or stack[-0] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-0] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if len(stack) == 0 or stack[-1] != el:",
      "mutated_line": "if len(stack) == 0 or stack[--1] != el:",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[--1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[2][el] = [0, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[2][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[0][el] = [0, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[0][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[0][el] = [0, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[0][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "current_node[1][el] = [0, {}]",
      "mutated_line": "current_node[-1][el] = [0, {}]",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[-1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-2][0] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-2][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-0][0] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-0][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[-0][0] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[-0][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "node_stack[-1][0] += 1",
      "mutated_line": "node_stack[--1][0] += 1",
      "code": "def count_stack_exterminable_subarrays(a: list[int]) -> int:\n    \"\"\"\n    Counts the number of stack exterminable subarrays in the given array `a`.\n\n    A subarray is considered stack exterminable if, after processing the array\n    elements according to the stack extermination rules, the stack remains empty.\n\n    Parameters:\n    a (list[int]): The input array of integers.\n\n    Returns:\n    int: The number of stack exterminable subarrays.\n    \"\"\"\n    stack = [None]\n    node_stack = [[1, {}]]\n    trie = node_stack[-1]\n    counter = 0\n    for el in a:\n        if len(stack) == 0 or stack[-1] != el:\n            current_node = node_stack[-1]\n            stack.append(el)\n            if el not in current_node[1]:\n                current_node[1][el] = [0, {}]\n            next_node = current_node[1][el]\n            next_node[0] += 1\n            node_stack.append(next_node)\n        else:\n            stack.pop()\n            node_stack.pop()\n            node_stack[--1][0] += 1\n        value = node_stack[-1][0]\n        counter -= (value - 1) * (value - 2) // 2\n        counter += value * (value - 1) // 2\n    return counter"
    }
  ]
}