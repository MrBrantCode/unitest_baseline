{
  "task_id": "taco_19175",
  "entry_point": "find_max_good_segment_length",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "curr += nums[i]",
      "mutated_line": "curr -= nums[i]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr -= nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 1\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = -1\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 1\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return last - node",
      "mutated_line": "return last + node",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last + node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return last - node",
      "mutated_line": "return last * node",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last * node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(start_index, j, curr) = ([], 0, 0)",
      "mutated_line": "(start_index, j, curr) = ([], 1, 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 1, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(start_index, j, curr) = ([], 0, 0)",
      "mutated_line": "(start_index, j, curr) = ([], -1, 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], -1, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(start_index, j, curr) = ([], 0, 0)",
      "mutated_line": "(start_index, j, curr) = ([], 1, 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 1, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(start_index, j, curr) = ([], 0, 0)",
      "mutated_line": "(start_index, j, curr) = ([], 0, 1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 1)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(start_index, j, curr) = ([], 0, 0)",
      "mutated_line": "(start_index, j, curr) = ([], 0, -1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, -1)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(start_index, j, curr) = ([], 0, 0)",
      "mutated_line": "(start_index, j, curr) = ([], 0, 1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 1)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while curr > S:",
      "mutated_line": "while curr >= S:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr >= S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while curr > S:",
      "mutated_line": "while curr <= S:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr <= S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while curr > S:",
      "mutated_line": "while curr != S:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr != S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "curr -= nums[j]",
      "mutated_line": "curr += nums[j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr += nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j -= 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N + 1, -1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N + 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N * 1, -1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N * 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, +1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, +1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, +1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, +1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] / N for _ in range(20)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] / N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] + N for _ in range(20)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] + N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] ** N for _ in range(20)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] ** N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "up[0] = start_index",
      "mutated_line": "up[1] = start_index",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[1] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "up[0] = start_index",
      "mutated_line": "up[-1] = start_index",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[-1] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "up[0] = start_index",
      "mutated_line": "up[1] = start_index",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[1] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(2, 20):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(2, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(0, 20):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(0, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(0, 20):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(0, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(-1, 20):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(-1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 21):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 21):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 19):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 19):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 0):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 1):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, 20):",
      "mutated_line": "for i in range(1, -20):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, -20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(last, jump) = (node, 1)",
      "mutated_line": "(last, jump) = (node, 2)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 2)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(last, jump) = (node, 1)",
      "mutated_line": "(last, jump) = (node, 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 0)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(last, jump) = (node, 1)",
      "mutated_line": "(last, jump) = (node, 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 0)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "(last, jump) = (node, 1)",
      "mutated_line": "(last, jump) = (node, -1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, -1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(19):",
      "mutated_line": "for i in range(20):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(20):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(19):",
      "mutated_line": "for i in range(18):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(18):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(19):",
      "mutated_line": "for i in range(0):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(0):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(19):",
      "mutated_line": "for i in range(1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(1):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(19):",
      "mutated_line": "for i in range(-19):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(-19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if node == -1:",
      "mutated_line": "if node != -1:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node != -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if K & jump:",
      "mutated_line": "if K | jump:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K | jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "jump <<= 1",
      "mutated_line": "jump <<= 2",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 2\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "jump <<= 1",
      "mutated_line": "jump <<= 0",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 0\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "jump <<= 1",
      "mutated_line": "jump <<= 0",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 0\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "jump <<= 1",
      "mutated_line": "jump <<= -1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= -1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 2\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 0\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 0\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += -1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "start_index.append(j - 1)",
      "mutated_line": "start_index.append(j + 1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j + 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "start_index.append(j - 1)",
      "mutated_line": "start_index.append(j * 1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j * 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 2, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 0, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 0, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - -1, -1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - -1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -2, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -2, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -0, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -0, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -0, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -0, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, --1, -1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, --1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -2):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -2):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -0):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -0):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -0):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -0):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, --1):",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, --1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if p == -1:",
      "mutated_line": "if p != -1:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p != -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if node == -1:",
      "mutated_line": "if node == +1:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == +1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start_index.append(j - 1)",
      "mutated_line": "start_index.append(j - 2)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 2)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start_index.append(j - 1)",
      "mutated_line": "start_index.append(j - 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 0)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start_index.append(j - 1)",
      "mutated_line": "start_index.append(j - 0)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 0)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "start_index.append(j - 1)",
      "mutated_line": "start_index.append(j - -1)",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - -1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] * N for _ in range(21)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(21)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] * N for _ in range(19)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(19)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] * N for _ in range(0)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(0)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] * N for _ in range(1)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(1)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "up = [[None] * N for _ in range(20)]",
      "mutated_line": "up = [[None] * N for _ in range(-20)]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(-20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if p == -1:",
      "mutated_line": "if p == +1:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == +1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "up[i][j] = -1",
      "mutated_line": "up[i][j] = +1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = +1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if node == -1:",
      "mutated_line": "if node == -2:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -2:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if node == -1:",
      "mutated_line": "if node == -0:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -0:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if node == -1:",
      "mutated_line": "if node == -0:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -0:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if node == -1:",
      "mutated_line": "if node == --1:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == --1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "p = up[i - 1][j]",
      "mutated_line": "p = up[i + 1][j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i + 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "p = up[i - 1][j]",
      "mutated_line": "p = up[i * 1][j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i * 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if p == -1:",
      "mutated_line": "if p == -2:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -2:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if p == -1:",
      "mutated_line": "if p == -0:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -0:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if p == -1:",
      "mutated_line": "if p == -0:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -0:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if p == -1:",
      "mutated_line": "if p == --1:",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == --1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "up[i][j] = -1",
      "mutated_line": "up[i][j] = -2",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -2\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "up[i][j] = -1",
      "mutated_line": "up[i][j] = -0",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -0\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "up[i][j] = -1",
      "mutated_line": "up[i][j] = -0",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -0\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "up[i][j] = -1",
      "mutated_line": "up[i][j] = --1",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = --1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = up[i - 1][j]",
      "mutated_line": "p = up[i - 2][j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 2][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = up[i - 1][j]",
      "mutated_line": "p = up[i - 0][j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 0][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = up[i - 1][j]",
      "mutated_line": "p = up[i - 0][j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 0][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = up[i - 1][j]",
      "mutated_line": "p = up[i - -1][j]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - -1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "up[i][j] = up[i - 1][p]",
      "mutated_line": "up[i][j] = up[i + 1][p]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i + 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "up[i][j] = up[i - 1][p]",
      "mutated_line": "up[i][j] = up[i * 1][p]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i * 1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "up[i][j] = up[i - 1][p]",
      "mutated_line": "up[i][j] = up[i - 2][p]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 2][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "up[i][j] = up[i - 1][p]",
      "mutated_line": "up[i][j] = up[i - 0][p]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 0][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "up[i][j] = up[i - 1][p]",
      "mutated_line": "up[i][j] = up[i - 0][p]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - 0][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "up[i][j] = up[i - 1][p]",
      "mutated_line": "up[i][j] = up[i - -1][p]",
      "code": "def find_max_good_segment_length(nums, N, K, S):\n\n    def build(N, start_index):\n        up = [[None] * N for _ in range(20)]\n        up[0] = start_index\n        for i in range(1, 20):\n            for j in range(N):\n                p = up[i - 1][j]\n                if p == -1:\n                    up[i][j] = -1\n                else:\n                    up[i][j] = up[i - -1][p]\n        return up\n\n    def call(up, node, K):\n        (last, jump) = (node, 1)\n        for i in range(19):\n            if node == -1:\n                break\n            if K & jump:\n                node = up[i][node]\n            jump <<= 1\n        return last - node\n    (start_index, j, curr) = ([], 0, 0)\n    for i in range(N):\n        curr += nums[i]\n        while curr > S:\n            curr -= nums[j]\n            j += 1\n        start_index.append(j - 1)\n    up = build(N, start_index)\n    res = 0\n    for i in range(N - 1, -1, -1):\n        res = max(res, call(up, i, K))\n    return res"
    }
  ]
}