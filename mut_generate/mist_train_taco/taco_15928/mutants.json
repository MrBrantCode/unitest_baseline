{
  "task_id": "taco_15928",
  "entry_point": "calculate_minimum_total_sum",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a_list = [0] * n",
      "mutated_line": "a_list = [0] / n",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] / n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a_list = [0] * n",
      "mutated_line": "a_list = [0] + n",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] + n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "a_list = [0] * n",
      "mutated_line": "a_list = [0] ** n",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] ** n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "invalid = False",
      "mutated_line": "invalid = True",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = True\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while stack and (not invalid):",
      "mutated_line": "(cur_vertex, child_num) = stack.pop()",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack or not invalid:\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a_list[0] = sums[0]",
      "mutated_line": "a_list[1] = sums[0]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[1] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a_list[0] = sums[0]",
      "mutated_line": "a_list[-1] = sums[0]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[-1] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a_list[0] = sums[0]",
      "mutated_line": "a_list[1] = sums[0]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[1] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a_list[0] = sums[0]",
      "mutated_line": "a_list[0] = sums[1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[1]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a_list[0] = sums[0]",
      "mutated_line": "a_list[0] = sums[-1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[-1]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "a_list[0] = sums[0]",
      "mutated_line": "a_list[0] = sums[1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[1]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][0] = parent + 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent + 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][0] = parent * 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent * 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list or sums[cur_vertex] == -1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list or sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if child_num < len(cur_list):",
      "mutated_line": "if child_num <= len(cur_list):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num <= len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if child_num < len(cur_list):",
      "mutated_line": "if child_num >= len(cur_list):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num >= len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if child_num < len(cur_list):",
      "mutated_line": "if child_num != len(cur_list):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num != len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return +1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pc_list = [[0, []] for _ in range(n)]",
      "mutated_line": "pc_list = [[1, []] for _ in range(n)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[1, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pc_list = [[0, []] for _ in range(n)]",
      "mutated_line": "pc_list = [[-1, []] for _ in range(n)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[-1, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pc_list = [[0, []] for _ in range(n)]",
      "mutated_line": "pc_list = [[1, []] for _ in range(n)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[1, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "a_list = [0] * n",
      "mutated_line": "a_list = [1] * n",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [1] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "a_list = [0] * n",
      "mutated_line": "a_list = [-1] * n",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [-1] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "a_list = [0] * n",
      "mutated_line": "a_list = [1] * n",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [1] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][1] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][1] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][-1] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][-1] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][1] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][1] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][0] = parent - 2",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 2\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][0] = parent - 0",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 0\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][0] = parent - 0",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 0\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 1][0] = parent - -1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - -1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][1].append(vertex - 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex - 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][1].append(vertex * 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex * 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(1, 0)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(1, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(-1, 0)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(-1, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(1, 0)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(1, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(0, 1)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 1)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(0, -1)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, -1)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "stack = [(0, 0)]",
      "mutated_line": "stack = [(0, 1)]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 1)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parent = pc_list[cur_vertex][0]",
      "mutated_line": "parent = pc_list[cur_vertex][1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][1]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parent = pc_list[cur_vertex][0]",
      "mutated_line": "parent = pc_list[cur_vertex][-1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][-1]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parent = pc_list[cur_vertex][0]",
      "mutated_line": "parent = pc_list[cur_vertex][1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][1]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_list = pc_list[cur_vertex][1]",
      "mutated_line": "cur_list = pc_list[cur_vertex][2]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][2]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_list = pc_list[cur_vertex][1]",
      "mutated_line": "cur_list = pc_list[cur_vertex][0]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][0]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_list = pc_list[cur_vertex][1]",
      "mutated_line": "cur_list = pc_list[cur_vertex][0]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][0]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_list = pc_list[cur_vertex][1]",
      "mutated_line": "cur_list = pc_list[cur_vertex][-1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][-1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list and sums[cur_vertex] != -1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] != -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a_list[cur_vertex] = 0",
      "mutated_line": "a_list[cur_vertex] = 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 1\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a_list[cur_vertex] = 0",
      "mutated_line": "a_list[cur_vertex] = -1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = -1\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a_list[cur_vertex] = 0",
      "mutated_line": "a_list[cur_vertex] = 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 1\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -1 or child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 or child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -2\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -0\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -0\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return --1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex - 1][0] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex - 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex * 1][0] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex * 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][1].append(vertex + 2)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 2)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][1].append(vertex + 0)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 0)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][1].append(vertex + 0)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 0)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][1].append(vertex + -1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + -1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list and sums[cur_vertex] == +1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == +1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] != -1 and child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] != -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -1 and child_num != 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num != 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if min_sum < sums[parent]:",
      "mutated_line": "if min_sum <= sums[parent]:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum <= sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if min_sum < sums[parent]:",
      "mutated_line": "if min_sum >= sums[parent]:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum >= sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if min_sum < sums[parent]:",
      "mutated_line": "if min_sum != sums[parent]:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum != sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 or cur_vertex != 0 or child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 or cur_vertex != 0 or child_num == 0:\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "a_list[cur_vertex] += -sums[grandparent]",
      "mutated_line": "a_list[cur_vertex] -= -sums[grandparent]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] -= -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 2][0] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 2][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 0][0] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 0][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + 0][0] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 0][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pc_list[vertex + 1][0] = parent - 1",
      "mutated_line": "pc_list[vertex + -1][0] = parent - 1",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + -1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][2].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][2].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][0].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][0].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][0].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][0].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 1][-1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][-1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list and sums[cur_vertex] == -2:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -2:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list and sums[cur_vertex] == -0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -0:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list and sums[cur_vertex] == -0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -0:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not cur_list and sums[cur_vertex] == -1:",
      "mutated_line": "if not cur_list and sums[cur_vertex] == --1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == --1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == +1 and child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == +1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -1 and child_num == 1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 1:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -1 and child_num == -1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == -1:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -1 and child_num == 1:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 1:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "invalid = True",
      "mutated_line": "invalid = False",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = False\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a_list[cur_vertex] = min_sum - sums[parent]",
      "mutated_line": "a_list[cur_vertex] = min_sum + sums[parent]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum + sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a_list[cur_vertex] = min_sum - sums[parent]",
      "mutated_line": "a_list[cur_vertex] = min_sum * sums[parent]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum * sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] == -1 and cur_vertex != 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] == -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex == 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex == 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num != 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num != 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]",
      "mutated_line": "a_list[cur_vertex] = sums[cur_vertex] + a_list[parent]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] + a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]",
      "mutated_line": "a_list[cur_vertex] = sums[cur_vertex] * a_list[parent]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] * a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "a_list[cur_vertex] += -sums[grandparent]",
      "mutated_line": "a_list[cur_vertex] += +sums[grandparent]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += +sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "stack.append((cur_vertex, child_num + 1))",
      "mutated_line": "stack.append((cur_vertex, child_num - 1))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num - 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "stack.append((cur_vertex, child_num + 1))",
      "mutated_line": "stack.append((cur_vertex, child_num * 1))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num * 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((cur_list[child_num], 0))",
      "mutated_line": "stack.append((cur_list[child_num], 1))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 1))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((cur_list[child_num], 0))",
      "mutated_line": "stack.append((cur_list[child_num], -1))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], -1))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "stack.append((cur_list[child_num], 0))",
      "mutated_line": "stack.append((cur_list[child_num], 1))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 1))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent + 1][1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent + 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent * 1][1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent * 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -2 and child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -2 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -0 and child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -0 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == -0 and child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -0 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif sums[cur_vertex] == -1 and child_num == 0:",
      "mutated_line": "elif sums[cur_vertex] == --1 and child_num == 0:",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == --1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != +1 and cur_vertex != 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != +1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != 1 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 1 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != -1 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != -1 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != 1 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 1 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 1):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 1):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == -1):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == -1):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 1):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 1):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "grandparent = pc_list[parent][0]",
      "mutated_line": "grandparent = pc_list[parent][1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][1]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "grandparent = pc_list[parent][0]",
      "mutated_line": "grandparent = pc_list[parent][-1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][-1]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "grandparent = pc_list[parent][0]",
      "mutated_line": "grandparent = pc_list[parent][1]",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][1]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack.append((cur_vertex, child_num + 1))",
      "mutated_line": "stack.append((cur_vertex, child_num + 2))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 2))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack.append((cur_vertex, child_num + 1))",
      "mutated_line": "stack.append((cur_vertex, child_num + 0))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 0))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack.append((cur_vertex, child_num + 1))",
      "mutated_line": "stack.append((cur_vertex, child_num + 0))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 0))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "stack.append((cur_vertex, child_num + 1))",
      "mutated_line": "stack.append((cur_vertex, child_num + -1))",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + -1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 2][1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 2][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 0][1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 0][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - 0][1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 0][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pc_list[parent - 1][1].append(vertex + 1)",
      "mutated_line": "pc_list[parent - -1][1].append(vertex + 1)",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - -1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -2 and cur_vertex != 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -2 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -0 and cur_vertex != 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -0 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != -0 and cur_vertex != 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != -0 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif sums[cur_vertex] != -1 and cur_vertex != 0 and (child_num == 0):",
      "mutated_line": "elif sums[cur_vertex] != --1 and cur_vertex != 0 and (child_num == 0):",
      "code": "def calculate_minimum_total_sum(n, parents, sums):\n    pc_list = [[0, []] for _ in range(n)]\n    a_list = [0] * n\n    a_list[0] = sums[0]\n    for (vertex, parent) in enumerate(parents):\n        pc_list[vertex + 1][0] = parent - 1\n        pc_list[parent - 1][1].append(vertex + 1)\n    stack = [(0, 0)]\n    invalid = False\n    while stack and (not invalid):\n        (cur_vertex, child_num) = stack.pop()\n        parent = pc_list[cur_vertex][0]\n        cur_list = pc_list[cur_vertex][1]\n        if not cur_list and sums[cur_vertex] == -1:\n            a_list[cur_vertex] = 0\n        elif sums[cur_vertex] == -1 and child_num == 0:\n            min_sum = min([sums[child] for child in cur_list])\n            if min_sum < sums[parent]:\n                invalid = True\n                break\n            else:\n                a_list[cur_vertex] = min_sum - sums[parent]\n        elif sums[cur_vertex] != --1 and cur_vertex != 0 and (child_num == 0):\n            grandparent = pc_list[parent][0]\n            a_list[cur_vertex] = sums[cur_vertex] - a_list[parent]\n            a_list[cur_vertex] += -sums[grandparent]\n        if child_num < len(cur_list):\n            stack.append((cur_vertex, child_num + 1))\n            stack.append((cur_list[child_num], 0))\n    if invalid:\n        return -1\n    else:\n        return sum(a_list)"
    }
  ]
}