{
  "task_id": "taco_5421",
  "entry_point": "find_closest_bean_hardness",
  "mutant_count": 197,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a_idx = 0",
      "mutated_line": "a_idx = 1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 1\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a_idx = 0",
      "mutated_line": "a_idx = -1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = -1\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a_idx = 0",
      "mutated_line": "a_idx = 1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 1\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "Ans = [0] * len(Q)",
      "mutated_line": "Ans = [0] / len(Q)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] / len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "Ans = [0] * len(Q)",
      "mutated_line": "Ans = [0] + len(Q)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] + len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "Ans = [0] * len(Q)",
      "mutated_line": "Ans = [0] ** len(Q)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] ** len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] / N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] / N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] + N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] + N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] ** N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] ** N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while a_idx < N:",
      "mutated_line": "while a_idx <= N:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx <= N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while a_idx < N:",
      "mutated_line": "while a_idx >= N:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx >= N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while a_idx < N:",
      "mutated_line": "while a_idx != N:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx != N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] / (elem_size * 2)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] / (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] + elem_size * 2",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] + elem_size * 2\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] ** (elem_size * 2)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] ** (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while l < r:",
      "mutated_line": "while l <= r:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l <= r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while l < r:",
      "mutated_line": "while l >= r:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l >= r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while l < r:",
      "mutated_line": "while l != r:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l != r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "k = self.elem_size + i",
      "mutated_line": "k = self.elem_size - i",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size - i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "k = self.elem_size + i",
      "mutated_line": "k = self.elem_size * i",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size * i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i >= 1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i >= 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i <= 1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i <= 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i != 1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i != 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, +1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, +1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 31, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 31, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 29, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 29, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 0, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 0, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 1, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 1, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << -30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << -30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 2 << 30, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 2 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 0 << 30, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 0 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 0 << 30, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 0 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, -1 << 30, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, -1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 1 << 31, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 31, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 1 << 29, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 29, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 1 << 0, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 0, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 1 << 1, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 1, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "seg2 = SegmentTree(A, 1 << 30, min)",
      "mutated_line": "seg2 = SegmentTree(A, 1 << -30, min)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << -30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "Ans = [0] * len(Q)",
      "mutated_line": "Ans = [1] * len(Q)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [1] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "Ans = [0] * len(Q)",
      "mutated_line": "Ans = [-1] * len(Q)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [-1] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "Ans = [0] * len(Q)",
      "mutated_line": "Ans = [1] * len(Q)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [1] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if a0 > d:",
      "mutated_line": "if a0 >= d:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 >= d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if a0 > d:",
      "mutated_line": "if a0 <= d:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 <= d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if a0 > d:",
      "mutated_line": "if a0 != d:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 != d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "a_idx += 1",
      "mutated_line": "a_idx -= 1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx -= 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r + 1) + d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) + d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r + 1) * d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) * d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r + 1) + d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) + d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r + 1) * d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) * d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 2 << ceil(log(real_size, 2))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 2 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 0 << ceil(log(real_size, 2))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 0 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 0 << ceil(log(real_size, 2))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 0 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = -1 << ceil(log(real_size, 2))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = -1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size / 2)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size / 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size + 2)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size + 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * elem_size ** 2",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * elem_size ** 2\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size + 1, 0, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size + 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size * 1, 0, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size * 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 1, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 1, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, -1, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, -1, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 1, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 1, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 0, +1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, +1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(l, r) = (x + self.elem_size, y + self.elem_size)",
      "mutated_line": "(l, r) = (x - self.elem_size, y + self.elem_size)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x - self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(l, r) = (x + self.elem_size, y + self.elem_size)",
      "mutated_line": "(l, r) = (x * self.elem_size, y + self.elem_size)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x * self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(l, r) = (x + self.elem_size, y + self.elem_size)",
      "mutated_line": "(l, r) = (x + self.elem_size, y - self.elem_size)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y - self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(l, r) = (x + self.elem_size, y + self.elem_size)",
      "mutated_line": "(l, r) = (x + self.elem_size, y * self.elem_size)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y * self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if l & 1:",
      "mutated_line": "if l | 1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l | 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "l += 1",
      "mutated_line": "l -= 1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l -= 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r & 1:",
      "mutated_line": "if r | 1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r | 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "r -= 1",
      "mutated_line": "r += 1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r += 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i > 2:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 2:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i > 0:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 0:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i > 0:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 0:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while i > 1:",
      "mutated_line": "while i > -1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > -1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i >>= 1",
      "mutated_line": "i >>= 2",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 2\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i >>= 1",
      "mutated_line": "i >>= 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 0\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i >>= 1",
      "mutated_line": "i >>= 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 0\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "i >>= 1",
      "mutated_line": "i >>= -1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= -1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -2 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -2 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -0 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -0 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, -0 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -0 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 30] * N, --1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, --1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "Q.sort(key=itemgetter(2))",
      "mutated_line": "Q.sort(key=itemgetter(3))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(3))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "Q.sort(key=itemgetter(2))",
      "mutated_line": "Q.sort(key=itemgetter(1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(1))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "Q.sort(key=itemgetter(2))",
      "mutated_line": "Q.sort(key=itemgetter(0))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(0))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "Q.sort(key=itemgetter(2))",
      "mutated_line": "Q.sort(key=itemgetter(1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(1))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "Q.sort(key=itemgetter(2))",
      "mutated_line": "Q.sort(key=itemgetter(-2))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(-2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A = sorted(zip(A, range(N)), key=itemgetter(0))",
      "mutated_line": "A = sorted(zip(A, range(N)), key=itemgetter(1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(1))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A = sorted(zip(A, range(N)), key=itemgetter(0))",
      "mutated_line": "A = sorted(zip(A, range(N)), key=itemgetter(-1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(-1))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A = sorted(zip(A, range(N)), key=itemgetter(0))",
      "mutated_line": "A = sorted(zip(A, range(N)), key=itemgetter(1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(1))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "a_idx += 1",
      "mutated_line": "a_idx += 2",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 2\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "a_idx += 1",
      "mutated_line": "a_idx += 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 0\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "a_idx += 1",
      "mutated_line": "a_idx += 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 0\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "a_idx += 1",
      "mutated_line": "a_idx += -1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += -1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size * 3)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 3)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size * 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 1)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size * 0)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 0)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size * 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 1)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.tree = tree = [default] * (elem_size * 2)",
      "mutated_line": "self.tree = tree = [default] * (elem_size * -2)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * -2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tree[elem_size:elem_size + real_size] = a",
      "mutated_line": "tree[elem_size:elem_size - real_size] = a",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size - real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "tree[elem_size:elem_size + real_size] = a",
      "mutated_line": "tree[elem_size:elem_size * real_size] = a",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size * real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 2, 0, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 2, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 0, 0, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 0, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 0, 0, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 0, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - -1, 0, -1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - -1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 0, -2):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -2):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 0, -0):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -0):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 0, -0):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -0):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(elem_size - 1, 0, -1):",
      "mutated_line": "for i in range(elem_size - 1, 0, --1):",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, --1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l & 1:",
      "mutated_line": "if l & 2:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 2:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l & 1:",
      "mutated_line": "if l & 0:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 0:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l & 1:",
      "mutated_line": "if l & 0:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 0:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if l & 1:",
      "mutated_line": "if l & -1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & -1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l += 1",
      "mutated_line": "l += 2",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 2\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 0\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 0\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l += 1",
      "mutated_line": "l += -1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += -1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r & 1:",
      "mutated_line": "if r & 2:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 2:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r & 1:",
      "mutated_line": "if r & 0:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 0:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r & 1:",
      "mutated_line": "if r & 0:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 0:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r & 1:",
      "mutated_line": "if r & -1:",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & -1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r -= 1",
      "mutated_line": "r -= 2",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 2\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r -= 1",
      "mutated_line": "r -= 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 0\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r -= 1",
      "mutated_line": "r -= 0",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 0\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "r -= 1",
      "mutated_line": "r -= -1",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= -1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([+1 << 30] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([+1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 31] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 31] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 29] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 29] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 0] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 0] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << 1] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 1] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-1 << -30] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << -30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r - 1) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r - 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r * 1) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r * 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r - 1) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r - 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r * 1) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r * 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 3))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 3))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 1))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 0))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 0))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 1))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 1))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, 2))",
      "mutated_line": "self.elem_size = elem_size = 1 << ceil(log(real_size, -2))",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, -2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) - 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) - 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) * 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) * 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 2, r >> 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 2, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 0, r >> 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 0, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 0, r >> 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 0, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> -1, r >> 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> -1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 1, r >> 2)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 2)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 1, r >> 0)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 0)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 1, r >> 0)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 0)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(l, r) = (l >> 1, r >> 1)",
      "mutated_line": "(l, r) = (l >> 1, r >> -1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> -1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) - 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) - 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) * 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) * 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-2 << 30] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-2 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-0 << 30] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-0 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([-0 << 30] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-0 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)",
      "mutated_line": "seg1 = SegmentTree([--1 << 30] * N, -1 << 30, max)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([--1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 2 << 30)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 2 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 0 << 30)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 0 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 0 << 30)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 0 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, -1 << 30)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, -1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 1 << 31)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 31)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 1 << 29)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 29)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 1 << 0)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 0)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 1 << 1)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 1)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "seg2.set_value(a1, 1 << 30)",
      "mutated_line": "seg2.set_value(a1, 1 << -30)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << -30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r + 2) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 2) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r + 0) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 0) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r + 0) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 0) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "an1 = abs(seg1.get_value(l, r + 1) - d)",
      "mutated_line": "an1 = abs(seg1.get_value(l, r + -1) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + -1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r + 2) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 2) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r + 0) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 0) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r + 0) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 0) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "an2 = abs(seg2.get_value(l, r + 1) - d)",
      "mutated_line": "an2 = abs(seg2.get_value(l, r + -1) - d)",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + -1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 2], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 2], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 0], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 0], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 0], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 0], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << -1], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << -1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 2])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 2])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 0])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 0])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 0])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 0])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + -1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + -1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 2], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 2], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 0], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 0], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 0], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 0], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << -1], tree[(i << 1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << -1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 2])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 2])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 0])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 0])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 0])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 0])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + -1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + -1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 2) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 2) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 0) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 0) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 0) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 0) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << -1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << -1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 2) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 2) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 0) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 0) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << 0) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << 0) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "tree[i] = op(tree[i << 1], tree[(i << 1) + 1])",
      "mutated_line": "tree[i] = op(tree[i << 1], tree[(i << -1) + 1])",
      "code": "def find_closest_bean_hardness(N: int, A: list, Q: list) -> list:\n\n    class SegmentTree(object):\n\n        def __init__(self, a: list, default: int, op):\n            from math import ceil, log\n            real_size = len(a)\n            self.elem_size = elem_size = 1 << ceil(log(real_size, 2))\n            self.tree = tree = [default] * (elem_size * 2)\n            tree[elem_size:elem_size + real_size] = a\n            self.default = default\n            self.op = op\n            for i in range(elem_size - 1, 0, -1):\n                tree[i] = op(tree[i << 1], tree[(i << 1) + 1])\n\n        def get_value(self, x: int, y: int):\n            (l, r) = (x + self.elem_size, y + self.elem_size)\n            (tree, result, op) = (self.tree, self.default, self.op)\n            while l < r:\n                if l & 1:\n                    result = op(tree[l], result)\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    result = op(tree[r], result)\n                (l, r) = (l >> 1, r >> 1)\n            return result\n\n        def set_value(self, i: int, value: int):\n            k = self.elem_size + i\n            self.tree[k] = value\n            self.update(k)\n\n        def update(self, i: int):\n            (op, tree) = (self.op, self.tree)\n            while i > 1:\n                i >>= 1\n                tree[i] = op(tree[i << 1], tree[(i << -1) + 1])\n    seg1 = SegmentTree([-1 << 30] * N, -1 << 30, max)\n    seg2 = SegmentTree(A, 1 << 30, min)\n    from operator import itemgetter\n    Q.sort(key=itemgetter(2))\n    A = sorted(zip(A, range(N)), key=itemgetter(0))\n    a_idx = 0\n    Ans = [0] * len(Q)\n    for (l, r, d, q_idx) in Q:\n        while a_idx < N:\n            (a0, a1) = A[a_idx]\n            if a0 > d:\n                break\n            else:\n                seg1.set_value(a1, a0)\n                seg2.set_value(a1, 1 << 30)\n                a_idx += 1\n        an1 = abs(seg1.get_value(l, r + 1) - d)\n        an2 = abs(seg2.get_value(l, r + 1) - d)\n        Ans[q_idx] = min(an1, an2)\n    return Ans"
    }
  ]
}