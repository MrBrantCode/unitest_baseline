{
  "task_id": "taco_2235",
  "entry_point": "find_longest_increasing_sequence",
  "mutant_count": 188,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = ''",
      "mutated_line": "ans = 'MUTATED'",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = 'MUTATED'\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "current = 0",
      "mutated_line": "current = 1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 1\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "current = 0",
      "mutated_line": "current = -1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = -1\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "current = 0",
      "mutated_line": "current = 1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 1\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] or current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] or current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current <= sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current <= sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current >= sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current >= sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current != sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current != sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current <= sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current >= sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current != sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current != sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] or i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] or i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] or current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] or current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += 'L'",
      "mutated_line": "ans -= 'L'",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans -= 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] != sl[-1] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] != sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i == n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i == n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if l > r:",
      "mutated_line": "if l >= r:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l >= r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if l > r:",
      "mutated_line": "if l <= r:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l <= r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if l > r:",
      "mutated_line": "if l != r:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l != r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "ans += 'L' * l",
      "mutated_line": "ans -= 'L' * l",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans -= 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "ans += 'R' * r",
      "mutated_line": "ans -= 'R' * r",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans -= 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] or sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] or sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "ans += 'L'",
      "mutated_line": "ans -= 'L'",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans -= 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current <= sl[0] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current <= sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current >= sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current != sl[0] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current != sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current > sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current < sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current == sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current == sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 'L'",
      "mutated_line": "ans += ''",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += ''\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] or current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] or current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "ans += 'R'",
      "mutated_line": "ans -= 'R'",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans -= 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[1] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[1] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[-1] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[-1] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[1] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[1] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current < sl[+1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[+1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i != n + 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n + 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i != n * 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n * 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (2, 1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (2, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (0, 1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (0, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (0, 1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (0, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (-1, 1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (-1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, 2)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 2)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, 0)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 0)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, 0)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 0)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(l, r) = (1, 1)",
      "mutated_line": "(l, r) = (1, -1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, -1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) + 1):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) + 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) * 1):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) * 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] <= sl[j + 1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] <= sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] >= sl[j + 1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] >= sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] != sl[j + 1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] != sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "l += 1",
      "mutated_line": "l -= 1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l -= 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) + 1):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) + 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) * 1):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) * 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] <= sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] <= sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] >= sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] >= sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] != sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] != sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "r += 1",
      "mutated_line": "r -= 1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r -= 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += 'L' * l",
      "mutated_line": "ans += 'L' / l",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' / l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += 'L' * l",
      "mutated_line": "ans += 'L' + l",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' + l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans += 'L' * l",
      "mutated_line": "ans += 'L' ** l",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' ** l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += 'R' * r",
      "mutated_line": "ans += 'R' / r",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' / r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += 'R' * r",
      "mutated_line": "ans += 'R' + r",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' + r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += 'R' * r",
      "mutated_line": "ans += 'R' ** r",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' ** r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current <= sl[0] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current <= sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current >= sl[0] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current >= sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current != sl[0] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current != sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] < sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] > sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] == sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] == sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans += 'L'",
      "mutated_line": "ans += ''",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += ''\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] or sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] or sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "ans += 'R'",
      "mutated_line": "ans -= 'R'",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans -= 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current = sl.pop(0)",
      "mutated_line": "current = sl.pop(1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(1)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current = sl.pop(0)",
      "mutated_line": "current = sl.pop(-1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(-1)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "current = sl.pop(0)",
      "mutated_line": "current = sl.pop(1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(1)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current > sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current > sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current < sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current < sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current == sl[0] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current == sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current <= sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current >= sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current != sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current != sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans += 'R'",
      "mutated_line": "ans += ''",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += ''\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current < sl[-2]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-2]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current < sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-0]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current < sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-0]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if current < sl[0] and current < sl[-1]:",
      "mutated_line": "if current < sl[0] and current < sl[--1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[--1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[1] == sl[-1] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[1] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[-1] == sl[-1] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[-1] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[1] == sl[-1] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[1] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[+1] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[+1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i != n - 2:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 2:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i != n - 0:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 0:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i != n - 0:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 0:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-1] and i != n - -1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - -1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - 2):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 2):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - 0):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 0):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - 0):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 0):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - -1):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - -1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l += 1",
      "mutated_line": "l += 2",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 2\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 0\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l += 1",
      "mutated_line": "l += 0",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 0\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "l += 1",
      "mutated_line": "l += -1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += -1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - 2):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 2):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - 0):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 0):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - 0):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 0):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for j in range(len(sl) - 1):",
      "mutated_line": "for j in range(len(sl) - -1):",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - -1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r += 1",
      "mutated_line": "r += 2",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 2\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 0\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 0\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r += 1",
      "mutated_line": "r += -1",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += -1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans += 'L' * l",
      "mutated_line": "ans += '' * l",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += '' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans += 'R' * r",
      "mutated_line": "ans += '' * r",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += '' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "current = sl.pop(0)",
      "mutated_line": "current = sl.pop(1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(1)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "current = sl.pop(0)",
      "mutated_line": "current = sl.pop(-1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(-1)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "current = sl.pop(0)",
      "mutated_line": "current = sl.pop(1)",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(1)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current <= sl[-1] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current <= sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current >= sl[-1] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current >= sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current != sl[-1] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current != sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] >= sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] <= sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] != sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] != sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += 'R'",
      "mutated_line": "ans += ''",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += ''\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[1] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[1] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[-1] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[-1] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[1] and current >= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[1] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current >= sl[+1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[+1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-2] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-2] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-0] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-0] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[-0] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-0] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if sl[0] == sl[-1] and i != n - 1:",
      "mutated_line": "if sl[0] == sl[--1] and i != n - 1:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[--1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] < sl[j - 1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j - 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] < sl[j * 1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j * 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[+(j + 1)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[+(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[+(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[+(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[1] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[1] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[-1] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[1] and sl[0] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[1] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[1] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[1] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[-1] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[-1] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[1] <= sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[1] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] <= sl[+1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[+1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current >= sl[-2]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-2]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current >= sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-0]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current >= sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-0]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif current < sl[0] and current >= sl[-1]:",
      "mutated_line": "elif current < sl[0] and current >= sl[--1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[--1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[1] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[1] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[-1] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[-1] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[1] and current < sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[1] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current < sl[+1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[+1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] < sl[j + 2]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 2]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] < sl[j + 0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 0]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] < sl[j + 0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 0]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if sl[j] < sl[j + 1]:",
      "mutated_line": "if sl[j] < sl[j + -1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + -1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j - 1)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j - 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j * 1)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j * 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j - 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j - 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j * 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j * 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] <= sl[-2]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-2]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] <= sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-0]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] <= sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-0]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif current < sl[0] and sl[0] <= sl[-1]:",
      "mutated_line": "elif current < sl[0] and sl[0] <= sl[--1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[--1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[+1] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[+1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[1] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[1] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[-1] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[-1] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[1] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[1] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] > sl[+1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[+1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current < sl[-2]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-2]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current < sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-0]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current < sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-0]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif current >= sl[0] and current < sl[-1]:",
      "mutated_line": "elif current >= sl[0] and current < sl[--1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[--1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 2)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 2)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 0)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 0)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 0)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 0)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + -1)] < sl[-(j + 2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + -1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j + 3)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 3)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j + 1)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 1)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j + 0)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 0)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j + 1)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 1)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sl[-(j + 1)] < sl[-(j + 2)]:",
      "mutated_line": "if sl[-(j + 1)] < sl[-(j + -2)]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + -2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-2] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-2] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-0] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-0] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-0] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-0] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[--1] and sl[0] > sl[-1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[--1] and sl[0] > sl[-1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] > sl[-2]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-2]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] > sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-0]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] > sl[-0]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[-0]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif current < sl[-1] and sl[0] > sl[-1]:",
      "mutated_line": "elif current < sl[-1] and sl[0] > sl[--1]:",
      "code": "def find_longest_increasing_sequence(n, a):\n    ans = ''\n    current = 0\n    sl = a[:]\n    for i in range(n):\n        if current < sl[0] and current < sl[-1]:\n            if sl[0] == sl[-1] and i != n - 1:\n                (l, r) = (1, 1)\n                for j in range(len(sl) - 1):\n                    if sl[j] < sl[j + 1]:\n                        l += 1\n                    else:\n                        break\n                for j in range(len(sl) - 1):\n                    if sl[-(j + 1)] < sl[-(j + 2)]:\n                        r += 1\n                    else:\n                        break\n                if l > r:\n                    ans += 'L' * l\n                else:\n                    ans += 'R' * r\n                break\n            elif current < sl[0] and sl[0] <= sl[-1]:\n                ans += 'L'\n                current = sl.pop(0)\n            elif current < sl[-1] and sl[0] > sl[--1]:\n                ans += 'R'\n                current = sl.pop()\n        elif current < sl[0] and current >= sl[-1]:\n            ans += 'L'\n            current = sl.pop(0)\n        elif current >= sl[0] and current < sl[-1]:\n            ans += 'R'\n            current = sl.pop()\n        else:\n            break\n    k = len(ans)\n    return (k, ans)"
    }
  ]
}