{
  "task_id": "taco_4152",
  "entry_point": "find_minimum_jumps",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] / (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] / (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] + (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] + (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] ** (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] ** (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] / (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] / (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] + (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] + (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] ** (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] ** (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited[start] = True",
      "mutated_line": "visited[start] = False",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = False\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[start] = 0",
      "mutated_line": "distance[start] = 1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 1\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[start] = 0",
      "mutated_line": "distance[start] = -1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = -1\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distance[start] = 0",
      "mutated_line": "distance[start] = 1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 1\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N - 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N - 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N * 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N * 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] * (N - 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N - 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] * (N * 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N * 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[target] if visited[target] else 0",
      "mutated_line": "return distance[target] if visited[target] else 1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[target] if visited[target] else 0",
      "mutated_line": "return distance[target] if visited[target] else -1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return distance[target] if visited[target] else 0",
      "mutated_line": "return distance[target] if visited[target] else 1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [True] * (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [True] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 2)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 2)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 0)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 0)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 0)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 0)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + -1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + -1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] * (N + 2)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 2)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] * (N + 0)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 0)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] * (N + 0)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 0)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('inf')] * (N + -1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + -1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(2, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(0, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(0, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(-1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N - 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N * 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distance = [float('inf')] * (N + 1)",
      "mutated_line": "distance = [float('')] * (N + 1)",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[neighbor] = True",
      "mutated_line": "visited[neighbor] = False",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = False\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "distance[neighbor] = distance[current] + 1",
      "mutated_line": "distance[neighbor] = distance[current] - 1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] - 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "distance[neighbor] = distance[current] + 1",
      "mutated_line": "distance[neighbor] = distance[current] * 1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] * 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 2)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 0)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 0)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adjacency_list = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (a, b) in close_pairs:",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + -1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 1\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "distance[neighbor] = distance[current] + 1",
      "mutated_line": "distance[neighbor] = distance[current] + 2",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 2\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "distance[neighbor] = distance[current] + 1",
      "mutated_line": "distance[neighbor] = distance[current] + 0",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 0\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "distance[neighbor] = distance[current] + 1",
      "mutated_line": "distance[neighbor] = distance[current] + 0",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + 0\n    return distance[target] if visited[target] else 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "distance[neighbor] = distance[current] + 1",
      "mutated_line": "distance[neighbor] = distance[current] + -1",
      "code": "from collections import deque\n\ndef find_minimum_jumps(N, M, close_pairs, start, target):\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for (a, b) in close_pairs:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n    queue = deque([start])\n    visited = [False] * (N + 1)\n    distance = [float('inf')] * (N + 1)\n    visited[start] = True\n    distance[start] = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in adjacency_list[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                distance[neighbor] = distance[current] + -1\n    return distance[target] if visited[target] else 0"
    }
  ]
}