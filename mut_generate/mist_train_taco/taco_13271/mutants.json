{
  "task_id": "taco_13271",
  "entry_point": "find_minimal_charger_power",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "turn_data = [0] * n",
      "mutated_line": "turn_data = [0] / n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] / n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "turn_data = [0] * n",
      "mutated_line": "turn_data = [0] + n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] + n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "turn_data = [0] * n",
      "mutated_line": "turn_data = [0] ** n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] ** n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = 0",
      "mutated_line": "b = 2 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 1\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = 0",
      "mutated_line": "b = 2 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = -1\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = 0",
      "mutated_line": "b = 2 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 1\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 / 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 / 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 + 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 + 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 ** 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 ** 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while a < b:",
      "mutated_line": "while a <= b:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a <= b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while a < b:",
      "mutated_line": "while a >= b:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a >= b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while a < b:",
      "mutated_line": "while a != b:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a != b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b != 2 * 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b != 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "Binv = [1.0 / b for b in power_usage]",
      "mutated_line": "Binv = [1.0 * b for b in power_usage]",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 * b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "Binv = [1.0 / b for b in power_usage]",
      "mutated_line": "Binv = [1.0 // b for b in power_usage]",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 // b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 3 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 3 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 1 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 1 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 0 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 0 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 1 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 1 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = -2 * 10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = -2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * (10 * 12)",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * (10 * 12)\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * (10 + 12)",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * (10 + 12)\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) / 2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) / 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) * 2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) * 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = 1.0 / c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 / c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = 1.0 + c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 + c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = 1.0 ** c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 ** c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "last_updated = [0] * n",
      "mutated_line": "last_updated = [0] / n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] / n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "last_updated = [0] * n",
      "mutated_line": "last_updated = [0] + n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] + n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "last_updated = [0] * n",
      "mutated_line": "last_updated = [0] ** n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] ** n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "failed = False",
      "mutated_line": "failed = True",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = True\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "updater_ind = 0",
      "mutated_line": "updater_ind = 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 1\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "updater_ind = 0",
      "mutated_line": "updater_ind = -1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = -1\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "updater_ind = 0",
      "mutated_line": "updater_ind = 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 1\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] -= x - power_usage[ind] * (turn - last_updated[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] -= x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 / 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 / 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 + 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 + 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 ** 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 ** 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return +1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Binv = [1.0 / b for b in power_usage]",
      "mutated_line": "Binv = [2.0 / b for b in power_usage]",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [2.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Binv = [1.0 / b for b in power_usage]",
      "mutated_line": "Binv = [0.0 / b for b in power_usage]",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [0.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Binv = [1.0 / b for b in power_usage]",
      "mutated_line": "Binv = [0 / b for b in power_usage]",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Binv = [1.0 / b for b in power_usage]",
      "mutated_line": "Binv = [-1.0 / b for b in power_usage]",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [-1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "turn_data = [0] * n",
      "mutated_line": "turn_data = [1] * n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [1] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "turn_data = [0] * n",
      "mutated_line": "turn_data = [-1] * n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [-1] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "turn_data = [0] * n",
      "mutated_line": "turn_data = [1] * n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [1] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t = int(a * binv)",
      "mutated_line": "t = int(a / binv)",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a / binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t = int(a * binv)",
      "mutated_line": "t = int(a + binv)",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a + binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t = int(a * binv)",
      "mutated_line": "t = int(a ** binv)",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a ** binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 11 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 11 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 9 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 9 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 0 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 0 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 1 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 1 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * -10 ** 12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * -10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 10 ** 13",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 13\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 10 ** 11",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 11\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 10 ** 0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 0\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 10 ** 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 1\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = 2 * 10**12",
      "mutated_line": "b = 2 * 10 ** -12",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** -12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a - b) // 2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a - b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = a * b // 2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = a * b // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) // 3",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 3\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) // 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 1\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) // 0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 0\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) // 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 1\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = (a + b) // 2",
      "mutated_line": "c = (a + b) // -2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // -2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = 2.0 * c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 2.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = 0.0 * c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 0.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = 0 * c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = 1.0 * c",
      "mutated_line": "x = -1.0 * c",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = -1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if turn_data[i] < k:",
      "mutated_line": "if turn_data[i] <= k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] <= k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if turn_data[i] < k:",
      "mutated_line": "if turn_data[i] >= k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] >= k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if turn_data[i] < k:",
      "mutated_line": "if turn_data[i] != k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] != k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "while updater_ind < k and (not updater[updater_ind]):",
      "mutated_line": "while updater_ind < k or not updater[updater_ind]:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k or not updater[updater_ind]:\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "updater_ind += 1",
      "mutated_line": "updater_ind -= 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind -= 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if updater_ind == k:",
      "mutated_line": "if updater_ind != k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind != k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if turn > val:",
      "mutated_line": "if turn >= val:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn >= val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if turn > val:",
      "mutated_line": "if turn <= val:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn <= val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if turn > val:",
      "mutated_line": "if turn != val:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn != val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x + power_usage[ind] * (turn - last_updated[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x + power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x * (power_usage[ind] * (turn - last_updated[ind]))",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x * (power_usage[ind] * (turn - last_updated[ind]))\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "next_update = turn + int(charge[ind] * Binv[ind])",
      "mutated_line": "next_update = turn - int(charge[ind] * Binv[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn - int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "next_update = turn + int(charge[ind] * Binv[ind])",
      "mutated_line": "next_update = turn * int(charge[ind] * Binv[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn * int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if next_update < k:",
      "mutated_line": "if next_update <= k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update <= k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if next_update < k:",
      "mutated_line": "if next_update >= k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update >= k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if next_update < k:",
      "mutated_line": "if next_update != k:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update != k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "a = c + 1",
      "mutated_line": "a = c - 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c - 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "a = c + 1",
      "mutated_line": "a = c * 1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c * 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 3 * 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 3 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 1 * 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 1 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 0 * 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 0 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 1 * 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 1 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == -2 * 10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == -2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * (10 * 12):",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * (10 * 12):\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * (10 + 12):",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * (10 + 12):\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -2\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -0\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -0\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return --1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "last_updated = [0] * n",
      "mutated_line": "last_updated = [1] * n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [1] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "last_updated = [0] * n",
      "mutated_line": "last_updated = [-1] * n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [-1] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "last_updated = [0] * n",
      "mutated_line": "last_updated = [1] * n",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [1] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while updater_ind < k and (not updater[updater_ind]):",
      "mutated_line": "while updater_ind <= k and (not updater[updater_ind]):",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind <= k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while updater_ind < k and (not updater[updater_ind]):",
      "mutated_line": "while updater_ind >= k and (not updater[updater_ind]):",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind >= k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while updater_ind < k and (not updater[updater_ind]):",
      "mutated_line": "while updater_ind != k and (not updater[updater_ind]):",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind != k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "updater_ind += 1",
      "mutated_line": "updater_ind += 2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 2\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "updater_ind += 1",
      "mutated_line": "updater_ind += 0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 0\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "updater_ind += 1",
      "mutated_line": "updater_ind += 0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 0\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "updater_ind += 1",
      "mutated_line": "updater_ind += -1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += -1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "failed = True",
      "mutated_line": "failed = False",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = False\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x - power_usage[ind] / (turn - last_updated[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] / (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x - (power_usage[ind] + (turn - last_updated[ind]))",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - (power_usage[ind] + (turn - last_updated[ind]))\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x - power_usage[ind] ** (turn - last_updated[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] ** (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = c + 1",
      "mutated_line": "a = c + 2",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 2\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = c + 1",
      "mutated_line": "a = c + 0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 0\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = c + 1",
      "mutated_line": "a = c + 0",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 0\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = c + 1",
      "mutated_line": "a = c + -1",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + -1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 11 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 11 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 9 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 9 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 0 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 0 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 1 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 1 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * -10 ** 12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * -10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 10 ** 13:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 13:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 10 ** 11:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 11:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 10 ** 0:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 0:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 10 ** 1:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 1:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if b == 2 * 10**12:",
      "mutated_line": "if b == 2 * 10 ** -12:",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** -12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x - power_usage[ind] * (turn + last_updated[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn + last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])",
      "mutated_line": "charge[ind] += x - power_usage[ind] * (turn * last_updated[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn * last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] * Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "next_update = turn + int(charge[ind] * Binv[ind])",
      "mutated_line": "next_update = turn + int(charge[ind] / Binv[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] / Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "next_update = turn + int(charge[ind] * Binv[ind])",
      "mutated_line": "next_update = turn + int(charge[ind] + Binv[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] + Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "next_update = turn + int(charge[ind] * Binv[ind])",
      "mutated_line": "next_update = turn + int(charge[ind] ** Binv[ind])",
      "code": "def find_minimal_charger_power(n, k, initial_charge, power_usage):\n    Binv = [1.0 / b for b in power_usage]\n    turn_data = [0] * n\n    for i in range(n):\n        a = initial_charge[i]\n        binv = Binv[i]\n        t = int(a * binv)\n        turn_data[i] = t\n    a = 0\n    b = 2 * 10 ** 12\n    while a < b:\n        c = (a + b) // 2\n        x = 1.0 * c\n        updater = [[] for _ in range(k)]\n        for i in range(n):\n            if turn_data[i] < k:\n                updater[turn_data[i]].append(i)\n        last_updated = [0] * n\n        charge = initial_charge[:]\n        failed = False\n        updater_ind = 0\n        for turn in range(k):\n            while updater_ind < k and (not updater[updater_ind]):\n                updater_ind += 1\n            if updater_ind == k:\n                break\n            ind = updater[updater_ind].pop()\n            val = updater_ind\n            if turn > val:\n                failed = True\n                break\n            charge[ind] += x - power_usage[ind] * (turn - last_updated[ind])\n            last_updated[ind] = turn\n            next_update = turn + int(charge[ind] ** Binv[ind])\n            if next_update < k:\n                updater[next_update].append(ind)\n        if failed:\n            a = c + 1\n        else:\n            b = c\n    if b == 2 * 10 ** 12:\n        return -1\n    else:\n        return b"
    }
  ]
}