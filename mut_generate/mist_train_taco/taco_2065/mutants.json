{
  "task_id": "taco_2065",
  "entry_point": "generate_segments",
  "mutant_count": 174,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] / (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] / (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] + (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] + (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] ** (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] ** (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[1] = 2",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 2\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 0\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 0\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[1] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = -1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] / (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] / (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] + (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] + (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] ** (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] ** (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-1] = 2",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 2\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 0\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 0\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-1] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = -1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 1\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[1] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = -1\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 1\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] / (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] / (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] + (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] + (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] ** (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] ** (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[1] = +1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = +1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[-1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 1\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[-1] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = -1\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[-1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 1\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "s = -1",
      "mutated_line": "s = +1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = +1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] / (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] / (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] + (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] + (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] ** (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] ** (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] / (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] / (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] + (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] + (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] ** (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] ** (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st = [1]",
      "mutated_line": "st = [2]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [2]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st = [1]",
      "mutated_line": "st = [0]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [0]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st = [1]",
      "mutated_line": "st = [0]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [0]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "st = [1]",
      "mutated_line": "st = [-1]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [-1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n - 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n - 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n * 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n * 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[2] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[2] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[0] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[0] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[0] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[0] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "seen[1] = 1",
      "mutated_line": "seen[-1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[-1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n - 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n - 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n * 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n * 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[+1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[+1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[2] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[2] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[0] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[0] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[0] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[0] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "LL[1] = 0",
      "mutated_line": "LL[-1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[-1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n - 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n - 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n * 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n * 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[2] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[2] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[0] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[0] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[0] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[0] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[-1] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[-1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[1] = -2",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -2\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[1] = -0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -0\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[1] = -0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -0\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "LL_rev[1] = -1",
      "mutated_line": "LL_rev[1] = --1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = --1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[+1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[+1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = -1",
      "mutated_line": "s = -2",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -2\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = -1",
      "mutated_line": "s = -0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -0\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = -1",
      "mutated_line": "s = -0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -0\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = -1",
      "mutated_line": "s = --1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = --1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] * (n - 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n - 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] * (n * 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n * 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] * (n - 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n - 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] * (n * 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n * 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(2, 2 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(2, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(0, 2 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(0, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(0, 2 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(0, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(-1, 2 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(-1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 * n - 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n - 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 * n * 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n * 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s < 0:",
      "mutated_line": "if s <= 0:",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s <= 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s < 0:",
      "mutated_line": "if s >= 0:",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s >= 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s < 0:",
      "mutated_line": "if s != 0:",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s != 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [1] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [-1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [-1] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [1] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + 2)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 2)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 0)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 0)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "seen = [0] * (n + 1)",
      "mutated_line": "seen = [0] * (n + -1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + -1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [1] * (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [1] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [-1] * (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [-1] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [1] * (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [1] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 / n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 / n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 + n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 + n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 ** n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 ** n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n + 4)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 4)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n + 2)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 2)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 0)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 1)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (2 * n + -3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + -3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-2] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-2] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-0] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-0] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[-0] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-0] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "LL[-1] = 1",
      "mutated_line": "LL[--1] = 1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[--1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [1] * (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [1] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [-1] * (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [-1] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [1] * (2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [1] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 / n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 / n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 + n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 + n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 ** n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 ** n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n + 4)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 4)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n + 2)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 2)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 0)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 1)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (2 * n + -3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + -3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[-2] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-2] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[-0] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-0] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[-0] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-0] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "LL_rev[-1] = 0",
      "mutated_line": "LL_rev[--1] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[--1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [1] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [-1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [-1] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [1] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] * (n + 2)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 2)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] * (n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 0)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] * (n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 0)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans1 = [0] * (n + 1)",
      "mutated_line": "ans1 = [0] * (n + -1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + -1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [1] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [-1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [-1] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [1] * (n + 1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [1] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] * (n + 2)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 2)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] * (n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 0)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] * (n + 0)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 0)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ans2 = [0] * (n + 1)",
      "mutated_line": "ans2 = [0] * (n + -1)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + -1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 / n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 / n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 + n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 + n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 ** n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 ** n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 * n + 2):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 2):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 * n + 0):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 0):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 * n + 0):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 0):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 2 * n + -1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + -1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 1:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if s < 0:",
      "mutated_line": "if s < -1:",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < -1:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 1:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n - 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n - 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n * 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n * 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (3 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (3 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (1 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (1 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (0 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (0 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (1 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (1 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "LL = [0] * (2 * n + 3)",
      "mutated_line": "LL = [0] * (-2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (-2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (3 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (3 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (1 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (1 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (0 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (0 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (1 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (1 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "LL_rev = [0] * (2 * n + 3)",
      "mutated_line": "LL_rev = [0] * (-2 * n + 3)",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (-2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "seen[u] = 1",
      "mutated_line": "seen[u] = 2",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 2\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "seen[u] = 1",
      "mutated_line": "seen[u] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 0\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "seen[u] = 1",
      "mutated_line": "seen[u] = 0",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 0\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "seen[u] = 1",
      "mutated_line": "seen[u] = -1",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = -1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "u_ = -u",
      "mutated_line": "u_ = +u",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = +u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 3 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 3 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 1 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 1 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 0 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 0 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, 1 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 1 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(1, 2 * n + 1):",
      "mutated_line": "for i in range(1, -2 * n + 1):",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, -2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "ans1[-s] = i",
      "mutated_line": "ans1[+s] = i",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[+s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(2, n + 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(2, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(0, n + 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(0, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(0, n + 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(0, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(-1, n + 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(-1, n + 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n - 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n - 1)]\n    return segments"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n * 1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n * 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 2)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 2)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 0)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 0)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + -1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + -1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 2)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 2)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 0)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 0)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 0)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + 0)]\n    return segments"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + 1)]",
      "mutated_line": "segments = [(ans1[i], ans2[i]) for i in range(1, n + -1)]",
      "code": "def generate_segments(n, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (a, b) in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    st = [1]\n    seen = [0] * (n + 1)\n    seen[1] = 1\n    LL = [0] * (2 * n + 3)\n    LL[-1] = 1\n    LL[1] = 0\n    LL_rev = [0] * (2 * n + 3)\n    LL_rev[1] = -1\n    LL_rev[-1] = 0\n    st_append = st.append\n    while st:\n        v = st.pop()\n        for u in adj[v]:\n            if not seen[u]:\n                seen[u] = 1\n                st_append(u)\n                v_next = LL[v]\n                v_prev = LL_rev[v]\n                LL[v] = u\n                LL[u] = v_next\n                LL_rev[v_next] = u\n                LL_rev[u] = v\n                u_ = -u\n                LL_rev[v] = u_\n                LL[v_prev] = u_\n                LL[u_] = v\n    s = -1\n    ans1 = [0] * (n + 1)\n    ans2 = [0] * (n + 1)\n    for i in range(1, 2 * n + 1):\n        if s < 0:\n            ans1[-s] = i\n        else:\n            ans2[s] = i\n        s = LL[s]\n    segments = [(ans1[i], ans2[i]) for i in range(1, n + -1)]\n    return segments"
    }
  ]
}