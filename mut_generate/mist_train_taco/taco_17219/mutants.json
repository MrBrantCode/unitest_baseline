{
  "task_id": "taco_17219",
  "entry_point": "calculate_min_max_f",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) + 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) + 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = (n - (len(leaves) - len(set(parent_leaves.values())))) * 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = (n - (len(leaves) - len(set(parent_leaves.values())))) * 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if min(parity_of_leaves) == max(parity_of_leaves):",
      "mutated_line": "if min(parity_of_leaves) != max(parity_of_leaves):",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) != max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(adjacency_list[u]) == 1:",
      "mutated_line": "if len(adjacency_list[u]) != 1:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) != 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n + (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n + (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n * (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n * (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 2",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 2\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 0",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 0\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 0",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 0\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - -1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - -1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parity = {leaves[0]: 0}",
      "mutated_line": "parity = {leaves[0]: 1}",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 1}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parity = {leaves[0]: 0}",
      "mutated_line": "parity = {leaves[0]: -1}",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: -1}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parity = {leaves[0]: 0}",
      "mutated_line": "parity = {leaves[0]: 1}",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 1}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_f = 1",
      "mutated_line": "min_f = 2",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 2\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_f = 1",
      "mutated_line": "min_f = 0",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 0\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_f = 1",
      "mutated_line": "min_f = 0",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 0\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "min_f = 1",
      "mutated_line": "min_f = -1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = -1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_f = 3",
      "mutated_line": "min_f = 4",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 4\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_f = 3",
      "mutated_line": "min_f = 2",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 2\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_f = 3",
      "mutated_line": "min_f = 0",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 0\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_f = 3",
      "mutated_line": "min_f = 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 1\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_f = 3",
      "mutated_line": "min_f = -3",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = -3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(adjacency_list[u]) == 1:",
      "mutated_line": "if len(adjacency_list[u]) == 2:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 2:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(adjacency_list[u]) == 1:",
      "mutated_line": "if len(adjacency_list[u]) == 0:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 0:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(adjacency_list[u]) == 1:",
      "mutated_line": "if len(adjacency_list[u]) == 0:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 0:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(adjacency_list[u]) == 1:",
      "mutated_line": "if len(adjacency_list[u]) == -1:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == -1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - (len(leaves) + len(set(parent_leaves.values()))) - 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) + len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1",
      "mutated_line": "max_f = n - len(leaves) * len(set(parent_leaves.values())) - 1",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - len(leaves) * len(set(parent_leaves.values())) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parity = {leaves[0]: 0}",
      "mutated_line": "parity = {leaves[1]: 0}",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[1]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parity = {leaves[0]: 0}",
      "mutated_line": "parity = {leaves[-1]: 0}",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[-1]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parity = {leaves[0]: 0}",
      "mutated_line": "parity = {leaves[1]: 0}",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[1]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack = [leaves[0]]",
      "mutated_line": "stack = [leaves[1]]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[1]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack = [leaves[0]]",
      "mutated_line": "stack = [leaves[-1]]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[-1]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack = [leaves[0]]",
      "mutated_line": "stack = [leaves[1]]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[1]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if adj not in seen:",
      "mutated_line": "if adj in seen:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(2, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(0, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(0, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(-1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n - 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n * 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "parent_leaves[u] = adjacency_list[u][0]",
      "mutated_line": "parent_leaves[u] = adjacency_list[u][1]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][1]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "parent_leaves[u] = adjacency_list[u][0]",
      "mutated_line": "parent_leaves[u] = adjacency_list[u][-1]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][-1]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "parent_leaves[u] = adjacency_list[u][0]",
      "mutated_line": "parent_leaves[u] = adjacency_list[u][1]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][1]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parity[adj] = 1 - parity[node]",
      "mutated_line": "parity[adj] = 1 + parity[node]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 + parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parity[adj] = 1 - parity[node]",
      "mutated_line": "parity[adj] = 1 * parity[node]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 * parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 2)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 0)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 0)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adjacency_list = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + -1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parity[adj] = 1 - parity[node]",
      "mutated_line": "parity[adj] = 2 - parity[node]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 2 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parity[adj] = 1 - parity[node]",
      "mutated_line": "parity[adj] = 0 - parity[node]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 0 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parity[adj] = 1 - parity[node]",
      "mutated_line": "parity[adj] = 0 - parity[node]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = 0 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parity[adj] = 1 - parity[node]",
      "mutated_line": "parity[adj] = -1 - parity[node]",
      "code": "def calculate_min_max_f(n, edges):\n    adjacency_list = {i: [] for i in range(1, n + 1)}\n    for (u, v) in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n    leaves = []\n    parent_leaves = {}\n    for u in adjacency_list:\n        if len(adjacency_list[u]) == 1:\n            leaves.append(u)\n            parent_leaves[u] = adjacency_list[u][0]\n    max_f = n - (len(leaves) - len(set(parent_leaves.values()))) - 1\n    parity = {leaves[0]: 0}\n    stack = [leaves[0]]\n    seen = set(stack)\n    while stack:\n        node = stack.pop()\n        for adj in adjacency_list[node]:\n            if adj not in seen:\n                parity[adj] = -1 - parity[node]\n                stack.append(adj)\n                seen.add(adj)\n    parity_of_leaves = [parity[leaf] for leaf in leaves]\n    if min(parity_of_leaves) == max(parity_of_leaves):\n        min_f = 1\n    else:\n        min_f = 3\n    return (min_f, max_f)"
    }
  ]
}