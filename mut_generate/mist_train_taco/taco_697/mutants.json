{
  "task_id": "taco_697",
  "entry_point": "minimum_trip_price",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] / (m + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] / (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] + (m + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] + (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] ** (m + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] ** (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] / (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] / (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] + (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] + (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] ** (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] ** (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 1\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = -1\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 1\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] * (m - 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m - 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] * (m * 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m * 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(2, m + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(2, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(0, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(0, m + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(0, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(-1, m + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(-1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m - 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m - 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m * 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m * 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] - prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] - prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] * prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] * prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = float('inf')",
      "mutated_line": "res = float('')",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(2, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(0, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(0, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(-1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n - 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n * 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if dist1[i] + dist2[i] + dist3[i] < m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] < m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if dist1[i] + dist2[i] + dist3[i] > m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] > m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if dist1[i] + dist2[i] + dist3[i] == m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] == m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] * (n - 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n - 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] * (n * 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n * 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [1] * (m + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [1] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [-1] * (m + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [-1] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [1] * (m + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [1] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] * (m + 2)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 2)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] * (m + 0)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 0)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] * (m + 0)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 0)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "prefix_sum = [0] * (m + 1)",
      "mutated_line": "prefix_sum = [0] * (m + -1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + -1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 2):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 2):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 0):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + 0):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 0):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, m + 1):",
      "mutated_line": "for i in range(1, m + -1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + -1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 2):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 0):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 0):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + -1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if dist1[i] + dist2[i] - dist3[i] <= m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] - dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if (dist1[i] + dist2[i]) * dist3[i] <= m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if (dist1[i] + dist2[i]) * dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [+1] * (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [+1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 2)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 2)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 0)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 0)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 0)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 0)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + -1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + -1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] != -1:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] != -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i + 1] + prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i + 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i * 1] + prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i * 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i + 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i + 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i * 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i * 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if dist1[i] - dist2[i] + dist3[i] <= m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] - dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if dist1[i] + dist2[i] + dist3[i] <= m:",
      "mutated_line": "if dist1[i] * dist2[i] + dist3[i] <= m:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] * dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "mutated_line": "res = min(res, prefix_sum[dist2[i]] - prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] - prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "mutated_line": "res = min(res, prefix_sum[dist2[i]] * prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] * prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-2] * (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-2] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-0] * (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-0] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [-0] * (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-0] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [-1] * (n + 1)",
      "mutated_line": "dist = [--1] * (n + 1)",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [--1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == +1:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == +1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] - 1",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] - 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] * 1",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] * 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 2] + prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 2] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 0] + prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 0] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 0] + prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 0] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - -1] + prices[i - 1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - -1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 2]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 2]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 0]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 0]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 0]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 0]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]",
      "mutated_line": "prefix_sum[i] = prefix_sum[i - 1] + prices[i - -1]",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - -1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == -2:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -2:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == -0:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -0:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == -0:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -0:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == --1:",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == --1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 2",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 2\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 0",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 0\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 0",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 0\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + -1",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + -1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "mutated_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] - dist3[i]])",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] - dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "mutated_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[(dist1[i] + dist2[i]) * dist3[i]])",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[(dist1[i] + dist2[i]) * dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "mutated_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] - dist2[i] + dist3[i]])",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] - dist2[i] + dist3[i]])\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] + dist2[i] + dist3[i]])",
      "mutated_line": "res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] * dist2[i] + dist3[i]])",
      "code": "from collections import deque\n\ndef minimum_trip_price(n, m, a, b, c, prices, edges):\n    g = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    def BFS(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            u = queue.popleft()\n            for v in g[u]:\n                if dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n    dist1 = BFS(a)\n    dist2 = BFS(b)\n    dist3 = BFS(c)\n    prices.sort()\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1]\n    res = float('inf')\n    for i in range(1, n + 1):\n        if dist1[i] + dist2[i] + dist3[i] <= m:\n            res = min(res, prefix_sum[dist2[i]] + prefix_sum[dist1[i] * dist2[i] + dist3[i]])\n    return res"
    }
  ]
}