{
  "task_id": "taco_6969",
  "entry_point": "count_valid_subsequences",
  "mutant_count": 158,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] / (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] / (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] + (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] + (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] ** (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] ** (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] * (n - 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n - 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] * (n * 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n * 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 1\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = 0",
      "mutated_line": "p = -1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = -1\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 1\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 1\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = 0",
      "mutated_line": "h = -1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = -1\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "h = 0",
      "mutated_line": "h = 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 1\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "y = 1",
      "mutated_line": "y = 2",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 2\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "y = 1",
      "mutated_line": "y = 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 0\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "y = 1",
      "mutated_line": "y = 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 0\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "y = 1",
      "mutated_line": "y = -1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = -1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] / (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] / (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] + (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] + (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] ** (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] ** (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] / (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] / (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] + (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] + (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] ** (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] ** (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if mp < 0:",
      "mutated_line": "if mp <= 0:",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp <= 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if mp < 0:",
      "mutated_line": "if mp >= 0:",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp >= 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if mp < 0:",
      "mutated_line": "if mp != 0:",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp != 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "required[req] += 1",
      "mutated_line": "required[req] -= 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] -= 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 * 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 * 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 + 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 + 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] * (n + 2)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 2)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] * (n + 0)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 0)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] * (n + 0)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 0)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 9] * (n + -1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + -1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m + 2, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m + 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m * 2, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m * 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n - 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n - 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n * 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n * 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n - 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n - 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n * 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n * 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if c == '>':",
      "mutated_line": "if c != '>':",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c != '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p -= 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pow_x = [1]",
      "mutated_line": "pow_x = [2]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [2]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pow_x = [1]",
      "mutated_line": "pow_x = [0]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [0]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pow_x = [1]",
      "mutated_line": "pow_x = [0]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [0]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pow_x = [1]",
      "mutated_line": "pow_x = [-1]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [-1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if mp < 0:",
      "mutated_line": "if mp < 1:",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 1:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if mp < 0:",
      "mutated_line": "if mp < -1:",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < -1:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if mp < 0:",
      "mutated_line": "if mp < 1:",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 1:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "ideal = hashes[-1]",
      "mutated_line": "ideal = hashes[+1]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[+1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = (ideal * pow_x[p] + h) * m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) * m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = ideal * pow_x[p] + h + m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = ideal * pow_x[p] + h + m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "required[req] += 1",
      "mutated_line": "required[req] += 2",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 2\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "required[req] += 1",
      "mutated_line": "required[req] += 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 0\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "required[req] += 1",
      "mutated_line": "required[req] += 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 0\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "required[req] += 1",
      "mutated_line": "required[req] += -1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += -1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [11 ** 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [11 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [9 ** 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [9 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [0 ** 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [0 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [1 ** 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [1 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [-10 ** 9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [-10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 10] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 10] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 8] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 8] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 0] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 0] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** 1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 1] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [10 ** 9] * (n + 1)",
      "mutated_line": "ans = [10 ** -9] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** -9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m - 3, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 3, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m - 1, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 1, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m - 0, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 0, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m - 1, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 1, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "r = pow(x, m - 2, m)",
      "mutated_line": "r = pow(x, m - -2, m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - -2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [1] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [-1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [-1] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [1] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + 2)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 2)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + 0)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 0)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + 0)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 0)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + -1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + -1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [1] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [-1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [-1] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [1] * (n + 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [1] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + 2)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 2)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + 0)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 0)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + 0)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 0)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "hashes = [0] * (n + 1)",
      "mutated_line": "hashes = [0] * (n + -1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + -1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for (i, c) in enumerate(s, start=1):",
      "mutated_line": "for (i, c) in enumerate(s, start=2):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=2):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for (i, c) in enumerate(s, start=1):",
      "mutated_line": "for (i, c) in enumerate(s, start=0):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=0):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for (i, c) in enumerate(s, start=1):",
      "mutated_line": "for (i, c) in enumerate(s, start=0):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=0):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for (i, c) in enumerate(s, start=1):",
      "mutated_line": "for (i, c) in enumerate(s, start=-1):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=-1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if c == '>':",
      "mutated_line": "if c == '':",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 2\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 0\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 0\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += -1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = y * x % m",
      "mutated_line": "y = y * x * m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x * m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = y * x % m",
      "mutated_line": "y = y * x + m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x + m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif c == '<':",
      "mutated_line": "elif c != '<':",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c != '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "p -= 1",
      "mutated_line": "p += 1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p += 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] * x * m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x * m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] * x + m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x + m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(-mp + 1):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp + 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(-mp * 1):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp * 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ideal = hashes[-1]",
      "mutated_line": "ideal = hashes[-2]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-2]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ideal = hashes[-1]",
      "mutated_line": "ideal = hashes[-0]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-0]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ideal = hashes[-1]",
      "mutated_line": "ideal = hashes[-0]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-0]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ideal = hashes[-1]",
      "mutated_line": "ideal = hashes[--1]",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[--1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "required = defaultdict(lambda : 0)",
      "mutated_line": "required = defaultdict(lambda : 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 1)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "required = defaultdict(lambda : 0)",
      "mutated_line": "required = defaultdict(lambda : -1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : -1)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "required = defaultdict(lambda : 0)",
      "mutated_line": "required = defaultdict(lambda : 1)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 1)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = (ideal * pow_x[p] - h) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] - h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = ideal * pow_x[p] * h % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = ideal * pow_x[p] * h % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = y * x % m",
      "mutated_line": "y = y / x % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y / x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = y * x % m",
      "mutated_line": "y = (y + x) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = (y + x) % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = y * x % m",
      "mutated_line": "y = y ** x % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y ** x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif c == '<':",
      "mutated_line": "elif c == '':",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p -= 1",
      "mutated_line": "p -= 2",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 2\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p -= 1",
      "mutated_line": "p -= 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 0\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p -= 1",
      "mutated_line": "p -= 0",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 0\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p -= 1",
      "mutated_line": "p -= -1",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= -1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = y * r % m",
      "mutated_line": "y = y * r * m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r * m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = y * r % m",
      "mutated_line": "y = y * r + m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r + m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif c == '+':",
      "mutated_line": "elif c != '+':",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c != '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] / x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] / x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append((pow_x[-1] + x) % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append((pow_x[-1] + x) % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] ** x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] ** x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "pow_x.append(pow(r, -mp, m))",
      "mutated_line": "pow_x.append(pow(r, +mp, m))",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, +mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(+mp - 1):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(+mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(-mp - 2):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 2):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(-mp - 0):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 0):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(-mp - 0):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 0):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for _ in range(-mp - 1):",
      "mutated_line": "for _ in range(-mp - -1):",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - -1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] * x * m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x * m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] * x + m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x + m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = (ideal / pow_x[p] + h) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal / pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = (ideal + pow_x[p] + h) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal + pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "req = (ideal * pow_x[p] + h) % m",
      "mutated_line": "req = (ideal ** pow_x[p] + h) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal ** pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = y * r % m",
      "mutated_line": "y = y / r % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y / r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = y * r % m",
      "mutated_line": "y = (y + r) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = (y + r) % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "y = y * r % m",
      "mutated_line": "y = y ** r % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y ** r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif c == '+':",
      "mutated_line": "elif c == '':",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "h = (h + y) % m",
      "mutated_line": "h = (h + y) * m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) * m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "h = (h + y) % m",
      "mutated_line": "h = h + y + m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = h + y + m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "h = (h - y) % m",
      "mutated_line": "h = (h - y) * m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) * m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "h = (h - y) % m",
      "mutated_line": "h = h - y + m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = h - y + m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] / x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] / x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append((pow_x[-1] + x) % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append((pow_x[-1] + x) % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-1] ** x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] ** x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "h = (h + y) % m",
      "mutated_line": "h = (h - y) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h - y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "h = (h + y) % m",
      "mutated_line": "h = h * y % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = h * y % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "h = (h - y) % m",
      "mutated_line": "h = (h + y) % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h + y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "h = (h - y) % m",
      "mutated_line": "h = h * y % m",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = h * y % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[+1] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[+1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-2] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-2] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-0] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-0] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-0] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-0] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[--1] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[--1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[+1] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[+1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-2] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-2] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-0] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-0] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[-0] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[-0] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pow_x.append(pow_x[-1] * x % m)",
      "mutated_line": "pow_x.append(pow_x[--1] * x % m)",
      "code": "from collections import defaultdict\n\ndef count_valid_subsequences(n, s, xs, m):\n    ans = [10 ** 9] * (n + 1)\n    for x in xs:\n        p = 0\n        h = 0\n        y = 1\n        r = pow(x, m - 2, m)\n        pos = [0] * (n + 1)\n        hashes = [0] * (n + 1)\n        for (i, c) in enumerate(s, start=1):\n            if c == '>':\n                p += 1\n                y = y * x % m\n            elif c == '<':\n                p -= 1\n                y = y * r % m\n            elif c == '+':\n                h = (h + y) % m\n            else:\n                h = (h - y) % m\n            pos[i] = p\n            hashes[i] = h\n        pow_x = [1]\n        for _ in range(max(pos)):\n            pow_x.append(pow_x[-1] * x % m)\n        mp = min(pos)\n        if mp < 0:\n            pow_x.append(pow(r, -mp, m))\n            for _ in range(-mp - 1):\n                pow_x.append(pow_x[--1] * x % m)\n        ideal = hashes[-1]\n        required = defaultdict(lambda : 0)\n        for (i, (p, h)) in enumerate(zip(pos, hashes)):\n            ans[i] = min(ans[i], required[h])\n            req = (ideal * pow_x[p] + h) % m\n            required[req] += 1\n    return sum(ans)"
    }
  ]
}