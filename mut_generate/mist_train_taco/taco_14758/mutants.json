{
  "task_id": "taco_14758",
  "entry_point": "max_exam_points",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "num_easy = n - num_hard",
      "mutated_line": "num_easy = n + num_hard",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n + num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "num_easy = n - num_hard",
      "mutated_line": "num_easy = n * num_hard",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n * num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mandatory_score = 0",
      "mutated_line": "mandatory_score = 1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 1\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mandatory_score = 0",
      "mutated_line": "mandatory_score = -1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = -1\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mandatory_score = 0",
      "mutated_line": "mandatory_score = 1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 1\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mandatory_time = 0",
      "mutated_line": "mandatory_time = 1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 1\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mandatory_time = 0",
      "mutated_line": "mandatory_time = -1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = -1\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mandatory_time = 0",
      "mutated_line": "mandatory_time = 1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 1\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time -= diff * (b - a) + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time -= diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "mandatory_score += 1",
      "mutated_line": "mandatory_score -= 1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score -= 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "left_time = T - mandatory_time",
      "mutated_line": "left_time = T + mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T + mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "left_time = T - mandatory_time",
      "mutated_line": "left_time = T * mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T * mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time > 0:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time > 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time < 0:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time < 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time == 0:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time == 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time - 1 + mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 + mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = (time - 1) * mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = (time - 1) * mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time > 0:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time > 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time < 0:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time < 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time == 0:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time == 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff * (b - a) - a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) - a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff * (b - a) * a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) * a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mandatory_score += 1",
      "mutated_line": "mandatory_score += 2",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 2\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mandatory_score += 1",
      "mutated_line": "mandatory_score += 0",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 0\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mandatory_score += 1",
      "mutated_line": "mandatory_score += 0",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 0\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mandatory_score += 1",
      "mutated_line": "mandatory_score += -1",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += -1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy + (1 - diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy + (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy * (1 - diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy * (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num_hard = num_hard - diff",
      "mutated_line": "num_hard = num_hard + diff",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard + diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "num_hard = num_hard - diff",
      "mutated_line": "num_hard = num_hard * diff",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard * diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time >= 1:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 1:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time >= -1:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= -1:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time >= 1:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 1:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time / a) < num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) < num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time / a) > num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) > num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time / a) == num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) == num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "score += int(left_time / a)",
      "mutated_line": "score -= int(left_time / a)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score -= int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "score += num_easy",
      "mutated_line": "score -= num_easy",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score -= num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time += num_easy * a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time += num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "score += min(int(left_time / b), num_hard)",
      "mutated_line": "score -= min(int(left_time / b), num_hard)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score -= min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time + 1 - mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time + 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time * 1 - mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time * 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time >= 1:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 1:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time >= -1:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= -1:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if left_time >= 0:",
      "mutated_line": "if left_time >= 1:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 1:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time / a) < num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) < num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time / a) > num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) > num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time / a) == num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) == num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "score += int(left_time / a)",
      "mutated_line": "score -= int(left_time / a)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score -= int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "score += num_easy",
      "mutated_line": "score -= num_easy",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score -= num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time += num_easy * a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time += num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "score += min(int(left_time / b), num_hard)",
      "mutated_line": "score -= min(int(left_time / b), num_hard)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score -= min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff / (b - a) + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff / (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff + (b - a) + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff + (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff ** (b - a) + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff ** (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy - (1 + diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 + diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy - 1 * diff",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - 1 * diff\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time -= num_easy / a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy / a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time -= num_easy + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy + a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time -= num_easy ** a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy ** a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "scores.append(0)",
      "mutated_line": "scores.append(1)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(1)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "scores.append(0)",
      "mutated_line": "scores.append(-1)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(-1)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "scores.append(0)",
      "mutated_line": "scores.append(1)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(1)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time - 2 - mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 2 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time - 0 - mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 0 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time - 0 - mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 0 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left_time = time - 1 - mandatory_time",
      "mutated_line": "left_time = time - -1 - mandatory_time",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - -1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time -= num_easy / a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy / a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time -= num_easy + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy + a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "left_time -= num_easy * a",
      "mutated_line": "left_time -= num_easy ** a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy ** a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "scores.append(0)",
      "mutated_line": "scores.append(1)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(1)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "scores.append(0)",
      "mutated_line": "scores.append(-1)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(-1)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "scores.append(0)",
      "mutated_line": "scores.append(1)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(1)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff * (b + a) + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b + a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mandatory_time += diff * (b - a) + a",
      "mutated_line": "mandatory_time += diff * (b * a) + a",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b * a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy - (2 - diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (2 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy - (0 - diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (0 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy - (0 - diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (0 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "num_easy = num_easy - (1 - diff)",
      "mutated_line": "num_easy = num_easy - (-1 - diff)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (-1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time * a) <= num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time * a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time // a) <= num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time // a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "score += int(left_time / a)",
      "mutated_line": "score += int(left_time * a)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time * a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "score += int(left_time / a)",
      "mutated_line": "score += int(left_time // a)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time // a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "joint.sort(key=lambda tup: tup[1])",
      "mutated_line": "joint.sort(key=lambda tup: tup[2])",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[2])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "joint.sort(key=lambda tup: tup[1])",
      "mutated_line": "",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[0])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "joint.sort(key=lambda tup: tup[1])",
      "mutated_line": "",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[0])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "joint.sort(key=lambda tup: tup[1])",
      "mutated_line": "joint.sort(key=lambda tup: tup[-1])",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[-1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "joint.sort(key=lambda tup: tup[0])",
      "mutated_line": "joint.sort(key=lambda tup: tup[1])",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[1])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "joint.sort(key=lambda tup: tup[0])",
      "mutated_line": "joint.sort(key=lambda tup: tup[-1])",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[-1])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "joint.sort(key=lambda tup: tup[0])",
      "mutated_line": "joint.sort(key=lambda tup: tup[1])",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[1])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time * a) <= num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time * a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if int(left_time / a) <= num_easy:",
      "mutated_line": "if int(left_time // a) <= num_easy:",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time // a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "score += int(left_time / a)",
      "mutated_line": "score += int(left_time * a)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time * a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "score += int(left_time / a)",
      "mutated_line": "score += int(left_time // a)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time // a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "score += min(int(left_time / b), num_hard)",
      "mutated_line": "score += min(int(left_time * b), num_hard)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time * b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "score += min(int(left_time / b), num_hard)",
      "mutated_line": "score += min(int(left_time // b), num_hard)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time / b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time // b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "score += min(int(left_time / b), num_hard)",
      "mutated_line": "score += min(int(left_time * b), num_hard)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time * b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "score += min(int(left_time / b), num_hard)",
      "mutated_line": "score += min(int(left_time // b), num_hard)",
      "code": "def max_exam_points(n, T, a, b, difficulty, mandatory_at):\n    joint = list(zip(mandatory_at, difficulty))\n    joint.sort(key=lambda tup: tup[1])\n    joint.sort(key=lambda tup: tup[0])\n    num_hard = sum(difficulty)\n    num_easy = n - num_hard\n    scores = []\n    mandatory_score = 0\n    mandatory_time = 0\n    for (time, diff) in joint:\n        left_time = time - 1 - mandatory_time\n        if left_time >= 0:\n            score = mandatory_score\n            if int(left_time / a) <= num_easy:\n                score += int(left_time / a)\n            else:\n                score += num_easy\n                left_time -= num_easy * a\n                score += min(int(left_time // b), num_hard)\n            scores.append(score)\n        else:\n            scores.append(0)\n        mandatory_time += diff * (b - a) + a\n        mandatory_score += 1\n        num_easy = num_easy - (1 - diff)\n        num_hard = num_hard - diff\n    left_time = T - mandatory_time\n    if left_time >= 0:\n        score = mandatory_score\n        if int(left_time / a) <= num_easy:\n            score += int(left_time / a)\n        else:\n            score += num_easy\n            left_time -= num_easy * a\n            score += min(int(left_time / b), num_hard)\n        scores.append(score)\n    else:\n        scores.append(0)\n    return max(scores)"
    }
  ]
}