{
  "task_id": "taco_4325",
  "entry_point": "count_finite_game_pairs",
  "mutant_count": 151,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n / (n * 2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n / (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n + (n * 2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n + (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n ** (n * 2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n ** (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [0] / n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] / n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [0] + n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] + n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [0] ** n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] ** n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pt = 0",
      "mutated_line": "pt = 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 1\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pt = 0",
      "mutated_line": "pt = -1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = -1\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pt = 0",
      "mutated_line": "pt = 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 1\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = True\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "pt += a[pt]",
      "mutated_line": "pt -= a[pt]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt -= a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans += (n - sum(visited)) * (2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans += (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "ans -= cnt * cnt",
      "mutated_line": "ans += cnt * cnt",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans += cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans += (1 + cnt) * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans += (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_visited = [0] * n",
      "mutated_line": "new_visited = [0] / n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] / n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_visited = [0] * n",
      "mutated_line": "new_visited = [0] + n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] + n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "new_visited = [0] * n",
      "mutated_line": "new_visited = [0] ** n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] ** n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 2 - 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 - 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 2 * 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 * 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited[pt] = 1",
      "mutated_line": "visited[pt] = 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 2\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited[pt] = 1",
      "mutated_line": "visited[pt] = 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 0\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited[pt] = 1",
      "mutated_line": "visited[pt] = 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 0\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "visited[pt] = 1",
      "mutated_line": "visited[pt] = -1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = -1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) / (2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) / (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= n - sum(visited) + (2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= n - sum(visited) + (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) ** (2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) ** (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = False\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans -= cnt * cnt",
      "mutated_line": "ans -= cnt / cnt",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt / cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans -= cnt * cnt",
      "mutated_line": "ans -= cnt + cnt",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt + cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans -= cnt * cnt",
      "mutated_line": "ans -= cnt ** cnt",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt ** cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt / 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt / 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt * 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt * 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n / 2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n / 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n + 2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n + 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n ** 2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n ** 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 2 + 2)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 2)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 2 + 0)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 0)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 2 + 0)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 0)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 2 + -1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + -1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [1] * n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [1] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [-1] * n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [-1] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * n",
      "mutated_line": "visited = [1] * n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [1] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if not 0 <= pt < n:",
      "mutated_line": "if not 0 < pt < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 < pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if not 0 <= pt < n:",
      "mutated_line": "if not 0 > pt < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 > pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if not 0 <= pt < n:",
      "mutated_line": "if not 0 == pt < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 == pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n + sum(visited)) * (2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n + sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= n * sum(visited) * (2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= n * sum(visited) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 * n - 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n - 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 * n * 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n * 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) / cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) / cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt + cnt) // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt + cnt) // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) ** cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) ** cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt // 3",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 3\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt // 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 1\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt // 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 0\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt // 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 1\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 + cnt) * cnt // -2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // -2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new_visited = [0] * n",
      "mutated_line": "new_visited = [1] * n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [1] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new_visited = [0] * n",
      "mutated_line": "new_visited = [-1] * n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [-1] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "new_visited = [0] * n",
      "mutated_line": "new_visited = [1] * n",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [1] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "f = False",
      "mutated_line": "f = True",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = True\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "i += a[i]",
      "mutated_line": "i -= a[i]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i -= a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if new_visited[i] != -1:",
      "mutated_line": "if new_visited[i] == -1:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] == -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 3 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 3 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 1 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 1 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 0 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 0 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * 1 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 1 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = n * (n * 2 + 1)",
      "mutated_line": "ans = n * (n * -2 + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * -2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not 0 <= pt < n:",
      "mutated_line": "if not 1 <= pt < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 1 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not 0 <= pt < n:",
      "mutated_line": "if not -1 <= pt < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not -1 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if not 0 <= pt < n:",
      "mutated_line": "if not 1 <= pt < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 1 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 / n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 / n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 + n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 + n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 ** n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 ** n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 * n + 2)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 2)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 * n + 0)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 0)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 * n + 0)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 0)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (2 * n + -1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + -1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (1 - cnt) * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 - cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= 1 * cnt * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= 1 * cnt * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "note[i] = 1",
      "mutated_line": "note[i] = 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 2\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "note[i] = 1",
      "mutated_line": "note[i] = 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 0\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "note[i] = 1",
      "mutated_line": "note[i] = 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 0\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "note[i] = 1",
      "mutated_line": "note[i] = -1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = -1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if (note[i] and new_visited[i] >= 0) and visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if (note[i] and new_visited[i] >= 0) and visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "if new_visited[i] != -1:",
      "mutated_line": "if new_visited[i] != +1:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != +1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 1] == 0 and flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 and flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "ans -= cnt",
      "mutated_line": "ans += cnt",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans += cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans += cnt - path_note[new_visited[i] - 1]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans += cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (3 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (3 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (1 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (1 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (0 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (0 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (1 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (1 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans -= (n - sum(visited)) * (2 * n + 1)",
      "mutated_line": "ans -= (n - sum(visited)) * (-2 * n + 1)",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (-2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (2 + cnt) * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (2 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (0 + cnt) * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (0 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (0 + cnt) * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (0 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans -= (1 + cnt) * cnt // 2",
      "mutated_line": "ans -= (-1 + cnt) * cnt // 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (-1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if not 0 <= i < n:",
      "mutated_line": "if not 0 < i < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 < i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if not 0 <= i < n:",
      "mutated_line": "if not 0 > i < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 > i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if not 0 <= i < n:",
      "mutated_line": "if not 0 == i < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 == i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if (note[i] or new_visited[i] >= 0) or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if (note[i] or new_visited[i] >= 0) or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "f = True",
      "mutated_line": "f = False",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = False\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "i = new_visited[i] - 1",
      "mutated_line": "i = new_visited[i] + 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] + 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "i = new_visited[i] - 1",
      "mutated_line": "i = new_visited[i] * 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] * 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_visited[x] = i + 1",
      "mutated_line": "new_visited[x] = i - 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i - 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_visited[x] = i + 1",
      "mutated_line": "new_visited[x] = i * 1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i * 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "new_visited[x] = -1",
      "mutated_line": "new_visited[x] = +1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = +1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if new_visited[i] != -1:",
      "mutated_line": "if new_visited[i] != -2:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -2:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if new_visited[i] != -1:",
      "mutated_line": "if new_visited[i] != -0:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -0:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if new_visited[i] != -1:",
      "mutated_line": "if new_visited[i] != -0:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -0:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if new_visited[i] != -1:",
      "mutated_line": "if new_visited[i] != --1:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != --1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 1] != 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] != 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt + path_note[new_visited[i] - 1]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt + path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt * path_note[new_visited[i] - 1]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt * path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if not 0 <= i < n:",
      "mutated_line": "if not 1 <= i < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 1 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if not 0 <= i < n:",
      "mutated_line": "if not -1 <= i < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not -1 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if not 0 <= i < n:",
      "mutated_line": "if not 1 <= i < n:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 1 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if note[i] and new_visited[i] > 0 or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] > 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if note[i] and new_visited[i] < 0 or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] < 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if note[i] and new_visited[i] == 0 or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] == 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i = new_visited[i] - 1",
      "mutated_line": "i = new_visited[i] - 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 2\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i = new_visited[i] - 1",
      "mutated_line": "i = new_visited[i] - 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 0\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i = new_visited[i] - 1",
      "mutated_line": "i = new_visited[i] - 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 0\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "i = new_visited[i] - 1",
      "mutated_line": "i = new_visited[i] - -1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - -1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_visited[x] = i + 1",
      "mutated_line": "new_visited[x] = i + 2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 2\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_visited[x] = i + 1",
      "mutated_line": "new_visited[x] = i + 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 0\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_visited[x] = i + 1",
      "mutated_line": "new_visited[x] = i + 0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 0\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "new_visited[x] = i + 1",
      "mutated_line": "new_visited[x] = i + -1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + -1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "new_visited[x] = -1",
      "mutated_line": "new_visited[x] = -2",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -2\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "new_visited[x] = -1",
      "mutated_line": "new_visited[x] = -0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -0\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "new_visited[x] = -1",
      "mutated_line": "new_visited[x] = -0",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -0\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "new_visited[x] = -1",
      "mutated_line": "new_visited[x] = --1",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = --1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 1] == 1 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 1 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 1] == -1 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == -1 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 1] == 1 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 1 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if note[i] and new_visited[i] >= 1 or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 1 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if note[i] and new_visited[i] >= -1 or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= -1 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if note[i] and new_visited[i] >= 0 or visited[i]:",
      "mutated_line": "if note[i] and new_visited[i] >= 1 or visited[i]:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 1 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] + 1] == 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] + 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] * 1] == 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] * 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt - path_note[new_visited[i] + 1]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] + 1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt - path_note[new_visited[i] * 1]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] * 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 2] == 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 2] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 0] == 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 0] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - 0] == 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 0] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if visited[new_visited[i] - 1] == 0 or flag:",
      "mutated_line": "if visited[new_visited[i] - -1] == 0 or flag:",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - -1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt - path_note[new_visited[i] - 2]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 2]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt - path_note[new_visited[i] - 0]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 0]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt - path_note[new_visited[i] - 0]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - 0]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans -= cnt - path_note[new_visited[i] - 1]",
      "mutated_line": "ans -= cnt - path_note[new_visited[i] - -1]",
      "code": "def count_finite_game_pairs(n, a):\n    ans = n * (n * 2 + 1)\n    visited = [0] * n\n    path = []\n    pt = 0\n    flag = False\n    while not visited[pt]:\n        path.append(pt)\n        visited[pt] = 1\n        pt += a[pt]\n        if not 0 <= pt < n:\n            break\n    else:\n        ans -= (n - sum(visited)) * (2 * n + 1)\n        flag = True\n    cnt = sum(visited)\n    if flag:\n        ans -= cnt * cnt\n    else:\n        ans -= (1 + cnt) * cnt // 2\n    new_visited = [0] * n\n    note = visited[:]\n    for i in range(n):\n        if not note[i]:\n            tmp = []\n            f = False\n            while not note[i]:\n                tmp.append(i)\n                note[i] = 1\n                i += a[i]\n                if not 0 <= i < n:\n                    break\n                if note[i] and new_visited[i] >= 0 or visited[i]:\n                    f = True\n            if f:\n                if new_visited[i]:\n                    i = new_visited[i] - 1\n                for x in tmp:\n                    new_visited[x] = i + 1\n            else:\n                for x in tmp:\n                    new_visited[x] = -1\n    path_note = {v: i for (i, v) in enumerate(path)}\n    for i in range(n):\n        if not visited[i]:\n            if new_visited[i] != -1:\n                if visited[new_visited[i] - 1] == 0 or flag:\n                    ans -= cnt\n                else:\n                    ans -= cnt - path_note[new_visited[i] - -1]\n    return ans"
    }
  ]
}