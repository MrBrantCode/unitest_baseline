{
  "task_id": "taco_7125",
  "entry_point": "choose",
  "mutant_count": 218,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "MOD = 1000000008\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "MOD = 1000000006\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "MOD = -1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 and k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 and k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "p *= n",
      "mutated_line": "p /= n",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p /= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "q *= i",
      "mutated_line": "q /= i",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q /= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "n -= 1",
      "mutated_line": "n += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n += 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return p // q",
      "mutated_line": "return p / q",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p / q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return p // q",
      "mutated_line": "return p * q",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p * q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return total[m] % MOD",
      "mutated_line": "return total[m] * MOD",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return total[m] % MOD",
      "mutated_line": "return total[m] + MOD",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] + MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k <= 0 or k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k <= 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k >= 0 or k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k >= 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k != 0 or k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k != 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 or k >= n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k >= n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 or k <= n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k <= n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 0 or k != n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k != n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 1\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return -1\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 1\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (2, 1)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (2, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (0, 1)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (0, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (0, 1)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (0, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (-1, 1)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (-1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (1, 2)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 2)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (1, 0)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 0)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (1, 0)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 0)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "(p, q) = (1, 1)",
      "mutated_line": "(p, q) = (1, -1)",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, -1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(2, min(k, n - k) + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(2, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(0, min(k, n - k) + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(0, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(0, min(k, n - k) + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(0, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(-1, min(k, n - k) + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(-1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n - k) - 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) - 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n - k) * 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) * 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n -= 1",
      "mutated_line": "n -= 2",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 2\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 0\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n -= 1",
      "mutated_line": "n -= 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 0\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "n -= 1",
      "mutated_line": "n -= -1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= -1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(2, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(0, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(0, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(-1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 1 or k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 1 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < -1 or k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < -1 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if k < 0 or k > n:",
      "mutated_line": "if k < 1 or k > n:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 1 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n - k) + 2):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 2):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n - k) + 0):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 0):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n - k) + 0):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 0):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n - k) + -1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + -1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] / D[i] for _ in range(M + 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] / D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] + D[i] for _ in range(M + 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] + D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] ** D[i] for _ in range(M + 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] ** D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][0][j] = 2",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 2\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][0][j] = 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 0\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][0][j] = 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 0\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][0][j] = -1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = -1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if j > 0:",
      "mutated_line": "if j >= 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j >= 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if j > 0:",
      "mutated_line": "if j <= 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j <= 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if j > 0:",
      "mutated_line": "if j != 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j != 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] -= 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] -= 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j <= D[i] - 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j <= D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j >= D[i] - 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j >= D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j != D[i] - 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j != D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] -= 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] -= 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(3, M + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(3, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(1, M + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(1, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(0, M + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(0, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(1, M + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(1, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(-2, M + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(-2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(2, M - 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M - 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(2, M * 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M * 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] + 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] + 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] * 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] * 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k >= 0 or (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 or (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k += 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n + k) + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n + k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, min(k, n - k) + 1):",
      "mutated_line": "for i in range(1, min(k, n * k) + 1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n * k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 1:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if j > 0:",
      "mutated_line": "if j > -1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > -1:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 1:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += 2",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 2\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 0\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 0\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += -1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += -1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] + 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] + 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] * 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] * 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += 2",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 2\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 0\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 0\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][1][j] += -1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += -1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(2, M + 2):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 2):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(2, M + 0):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 0):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(2, M + 0):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 0):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for s in range(2, M + 1):",
      "mutated_line": "for s in range(2, M + -1):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + -1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if j > 0:",
      "mutated_line": "if j >= 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j >= 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if j > 0:",
      "mutated_line": "if j <= 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j <= 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if j > 0:",
      "mutated_line": "if j != 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j != 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] -= ways[i][s - 1][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] -= ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j <= D[i] - 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j <= D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j >= D[i] - 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j >= D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j != D[i] - 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j != D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] -= ways[i][s - 1][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] -= ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 2] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 2] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 0] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 0] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 0] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 0] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - -1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - -1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 1] for i in range(m - 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m - 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 1] for i in range(m * 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m * 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(2, m + 1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(2, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(0, m + 1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(0, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(0, m + 1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(0, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(-1, m + 1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(-1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(1, m - 1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m - 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(1, m * 1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m * 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k > 0 and (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k > 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k < 0 and (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k < 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k == 0 and (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k == 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k >= 0 and (j, k) in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 2\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 0\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 0\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= -1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[1] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[1] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[-1] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[-1] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[1] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[1] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] * D[i] for _ in range(M - 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M - 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] * D[i] for _ in range(M * 1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M * 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][1][j] = 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][1][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][-1][j] = 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][-1][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ways[i][0][j] = 1",
      "mutated_line": "ways[i][1][j] = 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][1][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - 2:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 2:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 0:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 0:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - -1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - -1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 1:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if j > 0:",
      "mutated_line": "if j > -1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > -1:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 1:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] + 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] + 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] * 1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] * 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[1][i][x[0] - 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[1][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[-1][i][x[0] - 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[-1][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[1][i][x[0] - 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[1][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[1] - 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[1] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[-1] - 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[-1] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[1] - 1] for i in range(m + 1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[1] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 2)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 2)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 0)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 0)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 0)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 0)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "total = [ways[0][i][x[0] - 1] for i in range(m + 1)]",
      "mutated_line": "total = [ways[0][i][x[0] - 1] for i in range(m + -1)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + -1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(1, m + 2)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 2)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(1, m + 0)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 0)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(1, m + 0)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 0)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in reversed(range(1, m + 1)):",
      "mutated_line": "for j in reversed(range(1, m + -1)):",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + -1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k >= 1 and (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 1 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k >= -1 and (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= -1 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while k >= 0 and (j, k) not in c:",
      "mutated_line": "while k >= 1 and (j, k) not in c:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 1 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] / ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] / ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] + ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] + ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum(((total[k] * c[j, k]) ** ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum(((total[k] * c[j, k]) ** ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] * D[i] for _ in range(M + 2)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 2)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] * D[i] for _ in range(M + 0)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 0)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] * D[i] for _ in range(M + 0)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 0)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]",
      "mutated_line": "ways = [[[0] * D[i] for _ in range(M + -1)] for i in range(N)]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + -1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][2][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][2][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][0][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][0][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][0][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][0][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][-1][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][-1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][2][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][2][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][0][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][0][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][0][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][0][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ways[i][1][j] += 1",
      "mutated_line": "ways[i][-1][j] += 1",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][-1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j * 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j * 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - 2:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 2:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 0:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - 0:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 0:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if j < D[i] - 1:",
      "mutated_line": "if j < D[i] - -1:",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - -1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j * 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j * 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] / c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] / c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum(((total[k] + c[j, k]) * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum(((total[k] + c[j, k]) * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] ** c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] ** c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s + 1][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s + 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s * 1][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s * 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j - 2]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 2]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j - 0]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 0]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j - 0]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 0]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j - -1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - -1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s + 1][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s + 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s * 1][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s * 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j + 2]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 2]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j + 0]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 0]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j + 0]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 0]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 1][j + -1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + -1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] + 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] + 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] * 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] * 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j - 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j - 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j * 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j * 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 2][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 2][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 0][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 0][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 0][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 0][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j - 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - -1][j - 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - -1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 2][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 2][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 0][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 0][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - 0][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 0][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ways[i][s][j] += ways[i][s - 1][j + 1]",
      "mutated_line": "ways[i][s][j] += ways[i][s - -1][j + 1]",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - -1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j + k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j + k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j * k][x[i] - 1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j * k][x[i] - 1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 2] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 2] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 0] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 0] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 0] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 0] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - -1] for k in range(j + 1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - -1] for k in range(j + 1)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 2)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 2)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 0)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 0)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 0)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 0)))\n    return total[m] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + 1)))",
      "mutated_line": "total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + -1)))",
      "code": "MOD = 1000000007\n\ndef choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    (p, q) = (1, 1)\n    for i in range(1, min(k, n - k) + 1):\n        p *= n\n        q *= i\n        n -= 1\n    return p // q\n\ndef count_ways(N, M, D):\n    ways = [[[0] * D[i] for _ in range(M + 1)] for i in range(N)]\n    for i in range(N):\n        for j in range(D[i]):\n            ways[i][0][j] = 1\n            if j > 0:\n                ways[i][1][j] += 1\n            if j < D[i] - 1:\n                ways[i][1][j] += 1\n        for s in range(2, M + 1):\n            for j in range(D[i]):\n                if j > 0:\n                    ways[i][s][j] += ways[i][s - 1][j - 1]\n                if j < D[i] - 1:\n                    ways[i][s][j] += ways[i][s - 1][j + 1]\n    return ways\n\ndef grid_walking(m, x, D):\n    N = len(x)\n    ways = count_ways(N, m, D)\n    total = [ways[0][i][x[0] - 1] for i in range(m + 1)]\n    c = {}\n    for i in range(1, N):\n        for j in reversed(range(1, m + 1)):\n            k = j\n            while k >= 0 and (j, k) not in c:\n                c[j, k] = choose(j, k)\n                k -= 1\n            total[j] = sum((total[k] * c[j, k] * ways[i][j - k][x[i] - 1] for k in range(j + -1)))\n    return total[m] % MOD"
    }
  ]
}