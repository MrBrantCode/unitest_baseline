{
  "task_id": "taco_10047",
  "entry_point": "calculate_explosion_times",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] / len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] + len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] ** len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) > 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) > 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) < 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) < 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) == 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) == 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) > 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) > 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) < 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) < 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) == 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) == 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) < 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) < 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) > 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) > 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) == 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) == 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(stack2) == 2:",
      "mutated_line": "if len(stack2) != 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) != 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "proc(1)",
      "mutated_line": "proc(2)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(2)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "proc(1)",
      "mutated_line": "proc(0)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(0)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "proc(1)",
      "mutated_line": "proc(0)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(0)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "proc(1)",
      "mutated_line": "proc(-1)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(-1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "proc(0)",
      "mutated_line": "proc(1)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "proc(0)",
      "mutated_line": "proc(-1)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(-1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "proc(0)",
      "mutated_line": "proc(1)",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d != 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [2 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [0 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [0 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [-1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else +1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [+1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if p & 1 == val:",
      "mutated_line": "if p & 1 != val:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 != val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 or stack2 or stack2[-1][1] == 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 or stack2 or stack2[-1][1] == 1:\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 3:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 3:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 1:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 0:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 1:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= -2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= -2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 3:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 3:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 1:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 0:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 1:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(stack2) >= 2:",
      "mutated_line": "while len(stack2) >= -2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= -2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) <= 3",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 3\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) <= 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 1\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) <= 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 0\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) <= 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 1\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "assert len(stack2) <= 2",
      "mutated_line": "assert len(stack2) <= -2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= -2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(stack2) == 2:",
      "mutated_line": "if len(stack2) == 3:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 3:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(stack2) == 2:",
      "mutated_line": "if len(stack2) == 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 1:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(stack2) == 2:",
      "mutated_line": "if len(stack2) == 0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 0:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(stack2) == 2:",
      "mutated_line": "if len(stack2) == 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 1:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(stack2) == 2:",
      "mutated_line": "if len(stack2) == -2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == -2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 or stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 or stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == '' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -2 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -0 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -0 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dir_values = [1 if d == 'R' else -1 for d in directions]",
      "mutated_line": "zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else --1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-2] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-0] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-0] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res = [-1] * len(zrr)",
      "mutated_line": "",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [--1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if p & 1 == val:",
      "mutated_line": "if p | 1 == val:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p | 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d != -1 and stack2 and (stack2[-1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d != -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][1] != 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] != 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not d == d2 == -1:",
      "mutated_line": "if not d != d2 == -1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d != d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "t = p2 + p >> 1",
      "mutated_line": "t = p2 - p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 - p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "t = p2 + p >> 1",
      "mutated_line": "t = p2 * p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 * p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "t = p2 + p >> 1",
      "mutated_line": "t = p2 + p >> 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 2\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "t = p2 + p >> 1",
      "mutated_line": "t = p2 + p >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 0\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "t = p2 + p >> 1",
      "mutated_line": "t = p2 + p >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 0\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "t = p2 + p >> 1",
      "mutated_line": "t = p2 + p >> -1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> -1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if not d == d2 == 1:",
      "mutated_line": "if not d != d2 == 1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d != d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m - p2 + m + p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m + p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = (m - p2 + m) * p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = (m - p2 + m) * p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m - p2 + m - p >> 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 2\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m - p2 + m - p >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 0\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m - p2 + m - p >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 0\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m - p2 + m - p >> -1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> -1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] != -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] != -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][1] != 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] != 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + (m - p2) - p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) - p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = (m + (m - p2)) * p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = (m + (m - p2)) * p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + (m - p2) + p >> 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 2\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + (m - p2) + p >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 0\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + (m - p2) + p >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 0\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + (m - p2) + p >> -1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> -1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p & 1 == val:",
      "mutated_line": "if p & 2 == val:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 2 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p & 1 == val:",
      "mutated_line": "if p & 0 == val:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 0 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p & 1 == val:",
      "mutated_line": "if p & 0 == val:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 0 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p & 1 == val:",
      "mutated_line": "if p & -1 == val:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & -1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == +1 and stack2 and (stack2[-1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == +1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][1] == 2):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 2):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][1] == 0):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 0):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][1] == 0):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 0):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][1] == -1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == -1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "t = abs(p2 - p) >> 1",
      "mutated_line": "t = abs(p2 - p) >> 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 2\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "t = abs(p2 - p) >> 1",
      "mutated_line": "t = abs(p2 - p) >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 0\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "t = abs(p2 - p) >> 1",
      "mutated_line": "t = abs(p2 - p) >> 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 0\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "t = abs(p2 - p) >> 1",
      "mutated_line": "t = abs(p2 - p) >> -1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> -1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if not d == d2 == -1:",
      "mutated_line": "if not d == d2 == +1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == +1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not d == d2 == 1:",
      "mutated_line": "if not d == d2 == 2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 2:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not d == d2 == 1:",
      "mutated_line": "if not d == d2 == 0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 0:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not d == d2 == 1:",
      "mutated_line": "if not d == d2 == 0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 0:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if not d == d2 == 1:",
      "mutated_line": "if not d == d2 == -1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == -1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m - p2 - m - p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 - m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = (m - p2) * m - p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = (m - p2) * m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == +1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == +1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][1] == 2",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 2\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][1] == 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 0\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][1] == 0",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 0\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][1] == -1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == -1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m - (m - p2) + p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m - (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m * (m - p2) + p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m * (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -2 and stack2 and (stack2[-1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -2 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -0 and stack2 and (stack2[-1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -0 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -0 and stack2 and (stack2[-1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -0 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == --1 and stack2 and (stack2[-1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == --1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][2] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][2] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][0] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][0] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][0] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][0] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-1][-1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][-1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "t = abs(p2 - p) >> 1",
      "mutated_line": "t = abs(p2 + p) >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 + p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "t = abs(p2 - p) >> 1",
      "mutated_line": "t = abs(p2 * p) >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 * p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not d == d2 == -1:",
      "mutated_line": "if not d == d2 == -2:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -2:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not d == d2 == -1:",
      "mutated_line": "if not d == d2 == -0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -0:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not d == d2 == -1:",
      "mutated_line": "if not d == d2 == -0:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -0:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not d == d2 == -1:",
      "mutated_line": "if not d == d2 == --1:",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == --1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m + p2 + m - p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m + p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t = m - p2 + m - p >> 1",
      "mutated_line": "t = m * p2 + m - p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m * p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][2] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][2] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][0] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][0] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][0] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][0] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][-1] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][-1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -2 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -2 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -0 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -0 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -0 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -0 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == --1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == --1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][2] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][2] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][0] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][0] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][0] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][0] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[1][-1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][-1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + (m + p2) + p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m + p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "t = m + (m - p2) + p >> 1",
      "mutated_line": "t = m + m * p2 + p >> 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + m * p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[+1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[+1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[1][1] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[1][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[-1][1] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[-1][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[1][1] == -1 and stack2[1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[1][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[2][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[2][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[0][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[0][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[0][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[0][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "assert stack2[0][1] == -1 and stack2[1][1] == 1",
      "mutated_line": "assert stack2[0][1] == -1 and stack2[-1][1] == 1",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[-1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-2][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-2][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-0][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-0][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[-0][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[-0][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d == -1 and stack2 and (stack2[-1][1] == 1):",
      "mutated_line": "if d == -1 and stack2 and (stack2[--1][1] == 1):",
      "code": "def calculate_explosion_times(n, m, positions, directions):\n    dir_values = [1 if d == 'R' else -1 for d in directions]\n    zrr = [(pos, d, i) for (i, (pos, d)) in enumerate(zip(positions, dir_values))]\n    zrr.sort()\n    res = [-1] * len(zrr)\n\n    def proc(val):\n        stack2 = deque([])\n        for (p, d, i) in zrr:\n            if p & 1 == val:\n                continue\n            if d == -1 and stack2 and (stack2[--1][1] == 1):\n                (p2, d2, i2) = stack2.pop()\n                t = abs(p2 - p) >> 1\n                res[i] = t\n                res[i2] = t\n            else:\n                stack2.append((p, d, i))\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.popleft()\n            if not d == d2 == -1:\n                stack2.appendleft((p2, d2, i2))\n                stack2.appendleft((p, d, i))\n                break\n            t = p2 + p >> 1\n            res[i] = t\n            res[i2] = t\n        while len(stack2) >= 2:\n            (p, d, i) = stack2.pop()\n            (p2, d2, i2) = stack2.pop()\n            if not d == d2 == 1:\n                stack2.append((p2, d2, i2))\n                stack2.append((p, d, i))\n                break\n            t = m - p2 + m - p >> 1\n            res[i] = t\n            res[i2] = t\n        assert len(stack2) <= 2\n        if len(stack2) == 2:\n            assert stack2[0][1] == -1 and stack2[1][1] == 1\n            (p, d, i) = stack2.popleft()\n            (p2, d2, i2) = stack2.pop()\n            t = m + (m - p2) + p >> 1\n            res[i] = t\n            res[i2] = t\n    proc(1)\n    proc(0)\n    return res"
    }
  ]
}