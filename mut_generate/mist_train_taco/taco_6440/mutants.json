{
  "task_id": "taco_6440",
  "entry_point": "find_optimal_subarrays",
  "mutant_count": 137,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 2 + 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 + 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 2 * 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 * 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "balance = 0",
      "mutated_line": "balance = 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 1\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "balance = 0",
      "mutated_line": "balance = -1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = -1\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "balance = 0",
      "mutated_line": "balance = 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 1\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k >= 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k >= 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k <= 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k <= 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k != 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k != 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) / 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) / 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) * 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) * 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 2 - 2",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 2\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 2 - 0",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 0\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 2 - 0",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 0\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 2 - -1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - -1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] + b[0], 0, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] + b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] * b[0], 0, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] * b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] - b[0], 1, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 1, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] - b[0], -1, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], -1, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] - b[0], 1, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 1, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cd = b[i] - b[i - needed]",
      "mutated_line": "cd = b[i] + b[i - needed]",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] + b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cd = b[i] - b[i - needed]",
      "mutated_line": "cd = b[i] * b[i - needed]",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] * b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cd < md:",
      "mutated_line": "if cd <= md:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd <= md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cd < md:",
      "mutated_line": "if cd >= md:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd >= md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if cd < md:",
      "mutated_line": "if cd != md:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd != md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) > k - 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) > k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) < k - 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) < k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) == k - 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) == k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if b[ml] <= a[i] <= b[mr]:",
      "mutated_line": "if b[ml] < a[i] <= b[mr]:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] < a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if b[ml] <= a[i] <= b[mr]:",
      "mutated_line": "if b[ml] > a[i] <= b[mr]:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] > a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if b[ml] <= a[i] <= b[mr]:",
      "mutated_line": "if b[ml] == a[i] <= b[mr]:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] == a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "balance += 1",
      "mutated_line": "balance -= 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance -= 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "balance -= 1",
      "mutated_line": "balance += 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance += 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if balance > 0:",
      "mutated_line": "if balance >= 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance >= 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if balance > 0:",
      "mutated_line": "if balance <= 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance <= 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if balance > 0:",
      "mutated_line": "if balance != 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance != 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k > 2:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 2:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k > 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 0:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k > 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 0:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if k > 1:",
      "mutated_line": "if k > -1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > -1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k - 1) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k - 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k) * 1 // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k) * 1 // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 3 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 3 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 1 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 1 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 0 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 0 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // 1 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 1 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 1) // -2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // -2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) >= k + 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k + 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) >= k * 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k * 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "balance += 1",
      "mutated_line": "balance += 2",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 2\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "balance += 1",
      "mutated_line": "balance += 0",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 0\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "balance += 1",
      "mutated_line": "balance += 0",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 0\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "balance += 1",
      "mutated_line": "balance += -1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += -1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "balance -= 1",
      "mutated_line": "balance -= 2",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 2\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "balance -= 1",
      "mutated_line": "balance -= 0",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 0\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "balance -= 1",
      "mutated_line": "balance -= 0",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 0\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "balance -= 1",
      "mutated_line": "balance -= -1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= -1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if balance > 0:",
      "mutated_line": "if balance > 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 1:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if balance > 0:",
      "mutated_line": "if balance > -1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > -1:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if balance > 0:",
      "mutated_line": "if balance > 1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 1:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "balance = 0",
      "mutated_line": "balance = 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 1\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "balance = 0",
      "mutated_line": "balance = -1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = -1\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "balance = 0",
      "mutated_line": "balance = 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 1\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(2, k - 1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(2, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(0, k - 1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(0, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(0, k - 1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(0, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(-1, k - 1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(-1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(1, k + 1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k + 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(1, k * 1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k * 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n - k + 1) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n - k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n * k + 1) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n * k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 2) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 2) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 0) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 0) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + 0) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 0) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "needed = (n + k + 1) // 2 - 1",
      "mutated_line": "needed = (n + k + -1) // 2 - 1",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + -1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] - b[1], 0, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[1], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] - b[-1], 0, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[-1], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "md, ml, mr = b[needed] - b[0], 0, needed",
      "mutated_line": "(md, ml, mr) = (b[needed] - b[1], 0, needed)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[1], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cd = b[i] - b[i - needed]",
      "mutated_line": "cd = b[i] - b[i + needed]",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i + needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "cd = b[i] - b[i - needed]",
      "mutated_line": "cd = b[i] - b[i * needed]",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i * needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "md, ml, mr = cd, i - needed, i",
      "mutated_line": "(md, ml, mr) = (cd, i + needed, i)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i + needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "md, ml, mr = cd, i - needed, i",
      "mutated_line": "(md, ml, mr) = (cd, i * needed, i)",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i * needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) >= k - 2:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 2:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) >= k - 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 0:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) >= k - 0:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 0:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(splits) >= k - 1:",
      "mutated_line": "if len(splits) >= k - -1:",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - -1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((2, splits[0] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((2, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((0, splits[0] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((0, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((0, splits[0] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((0, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((-1, splits[0] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((-1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[0] - 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] - 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[0] * 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] * 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(1, k - 2):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 2):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(1, k - 0):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 0):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(1, k - 0):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 0):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, k - 1):",
      "mutated_line": "for i in range(1, k - -1):",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - -1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] - 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] - 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] * 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] * 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "subarrays.append((1, n))",
      "mutated_line": "subarrays.append((2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((2, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "subarrays.append((1, n))",
      "mutated_line": "subarrays.append((0, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((0, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "subarrays.append((1, n))",
      "mutated_line": "subarrays.append((0, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((0, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "subarrays.append((1, n))",
      "mutated_line": "subarrays.append((-1, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((-1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[0] + 2))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 2))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[0] + 0))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 0))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[0] + 0))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 0))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[0] + -1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + -1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] - 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] - 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] * 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] * 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 2, splits[i] - 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] - 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 2, splits[i] * 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] * 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] + 3, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 3, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] + 1, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 1, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] + 0, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 0, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] + 1, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 1, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-1] + -2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + -2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[1] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[1] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[-1] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[-1] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "subarrays.append((1, splits[0] + 1))",
      "mutated_line": "subarrays.append((1, splits[1] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[1] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 3, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 3, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 1, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 1, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 0, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 0, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 1, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 1, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + -2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + -2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 2))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 2))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 0))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 0))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 0))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 0))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 1] + 2, splits[i] + -1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + -1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[+1] + 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[+1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i + 1] + 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i + 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i * 1] + 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i * 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-2] + 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-2] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-0] + 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-0] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[-0] + 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[-0] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subarrays.append((splits[-1] + 2, n))",
      "mutated_line": "subarrays.append((splits[--1] + 2, n))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 1] + 2, splits[i] + 1))\n        subarrays.append((splits[--1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 2] + 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 2] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 0] + 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 0] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - 0] + 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - 0] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "subarrays.append((splits[i - 1] + 2, splits[i] + 1))",
      "mutated_line": "subarrays.append((splits[i - -1] + 2, splits[i] + 1))",
      "code": "def find_optimal_subarrays(n, k, a):\n    b = sorted(a)\n    needed = (n + k + 1) // 2 - 1\n    (md, ml, mr) = (b[needed] - b[0], 0, needed)\n    for i in range(needed, n):\n        cd = b[i] - b[i - needed]\n        if cd < md:\n            (md, ml, mr) = (cd, i - needed, i)\n    (x, y) = (b[ml], b[mr])\n    balance = 0\n    splits = []\n    for i in range(n):\n        if len(splits) >= k - 1:\n            break\n        if b[ml] <= a[i] <= b[mr]:\n            balance += 1\n        else:\n            balance -= 1\n        if balance > 0:\n            balance = 0\n            splits.append(i)\n    subarrays = []\n    if k > 1:\n        subarrays.append((1, splits[0] + 1))\n        for i in range(1, k - 1):\n            subarrays.append((splits[i - -1] + 2, splits[i] + 1))\n        subarrays.append((splits[-1] + 2, n))\n    else:\n        subarrays.append((1, n))\n    return (x, y, subarrays)"
    }
  ]
}