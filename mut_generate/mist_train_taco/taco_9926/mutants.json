{
  "task_id": "taco_9926",
  "entry_point": "gcd",
  "mutant_count": 155,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 - 7",
      "code": "large_int = 10 ** 9 - 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 * 7",
      "code": "large_int = 10 ** 9 * 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 * 9 + 7",
      "code": "large_int = 10 * 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 + 9 + 7",
      "code": "large_int = 10 + 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 + 8",
      "code": "large_int = 10 ** 9 + 8\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 + 6",
      "code": "large_int = 10 ** 9 + 6\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 + 0",
      "code": "large_int = 10 ** 9 + 0\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 + 1",
      "code": "large_int = 10 ** 9 + 1\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 9 + -7",
      "code": "large_int = 10 ** 9 + -7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if a % b == 0:",
      "mutated_line": "if a % b != 0:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b != 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a * b // gcd(a, b)",
      "mutated_line": "return a * b / gcd(a, b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b / gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a * b // gcd(a, b)",
      "mutated_line": "return a * b * gcd(a, b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b * gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 and (c_start - b_start) % b_step != 0 and (c_start < b_start) and (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 and (c_start - b_start) % b_step != 0 and (c_start < b_start) and (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step and c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step and c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 1\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = -1\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 1\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count -= c_step // i * (c_step // i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count -= c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return count % large_int",
      "mutated_line": "return count * large_int",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count * large_int"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return count % large_int",
      "mutated_line": "return count + large_int",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count + large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 11 ** 9 + 7",
      "code": "large_int = 11 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 9 ** 9 + 7",
      "code": "large_int = 9 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 0 ** 9 + 7",
      "code": "large_int = 0 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 1 ** 9 + 7",
      "code": "large_int = 1 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = -10 ** 9 + 7",
      "code": "large_int = -10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 10 + 7",
      "code": "large_int = 10 ** 10 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 8 + 7",
      "code": "large_int = 10 ** 8 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 0 + 7",
      "code": "large_int = 10 ** 0 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** 1 + 7",
      "code": "large_int = 10 ** 1 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "large_int = 10 ** 9 + 7",
      "mutated_line": "large_int = 10 ** -9 + 7",
      "code": "large_int = 10 ** -9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if a % b == 0:",
      "mutated_line": "if a * b == 0:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a * b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if a % b == 0:",
      "mutated_line": "if a + b == 0:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a + b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % b == 0:",
      "mutated_line": "if a % b == 1:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 1:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % b == 0:",
      "mutated_line": "if a % b == -1:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == -1:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % b == 0:",
      "mutated_line": "if a % b == 1:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 1:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a * b // gcd(a, b)",
      "mutated_line": "return a / b // gcd(a, b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a / b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a * b // gcd(a, b)",
      "mutated_line": "return (a + b) // gcd(a, b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a + b) // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a * b // gcd(a, b)",
      "mutated_line": "return a ** b // gcd(a, b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a ** b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step == 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step == 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step == 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step == 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start <= b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start <= b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start >= b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start >= b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start != b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start != b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step >= b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step >= b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step <= b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step <= b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step != b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step != b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 1\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return -1\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 1\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step >= b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step >= b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step <= b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step <= b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step != b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step != b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step <= b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step <= b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step >= b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step >= b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step != b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step != b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return +1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i < c_step // b_step and lcm(b_step, i) < c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step and lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += c_step // i / (c_step // i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i / (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += c_step // i + c_step // i",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i + c_step // i\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += (c_step // i) ** (c_step // i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += (c_step // i) ** (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return gcd(b, a % b)",
      "mutated_line": "return gcd(b, a * b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a * b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return gcd(b, a % b)",
      "mutated_line": "return gcd(b, a + b)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a + b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step * b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step * b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step + b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step + b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 1 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 1 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != -1 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != -1 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 1 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 1 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) * b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) * b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or c_start - b_start + b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or c_start - b_start + b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 1 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 1 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != -1 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != -1 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 1 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 1 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start - (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start - (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start * ((c_n - 1) * c_step) > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start * ((c_n - 1) * c_step) > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start - (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start - (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start * ((b_n - 1) * b_step)):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start * ((b_n - 1) * b_step)):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start - c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start - c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start * (c_n * c_step) > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start * (c_n * c_step) > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start - (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start - (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start * ((b_n - 1) * b_step) or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start * ((b_n - 1) * b_step) or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start + c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start + c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start * c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start * c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -2\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -0\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -0\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return --1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i <= c_step // b_step or lcm(b_step, i) < c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i <= c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i >= c_step // b_step or lcm(b_step, i) < c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i >= c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i != c_step // b_step or lcm(b_step, i) < c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i != c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i < c_step // b_step or lcm(b_step, i) <= c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) <= c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i < c_step // b_step or lcm(b_step, i) >= c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) >= c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i < c_step // b_step or lcm(b_step, i) != c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) != c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += c_step / i * (c_step // i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step / i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += c_step * i * (c_step // i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step * i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += c_step // i * (c_step / i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step / i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "count += c_step // i * (c_step // i)",
      "mutated_line": "count += c_step // i * (c_step * i)",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step * i)\n    return count % large_int"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i != 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i != 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start + b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start + b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or c_start * b_start % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or c_start * b_start % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) / c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) / c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1 + c_step) > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1 + c_step) > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) ** c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) ** c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) / b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) / b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1 + b_step)):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1 + b_step)):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) ** b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) ** b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n / c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n / c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + (c_n + c_step) > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + (c_n + c_step) > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n ** c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n ** c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) / b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) / b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1 + b_step) or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1 + b_step) or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 1) ** b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) ** b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i < c_step / b_step or lcm(b_step, i) < c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step / b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i < c_step // b_step or lcm(b_step, i) < c_step:",
      "mutated_line": "if i < c_step * b_step or lcm(b_step, i) < c_step:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step * b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(2, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(2, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(0, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(0, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(0, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(0, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(-1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(-1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) - 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) - 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) * 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) * 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n * i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n * i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n + i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n + i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 1 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 1 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == -1 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == -1 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 1 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 1 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n / i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n / i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n * i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n * i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n + 1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n + 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + c_n * 1 * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + c_n * 1 * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n + 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n + 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + b_n * 1 * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + b_n * 1 * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n + 1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n + 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + b_n * 1 * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + b_n * 1 * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 2) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 2) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 0) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 0) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + 0) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 0) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0.5) + -1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + -1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 2) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 2) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 0) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 0) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 0) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 0) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - -1) * c_step > b_start + (b_n - 1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - -1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 2) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 2) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 0) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 0) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 0) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 0) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):",
      "mutated_line": "if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - -1) * b_step):",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - -1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 2) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 2) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 0) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 0) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - 0) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 0) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:",
      "mutated_line": "if c_start + c_n * c_step > b_start + (b_n - -1) * b_step or c_start - c_step < b_start:",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - -1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n * 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n * 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n + 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n + 0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 1.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 1.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** -0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** -0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 0) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 0) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** 1) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** 1) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return set((factor for i in range(1, int(n ** 0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "mutated_line": "return set((factor for i in range(1, int(n ** -0.5) + 1) if n % i == 0 for factor in (i, n // i)))",
      "code": "large_int = 10 ** 9 + 7\n\ndef gcd(a, b):\n    if a % b == 0:\n        return b\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef factors(n):\n    return set((factor for i in range(1, int(n ** -0.5) + 1) if n % i == 0 for factor in (i, n // i)))\n\ndef count_possible_progressions(b_start, b_step, b_n, c_start, c_step, c_n):\n    if c_step % b_step != 0 or (c_start - b_start) % b_step != 0 or c_start < b_start or (c_start + (c_n - 1) * c_step > b_start + (b_n - 1) * b_step):\n        return 0\n    if c_start + c_n * c_step > b_start + (b_n - 1) * b_step or c_start - c_step < b_start:\n        return -1\n    count = 0\n    for i in factors(c_step):\n        if i < c_step // b_step or lcm(b_step, i) < c_step:\n            continue\n        count += c_step // i * (c_step // i)\n    return count % large_int"
    }
  ]
}