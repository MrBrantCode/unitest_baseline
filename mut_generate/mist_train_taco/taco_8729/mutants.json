{
  "task_id": "taco_8729",
  "entry_point": "max_possible_sets",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] / n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] / n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] + n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] + n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] ** n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] ** n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ok = True",
      "mutated_line": "ok = False",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = False\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[1000] / n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] / n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[1000] + n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] + n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[1000] ** n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] ** n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat[i][i] = 0",
      "mutated_line": "mat[i][i] = 1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 1\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat[i][i] = 0",
      "mutated_line": "mat[i][i] = -1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = -1\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mat[i][i] = 0",
      "mutated_line": "mat[i][i] = 1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 1\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dist[v] == d:",
      "mutated_line": "if dist[v] != d:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] != d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] != -1:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] != -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 1\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = -1\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 1\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return ans + 1",
      "mutated_line": "return ans - 1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans - 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return ans + 1",
      "mutated_line": "return ans * 1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans * 1\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return +1"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if S[i][j] == '1':",
      "mutated_line": "if S[i][j] != '1':",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] != '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [+1] * n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [+1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dq.append((0, 0))",
      "mutated_line": "dq.append((1, 0))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((1, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dq.append((0, 0))",
      "mutated_line": "dq.append((-1, 0))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((-1, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dq.append((0, 0))",
      "mutated_line": "dq.append((1, 0))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((1, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dq.append((0, 0))",
      "mutated_line": "dq.append((0, 1))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 1))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dq.append((0, 0))",
      "mutated_line": "dq.append((0, -1))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, -1))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dq.append((0, 0))",
      "mutated_line": "dq.append((0, 1))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 1))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == +1:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == +1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ok = False",
      "mutated_line": "ok = True",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = True\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if dist[item] == -1:",
      "mutated_line": "if dist[item] != -1:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] != -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + 2",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 2\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + 0",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 0\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + 0",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 0\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + -1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + -1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[1001] * n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1001] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[999] * n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[999] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[0] * n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[1] * n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mat = [[1000] * n for _ in range(n)]",
      "mutated_line": "mat = [[-1000] * n for _ in range(n)]",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[-1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if S[i][j] == '1':",
      "mutated_line": "if S[i][j] == '':",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mat[i][j] = 1",
      "mutated_line": "mat[i][j] = 2",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 2\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mat[i][j] = 1",
      "mutated_line": "mat[i][j] = 0",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 0\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mat[i][j] = 1",
      "mutated_line": "mat[i][j] = 0",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 0\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mat[i][j] = 1",
      "mutated_line": "mat[i][j] = -1",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = -1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if j > i:",
      "mutated_line": "if j >= i:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j >= i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if j > i:",
      "mutated_line": "if j <= i:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j <= i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if j > i:",
      "mutated_line": "if j != i:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j != i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-2] * n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-2] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-0] * n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-0] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-0] * n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-0] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [--1] * n",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [--1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == -2:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -2:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == -0:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -0:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == -0:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -0:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if dist[v] == -1:",
      "mutated_line": "if dist[v] == --1:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == --1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "if dist[item] == -1:",
      "mutated_line": "if dist[item] == +1:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == +1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])",
      "mutated_line": "mat[i][j] = min(mat[i][j], mat[i][k] - mat[k][j])",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] - mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])",
      "mutated_line": "mat[i][j] = min(mat[i][j], mat[i][k] * mat[k][j])",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] * mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dist[item] == -1:",
      "mutated_line": "if dist[item] == -2:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -2:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dist[item] == -1:",
      "mutated_line": "if dist[item] == -0:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -0:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dist[item] == -1:",
      "mutated_line": "if dist[item] == -0:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -0:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if dist[item] == -1:",
      "mutated_line": "if dist[item] == --1:",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == --1:\n                dq.append((item, d + 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dq.append((item, d + 1))",
      "mutated_line": "dq.append((item, d - 1))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d - 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dq.append((item, d + 1))",
      "mutated_line": "dq.append((item, d * 1))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d * 1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dq.append((item, d + 1))",
      "mutated_line": "dq.append((item, d + 2))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 2))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dq.append((item, d + 1))",
      "mutated_line": "dq.append((item, d + 0))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 0))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dq.append((item, d + 1))",
      "mutated_line": "dq.append((item, d + 0))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + 0))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dq.append((item, d + 1))",
      "mutated_line": "dq.append((item, d + -1))",
      "code": "from collections import deque\n\ndef max_possible_sets(n, S):\n    edge = [[] for _ in range(n)]\n    mat = [[1000] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if S[i][j] == '1':\n                mat[i][j] = 1\n                if j > i:\n                    edge[i].append(j)\n                    edge[j].append(i)\n    for i in range(n):\n        mat[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j])\n    dq = deque()\n    dist = [-1] * n\n    dq.append((0, 0))\n    ok = True\n    while dq:\n        (v, d) = dq.popleft()\n        if dist[v] == d:\n            continue\n        if dist[v] == -1:\n            dist[v] = d\n        else:\n            ok = False\n            break\n        for item in edge[v]:\n            if dist[item] == -1:\n                dq.append((item, d + -1))\n    if ok:\n        ans = 0\n        for line in mat:\n            ans = max(ans, max(line))\n        return ans + 1\n    else:\n        return -1"
    }
  ]
}