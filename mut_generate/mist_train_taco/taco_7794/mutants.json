{
  "task_id": "taco_7794",
  "entry_point": "shortest_path_dijkstra",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def shortest_path_dijkstra(n, adj_list, start=0):",
      "mutated_line": "def shortest_path_dijkstra(n, adj_list, start=1):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=1):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def shortest_path_dijkstra(n, adj_list, start=0):",
      "mutated_line": "def shortest_path_dijkstra(n, adj_list, start=-1):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=-1):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def shortest_path_dijkstra(n, adj_list, start=0):",
      "mutated_line": "def shortest_path_dijkstra(n, adj_list, start=1):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=1):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] / n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] / n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] + n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] + n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] ** n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] ** n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10000000000",
      "mutated_line": "INF = 10000000001",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000001\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10000000000",
      "mutated_line": "INF = 9999999999",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 9999999999\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10000000000",
      "mutated_line": "INF = 0",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 0\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10000000000",
      "mutated_line": "INF = 1",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 1\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10000000000",
      "mutated_line": "INF = -10000000000",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = -10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [INF] * n",
      "mutated_line": "d = [INF] / n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] / n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [INF] * n",
      "mutated_line": "d = [INF] + n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] + n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [INF] * n",
      "mutated_line": "d = [INF] ** n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] ** n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[start] = 0",
      "mutated_line": "d[start] = 1",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 1\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[start] = 0",
      "mutated_line": "d[start] = -1",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = -1\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[start] = 0",
      "mutated_line": "d[start] = 1",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 1\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited[start] = True",
      "mutated_line": "visited[start] = False",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = False\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n + 1):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n + 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n * 1):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n * 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while False:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[min_node] = True",
      "mutated_line": "visited[min_node] = False",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = False\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [True] * n",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [True] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - 2):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 2):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - 0):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 0):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - 0):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 0):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for _ in range(n - 1):",
      "mutated_line": "for _ in range(n - -1):",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - -1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_weight = tmp[0]",
      "mutated_line": "min_weight = tmp[1]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[1]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_weight = tmp[0]",
      "mutated_line": "min_weight = tmp[-1]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[-1]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_weight = tmp[0]",
      "mutated_line": "min_weight = tmp[1]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[1]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "min_node = tmp[1]",
      "mutated_line": "min_node = tmp[2]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[2]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "min_node = tmp[1]",
      "mutated_line": "min_node = tmp[0]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[0]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "min_node = tmp[1]",
      "mutated_line": "min_node = tmp[0]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[0]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "min_node = tmp[1]",
      "mutated_line": "min_node = tmp[-1]",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[-1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not visited[adj_weight[0]]:",
      "mutated_line": "if not visited[adj_weight[1]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[1]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not visited[adj_weight[0]]:",
      "mutated_line": "if not visited[adj_weight[-1]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[-1]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if not visited[adj_weight[0]]:",
      "mutated_line": "if not visited[adj_weight[1]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[1]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] - adj_weight[1], adj_weight[0]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] - adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] * adj_weight[1], adj_weight[0]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] * adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not visited[tmp[1]]:",
      "mutated_line": "if not visited[tmp[2]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[2]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not visited[tmp[1]]:",
      "mutated_line": "if not visited[tmp[0]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[0]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not visited[tmp[1]]:",
      "mutated_line": "if not visited[tmp[0]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[0]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not visited[tmp[1]]:",
      "mutated_line": "if not visited[tmp[-1]]:",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[-1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[1]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[1]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[-1]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[-1]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[1]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[1]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[2], adj_weight[0]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[2], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[0], adj_weight[0]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[0], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[0], adj_weight[0]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[0], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(q, (d[add_node] + adj_weight[1], adj_weight[0]))",
      "mutated_line": "heapq.heappush(q, (d[add_node] + adj_weight[-1], adj_weight[0]))",
      "code": "import heapq\n\ndef shortest_path_dijkstra(n, adj_list, start=0):\n    visited = [False] * n\n    INF = 10000000000\n    d = [INF] * n\n    d[start] = 0\n    visited[start] = True\n    q = []\n    add_node = start\n    for _ in range(n - 1):\n        for adj_weight in adj_list[add_node]:\n            if not visited[adj_weight[0]]:\n                heapq.heappush(q, (d[add_node] + adj_weight[-1], adj_weight[0]))\n        while True:\n            tmp = heapq.heappop(q)\n            if not visited[tmp[1]]:\n                min_weight = tmp[0]\n                min_node = tmp[1]\n                break\n        add_node = min_node\n        visited[min_node] = True\n        d[min_node] = min_weight\n    return d"
    }
  ]
}